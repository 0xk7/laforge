// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/predicate"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgentStatus        = "AgentStatus"
	TypeBuild              = "Build"
	TypeCommand            = "Command"
	TypeCompetition        = "Competition"
	TypeDNS                = "DNS"
	TypeDNSRecord          = "DNSRecord"
	TypeDisk               = "Disk"
	TypeEnvironment        = "Environment"
	TypeFileDelete         = "FileDelete"
	TypeFileDownload       = "FileDownload"
	TypeFileExtract        = "FileExtract"
	TypeFinding            = "Finding"
	TypeHost               = "Host"
	TypeHostDependency     = "HostDependency"
	TypeIdentity           = "Identity"
	TypeIncludedNetwork    = "IncludedNetwork"
	TypeNetwork            = "Network"
	TypeProvisionedHost    = "ProvisionedHost"
	TypeProvisionedNetwork = "ProvisionedNetwork"
	TypeProvisioningStep   = "ProvisioningStep"
	TypeScript             = "Script"
	TypeStatus             = "Status"
	TypeTag                = "Tag"
	TypeTeam               = "Team"
	TypeUser               = "User"
)

// AgentStatusMutation represents an operation that mutates the AgentStatus nodes in the graph.
type AgentStatusMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	_ClientID                            *string
	_Hostname                            *string
	_UpTime                              *int64
	add_UpTime                           *int64
	_BootTime                            *int64
	add_BootTime                         *int64
	_NumProcs                            *int64
	add_NumProcs                         *int64
	_Os                                  *string
	_HostID                              *string
	_Load1                               *float64
	add_Load1                            *float64
	_Load5                               *float64
	add_Load5                            *float64
	_Load15                              *float64
	add_Load15                           *float64
	_TotalMem                            *int64
	add_TotalMem                         *int64
	_FreeMem                             *int64
	add_FreeMem                          *int64
	_UsedMem                             *int64
	add_UsedMem                          *int64
	_Timestamp                           *int64
	add_Timestamp                        *int64
	clearedFields                        map[string]struct{}
	_AgentStatusToTag                    map[int]struct{}
	removed_AgentStatusToTag             map[int]struct{}
	cleared_AgentStatusToTag             bool
	_AgentStatusToProvisionedHost        map[int]struct{}
	removed_AgentStatusToProvisionedHost map[int]struct{}
	cleared_AgentStatusToProvisionedHost bool
	done                                 bool
	oldValue                             func(context.Context) (*AgentStatus, error)
	predicates                           []predicate.AgentStatus
}

var _ ent.Mutation = (*AgentStatusMutation)(nil)

// agentstatusOption allows management of the mutation configuration using functional options.
type agentstatusOption func(*AgentStatusMutation)

// newAgentStatusMutation creates new mutation for the AgentStatus entity.
func newAgentStatusMutation(c config, op Op, opts ...agentstatusOption) *AgentStatusMutation {
	m := &AgentStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentStatusID sets the ID field of the mutation.
func withAgentStatusID(id int) agentstatusOption {
	return func(m *AgentStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentStatus
		)
		m.oldValue = func(ctx context.Context) (*AgentStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentStatus sets the old AgentStatus of the mutation.
func withAgentStatus(node *AgentStatus) agentstatusOption {
	return func(m *AgentStatusMutation) {
		m.oldValue = func(context.Context) (*AgentStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AgentStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClientID sets the "ClientID" field.
func (m *AgentStatusMutation) SetClientID(s string) {
	m._ClientID = &s
}

// ClientID returns the value of the "ClientID" field in the mutation.
func (m *AgentStatusMutation) ClientID() (r string, exists bool) {
	v := m._ClientID
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "ClientID" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "ClientID" field.
func (m *AgentStatusMutation) ResetClientID() {
	m._ClientID = nil
}

// SetHostname sets the "Hostname" field.
func (m *AgentStatusMutation) SetHostname(s string) {
	m._Hostname = &s
}

// Hostname returns the value of the "Hostname" field in the mutation.
func (m *AgentStatusMutation) Hostname() (r string, exists bool) {
	v := m._Hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "Hostname" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "Hostname" field.
func (m *AgentStatusMutation) ResetHostname() {
	m._Hostname = nil
}

// SetUpTime sets the "UpTime" field.
func (m *AgentStatusMutation) SetUpTime(i int64) {
	m._UpTime = &i
	m.add_UpTime = nil
}

// UpTime returns the value of the "UpTime" field in the mutation.
func (m *AgentStatusMutation) UpTime() (r int64, exists bool) {
	v := m._UpTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpTime returns the old "UpTime" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldUpTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpTime: %w", err)
	}
	return oldValue.UpTime, nil
}

// AddUpTime adds i to the "UpTime" field.
func (m *AgentStatusMutation) AddUpTime(i int64) {
	if m.add_UpTime != nil {
		*m.add_UpTime += i
	} else {
		m.add_UpTime = &i
	}
}

// AddedUpTime returns the value that was added to the "UpTime" field in this mutation.
func (m *AgentStatusMutation) AddedUpTime() (r int64, exists bool) {
	v := m.add_UpTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpTime resets all changes to the "UpTime" field.
func (m *AgentStatusMutation) ResetUpTime() {
	m._UpTime = nil
	m.add_UpTime = nil
}

// SetBootTime sets the "BootTime" field.
func (m *AgentStatusMutation) SetBootTime(i int64) {
	m._BootTime = &i
	m.add_BootTime = nil
}

// BootTime returns the value of the "BootTime" field in the mutation.
func (m *AgentStatusMutation) BootTime() (r int64, exists bool) {
	v := m._BootTime
	if v == nil {
		return
	}
	return *v, true
}

// OldBootTime returns the old "BootTime" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldBootTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBootTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBootTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootTime: %w", err)
	}
	return oldValue.BootTime, nil
}

// AddBootTime adds i to the "BootTime" field.
func (m *AgentStatusMutation) AddBootTime(i int64) {
	if m.add_BootTime != nil {
		*m.add_BootTime += i
	} else {
		m.add_BootTime = &i
	}
}

// AddedBootTime returns the value that was added to the "BootTime" field in this mutation.
func (m *AgentStatusMutation) AddedBootTime() (r int64, exists bool) {
	v := m.add_BootTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetBootTime resets all changes to the "BootTime" field.
func (m *AgentStatusMutation) ResetBootTime() {
	m._BootTime = nil
	m.add_BootTime = nil
}

// SetNumProcs sets the "NumProcs" field.
func (m *AgentStatusMutation) SetNumProcs(i int64) {
	m._NumProcs = &i
	m.add_NumProcs = nil
}

// NumProcs returns the value of the "NumProcs" field in the mutation.
func (m *AgentStatusMutation) NumProcs() (r int64, exists bool) {
	v := m._NumProcs
	if v == nil {
		return
	}
	return *v, true
}

// OldNumProcs returns the old "NumProcs" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldNumProcs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumProcs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumProcs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumProcs: %w", err)
	}
	return oldValue.NumProcs, nil
}

// AddNumProcs adds i to the "NumProcs" field.
func (m *AgentStatusMutation) AddNumProcs(i int64) {
	if m.add_NumProcs != nil {
		*m.add_NumProcs += i
	} else {
		m.add_NumProcs = &i
	}
}

// AddedNumProcs returns the value that was added to the "NumProcs" field in this mutation.
func (m *AgentStatusMutation) AddedNumProcs() (r int64, exists bool) {
	v := m.add_NumProcs
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumProcs resets all changes to the "NumProcs" field.
func (m *AgentStatusMutation) ResetNumProcs() {
	m._NumProcs = nil
	m.add_NumProcs = nil
}

// SetOs sets the "Os" field.
func (m *AgentStatusMutation) SetOs(s string) {
	m._Os = &s
}

// Os returns the value of the "Os" field in the mutation.
func (m *AgentStatusMutation) Os() (r string, exists bool) {
	v := m._Os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "Os" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "Os" field.
func (m *AgentStatusMutation) ResetOs() {
	m._Os = nil
}

// SetHostID sets the "HostID" field.
func (m *AgentStatusMutation) SetHostID(s string) {
	m._HostID = &s
}

// HostID returns the value of the "HostID" field in the mutation.
func (m *AgentStatusMutation) HostID() (r string, exists bool) {
	v := m._HostID
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "HostID" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "HostID" field.
func (m *AgentStatusMutation) ResetHostID() {
	m._HostID = nil
}

// SetLoad1 sets the "Load1" field.
func (m *AgentStatusMutation) SetLoad1(f float64) {
	m._Load1 = &f
	m.add_Load1 = nil
}

// Load1 returns the value of the "Load1" field in the mutation.
func (m *AgentStatusMutation) Load1() (r float64, exists bool) {
	v := m._Load1
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad1 returns the old "Load1" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad1(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoad1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoad1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad1: %w", err)
	}
	return oldValue.Load1, nil
}

// AddLoad1 adds f to the "Load1" field.
func (m *AgentStatusMutation) AddLoad1(f float64) {
	if m.add_Load1 != nil {
		*m.add_Load1 += f
	} else {
		m.add_Load1 = &f
	}
}

// AddedLoad1 returns the value that was added to the "Load1" field in this mutation.
func (m *AgentStatusMutation) AddedLoad1() (r float64, exists bool) {
	v := m.add_Load1
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad1 resets all changes to the "Load1" field.
func (m *AgentStatusMutation) ResetLoad1() {
	m._Load1 = nil
	m.add_Load1 = nil
}

// SetLoad5 sets the "Load5" field.
func (m *AgentStatusMutation) SetLoad5(f float64) {
	m._Load5 = &f
	m.add_Load5 = nil
}

// Load5 returns the value of the "Load5" field in the mutation.
func (m *AgentStatusMutation) Load5() (r float64, exists bool) {
	v := m._Load5
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad5 returns the old "Load5" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad5(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoad5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoad5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad5: %w", err)
	}
	return oldValue.Load5, nil
}

// AddLoad5 adds f to the "Load5" field.
func (m *AgentStatusMutation) AddLoad5(f float64) {
	if m.add_Load5 != nil {
		*m.add_Load5 += f
	} else {
		m.add_Load5 = &f
	}
}

// AddedLoad5 returns the value that was added to the "Load5" field in this mutation.
func (m *AgentStatusMutation) AddedLoad5() (r float64, exists bool) {
	v := m.add_Load5
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad5 resets all changes to the "Load5" field.
func (m *AgentStatusMutation) ResetLoad5() {
	m._Load5 = nil
	m.add_Load5 = nil
}

// SetLoad15 sets the "Load15" field.
func (m *AgentStatusMutation) SetLoad15(f float64) {
	m._Load15 = &f
	m.add_Load15 = nil
}

// Load15 returns the value of the "Load15" field in the mutation.
func (m *AgentStatusMutation) Load15() (r float64, exists bool) {
	v := m._Load15
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad15 returns the old "Load15" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad15(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoad15 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoad15 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad15: %w", err)
	}
	return oldValue.Load15, nil
}

// AddLoad15 adds f to the "Load15" field.
func (m *AgentStatusMutation) AddLoad15(f float64) {
	if m.add_Load15 != nil {
		*m.add_Load15 += f
	} else {
		m.add_Load15 = &f
	}
}

// AddedLoad15 returns the value that was added to the "Load15" field in this mutation.
func (m *AgentStatusMutation) AddedLoad15() (r float64, exists bool) {
	v := m.add_Load15
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad15 resets all changes to the "Load15" field.
func (m *AgentStatusMutation) ResetLoad15() {
	m._Load15 = nil
	m.add_Load15 = nil
}

// SetTotalMem sets the "TotalMem" field.
func (m *AgentStatusMutation) SetTotalMem(i int64) {
	m._TotalMem = &i
	m.add_TotalMem = nil
}

// TotalMem returns the value of the "TotalMem" field in the mutation.
func (m *AgentStatusMutation) TotalMem() (r int64, exists bool) {
	v := m._TotalMem
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMem returns the old "TotalMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldTotalMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMem: %w", err)
	}
	return oldValue.TotalMem, nil
}

// AddTotalMem adds i to the "TotalMem" field.
func (m *AgentStatusMutation) AddTotalMem(i int64) {
	if m.add_TotalMem != nil {
		*m.add_TotalMem += i
	} else {
		m.add_TotalMem = &i
	}
}

// AddedTotalMem returns the value that was added to the "TotalMem" field in this mutation.
func (m *AgentStatusMutation) AddedTotalMem() (r int64, exists bool) {
	v := m.add_TotalMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMem resets all changes to the "TotalMem" field.
func (m *AgentStatusMutation) ResetTotalMem() {
	m._TotalMem = nil
	m.add_TotalMem = nil
}

// SetFreeMem sets the "FreeMem" field.
func (m *AgentStatusMutation) SetFreeMem(i int64) {
	m._FreeMem = &i
	m.add_FreeMem = nil
}

// FreeMem returns the value of the "FreeMem" field in the mutation.
func (m *AgentStatusMutation) FreeMem() (r int64, exists bool) {
	v := m._FreeMem
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeMem returns the old "FreeMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldFreeMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFreeMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFreeMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeMem: %w", err)
	}
	return oldValue.FreeMem, nil
}

// AddFreeMem adds i to the "FreeMem" field.
func (m *AgentStatusMutation) AddFreeMem(i int64) {
	if m.add_FreeMem != nil {
		*m.add_FreeMem += i
	} else {
		m.add_FreeMem = &i
	}
}

// AddedFreeMem returns the value that was added to the "FreeMem" field in this mutation.
func (m *AgentStatusMutation) AddedFreeMem() (r int64, exists bool) {
	v := m.add_FreeMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreeMem resets all changes to the "FreeMem" field.
func (m *AgentStatusMutation) ResetFreeMem() {
	m._FreeMem = nil
	m.add_FreeMem = nil
}

// SetUsedMem sets the "UsedMem" field.
func (m *AgentStatusMutation) SetUsedMem(i int64) {
	m._UsedMem = &i
	m.add_UsedMem = nil
}

// UsedMem returns the value of the "UsedMem" field in the mutation.
func (m *AgentStatusMutation) UsedMem() (r int64, exists bool) {
	v := m._UsedMem
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedMem returns the old "UsedMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldUsedMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsedMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsedMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedMem: %w", err)
	}
	return oldValue.UsedMem, nil
}

// AddUsedMem adds i to the "UsedMem" field.
func (m *AgentStatusMutation) AddUsedMem(i int64) {
	if m.add_UsedMem != nil {
		*m.add_UsedMem += i
	} else {
		m.add_UsedMem = &i
	}
}

// AddedUsedMem returns the value that was added to the "UsedMem" field in this mutation.
func (m *AgentStatusMutation) AddedUsedMem() (r int64, exists bool) {
	v := m.add_UsedMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedMem resets all changes to the "UsedMem" field.
func (m *AgentStatusMutation) ResetUsedMem() {
	m._UsedMem = nil
	m.add_UsedMem = nil
}

// SetTimestamp sets the "Timestamp" field.
func (m *AgentStatusMutation) SetTimestamp(i int64) {
	m._Timestamp = &i
	m.add_Timestamp = nil
}

// Timestamp returns the value of the "Timestamp" field in the mutation.
func (m *AgentStatusMutation) Timestamp() (r int64, exists bool) {
	v := m._Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "Timestamp" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "Timestamp" field.
func (m *AgentStatusMutation) AddTimestamp(i int64) {
	if m.add_Timestamp != nil {
		*m.add_Timestamp += i
	} else {
		m.add_Timestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "Timestamp" field in this mutation.
func (m *AgentStatusMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.add_Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "Timestamp" field.
func (m *AgentStatusMutation) ResetTimestamp() {
	m._Timestamp = nil
	m.add_Timestamp = nil
}

// AddAgentStatusToTagIDs adds the "AgentStatusToTag" edge to the Tag entity by ids.
func (m *AgentStatusMutation) AddAgentStatusToTagIDs(ids ...int) {
	if m._AgentStatusToTag == nil {
		m._AgentStatusToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._AgentStatusToTag[ids[i]] = struct{}{}
	}
}

// ClearAgentStatusToTag clears the "AgentStatusToTag" edge to the Tag entity.
func (m *AgentStatusMutation) ClearAgentStatusToTag() {
	m.cleared_AgentStatusToTag = true
}

// AgentStatusToTagCleared returns if the "AgentStatusToTag" edge to the Tag entity was cleared.
func (m *AgentStatusMutation) AgentStatusToTagCleared() bool {
	return m.cleared_AgentStatusToTag
}

// RemoveAgentStatusToTagIDs removes the "AgentStatusToTag" edge to the Tag entity by IDs.
func (m *AgentStatusMutation) RemoveAgentStatusToTagIDs(ids ...int) {
	if m.removed_AgentStatusToTag == nil {
		m.removed_AgentStatusToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_AgentStatusToTag[ids[i]] = struct{}{}
	}
}

// RemovedAgentStatusToTag returns the removed IDs of the "AgentStatusToTag" edge to the Tag entity.
func (m *AgentStatusMutation) RemovedAgentStatusToTagIDs() (ids []int) {
	for id := range m.removed_AgentStatusToTag {
		ids = append(ids, id)
	}
	return
}

// AgentStatusToTagIDs returns the "AgentStatusToTag" edge IDs in the mutation.
func (m *AgentStatusMutation) AgentStatusToTagIDs() (ids []int) {
	for id := range m._AgentStatusToTag {
		ids = append(ids, id)
	}
	return
}

// ResetAgentStatusToTag resets all changes to the "AgentStatusToTag" edge.
func (m *AgentStatusMutation) ResetAgentStatusToTag() {
	m._AgentStatusToTag = nil
	m.cleared_AgentStatusToTag = false
	m.removed_AgentStatusToTag = nil
}

// AddAgentStatusToProvisionedHostIDs adds the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity by ids.
func (m *AgentStatusMutation) AddAgentStatusToProvisionedHostIDs(ids ...int) {
	if m._AgentStatusToProvisionedHost == nil {
		m._AgentStatusToProvisionedHost = make(map[int]struct{})
	}
	for i := range ids {
		m._AgentStatusToProvisionedHost[ids[i]] = struct{}{}
	}
}

// ClearAgentStatusToProvisionedHost clears the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity.
func (m *AgentStatusMutation) ClearAgentStatusToProvisionedHost() {
	m.cleared_AgentStatusToProvisionedHost = true
}

// AgentStatusToProvisionedHostCleared returns if the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *AgentStatusMutation) AgentStatusToProvisionedHostCleared() bool {
	return m.cleared_AgentStatusToProvisionedHost
}

// RemoveAgentStatusToProvisionedHostIDs removes the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity by IDs.
func (m *AgentStatusMutation) RemoveAgentStatusToProvisionedHostIDs(ids ...int) {
	if m.removed_AgentStatusToProvisionedHost == nil {
		m.removed_AgentStatusToProvisionedHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_AgentStatusToProvisionedHost[ids[i]] = struct{}{}
	}
}

// RemovedAgentStatusToProvisionedHost returns the removed IDs of the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity.
func (m *AgentStatusMutation) RemovedAgentStatusToProvisionedHostIDs() (ids []int) {
	for id := range m.removed_AgentStatusToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// AgentStatusToProvisionedHostIDs returns the "AgentStatusToProvisionedHost" edge IDs in the mutation.
func (m *AgentStatusMutation) AgentStatusToProvisionedHostIDs() (ids []int) {
	for id := range m._AgentStatusToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ResetAgentStatusToProvisionedHost resets all changes to the "AgentStatusToProvisionedHost" edge.
func (m *AgentStatusMutation) ResetAgentStatusToProvisionedHost() {
	m._AgentStatusToProvisionedHost = nil
	m.cleared_AgentStatusToProvisionedHost = false
	m.removed_AgentStatusToProvisionedHost = nil
}

// Op returns the operation name.
func (m *AgentStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AgentStatus).
func (m *AgentStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentStatusMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._ClientID != nil {
		fields = append(fields, agentstatus.FieldClientID)
	}
	if m._Hostname != nil {
		fields = append(fields, agentstatus.FieldHostname)
	}
	if m._UpTime != nil {
		fields = append(fields, agentstatus.FieldUpTime)
	}
	if m._BootTime != nil {
		fields = append(fields, agentstatus.FieldBootTime)
	}
	if m._NumProcs != nil {
		fields = append(fields, agentstatus.FieldNumProcs)
	}
	if m._Os != nil {
		fields = append(fields, agentstatus.FieldOs)
	}
	if m._HostID != nil {
		fields = append(fields, agentstatus.FieldHostID)
	}
	if m._Load1 != nil {
		fields = append(fields, agentstatus.FieldLoad1)
	}
	if m._Load5 != nil {
		fields = append(fields, agentstatus.FieldLoad5)
	}
	if m._Load15 != nil {
		fields = append(fields, agentstatus.FieldLoad15)
	}
	if m._TotalMem != nil {
		fields = append(fields, agentstatus.FieldTotalMem)
	}
	if m._FreeMem != nil {
		fields = append(fields, agentstatus.FieldFreeMem)
	}
	if m._UsedMem != nil {
		fields = append(fields, agentstatus.FieldUsedMem)
	}
	if m._Timestamp != nil {
		fields = append(fields, agentstatus.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentstatus.FieldClientID:
		return m.ClientID()
	case agentstatus.FieldHostname:
		return m.Hostname()
	case agentstatus.FieldUpTime:
		return m.UpTime()
	case agentstatus.FieldBootTime:
		return m.BootTime()
	case agentstatus.FieldNumProcs:
		return m.NumProcs()
	case agentstatus.FieldOs:
		return m.Os()
	case agentstatus.FieldHostID:
		return m.HostID()
	case agentstatus.FieldLoad1:
		return m.Load1()
	case agentstatus.FieldLoad5:
		return m.Load5()
	case agentstatus.FieldLoad15:
		return m.Load15()
	case agentstatus.FieldTotalMem:
		return m.TotalMem()
	case agentstatus.FieldFreeMem:
		return m.FreeMem()
	case agentstatus.FieldUsedMem:
		return m.UsedMem()
	case agentstatus.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentstatus.FieldClientID:
		return m.OldClientID(ctx)
	case agentstatus.FieldHostname:
		return m.OldHostname(ctx)
	case agentstatus.FieldUpTime:
		return m.OldUpTime(ctx)
	case agentstatus.FieldBootTime:
		return m.OldBootTime(ctx)
	case agentstatus.FieldNumProcs:
		return m.OldNumProcs(ctx)
	case agentstatus.FieldOs:
		return m.OldOs(ctx)
	case agentstatus.FieldHostID:
		return m.OldHostID(ctx)
	case agentstatus.FieldLoad1:
		return m.OldLoad1(ctx)
	case agentstatus.FieldLoad5:
		return m.OldLoad5(ctx)
	case agentstatus.FieldLoad15:
		return m.OldLoad15(ctx)
	case agentstatus.FieldTotalMem:
		return m.OldTotalMem(ctx)
	case agentstatus.FieldFreeMem:
		return m.OldFreeMem(ctx)
	case agentstatus.FieldUsedMem:
		return m.OldUsedMem(ctx)
	case agentstatus.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown AgentStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentstatus.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case agentstatus.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agentstatus.FieldUpTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpTime(v)
		return nil
	case agentstatus.FieldBootTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootTime(v)
		return nil
	case agentstatus.FieldNumProcs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumProcs(v)
		return nil
	case agentstatus.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agentstatus.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case agentstatus.FieldLoad1:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad1(v)
		return nil
	case agentstatus.FieldLoad5:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad5(v)
		return nil
	case agentstatus.FieldLoad15:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad15(v)
		return nil
	case agentstatus.FieldTotalMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMem(v)
		return nil
	case agentstatus.FieldFreeMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeMem(v)
		return nil
	case agentstatus.FieldUsedMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedMem(v)
		return nil
	case agentstatus.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AgentStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentStatusMutation) AddedFields() []string {
	var fields []string
	if m.add_UpTime != nil {
		fields = append(fields, agentstatus.FieldUpTime)
	}
	if m.add_BootTime != nil {
		fields = append(fields, agentstatus.FieldBootTime)
	}
	if m.add_NumProcs != nil {
		fields = append(fields, agentstatus.FieldNumProcs)
	}
	if m.add_Load1 != nil {
		fields = append(fields, agentstatus.FieldLoad1)
	}
	if m.add_Load5 != nil {
		fields = append(fields, agentstatus.FieldLoad5)
	}
	if m.add_Load15 != nil {
		fields = append(fields, agentstatus.FieldLoad15)
	}
	if m.add_TotalMem != nil {
		fields = append(fields, agentstatus.FieldTotalMem)
	}
	if m.add_FreeMem != nil {
		fields = append(fields, agentstatus.FieldFreeMem)
	}
	if m.add_UsedMem != nil {
		fields = append(fields, agentstatus.FieldUsedMem)
	}
	if m.add_Timestamp != nil {
		fields = append(fields, agentstatus.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agentstatus.FieldUpTime:
		return m.AddedUpTime()
	case agentstatus.FieldBootTime:
		return m.AddedBootTime()
	case agentstatus.FieldNumProcs:
		return m.AddedNumProcs()
	case agentstatus.FieldLoad1:
		return m.AddedLoad1()
	case agentstatus.FieldLoad5:
		return m.AddedLoad5()
	case agentstatus.FieldLoad15:
		return m.AddedLoad15()
	case agentstatus.FieldTotalMem:
		return m.AddedTotalMem()
	case agentstatus.FieldFreeMem:
		return m.AddedFreeMem()
	case agentstatus.FieldUsedMem:
		return m.AddedUsedMem()
	case agentstatus.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agentstatus.FieldUpTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpTime(v)
		return nil
	case agentstatus.FieldBootTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBootTime(v)
		return nil
	case agentstatus.FieldNumProcs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumProcs(v)
		return nil
	case agentstatus.FieldLoad1:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad1(v)
		return nil
	case agentstatus.FieldLoad5:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad5(v)
		return nil
	case agentstatus.FieldLoad15:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad15(v)
		return nil
	case agentstatus.FieldTotalMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMem(v)
		return nil
	case agentstatus.FieldFreeMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeMem(v)
		return nil
	case agentstatus.FieldUsedMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedMem(v)
		return nil
	case agentstatus.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AgentStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AgentStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentStatusMutation) ResetField(name string) error {
	switch name {
	case agentstatus.FieldClientID:
		m.ResetClientID()
		return nil
	case agentstatus.FieldHostname:
		m.ResetHostname()
		return nil
	case agentstatus.FieldUpTime:
		m.ResetUpTime()
		return nil
	case agentstatus.FieldBootTime:
		m.ResetBootTime()
		return nil
	case agentstatus.FieldNumProcs:
		m.ResetNumProcs()
		return nil
	case agentstatus.FieldOs:
		m.ResetOs()
		return nil
	case agentstatus.FieldHostID:
		m.ResetHostID()
		return nil
	case agentstatus.FieldLoad1:
		m.ResetLoad1()
		return nil
	case agentstatus.FieldLoad5:
		m.ResetLoad5()
		return nil
	case agentstatus.FieldLoad15:
		m.ResetLoad15()
		return nil
	case agentstatus.FieldTotalMem:
		m.ResetTotalMem()
		return nil
	case agentstatus.FieldFreeMem:
		m.ResetFreeMem()
		return nil
	case agentstatus.FieldUsedMem:
		m.ResetUsedMem()
		return nil
	case agentstatus.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._AgentStatusToTag != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToTag)
	}
	if m._AgentStatusToProvisionedHost != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agentstatus.EdgeAgentStatusToTag:
		ids := make([]ent.Value, 0, len(m._AgentStatusToTag))
		for id := range m._AgentStatusToTag {
			ids = append(ids, id)
		}
		return ids
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		ids := make([]ent.Value, 0, len(m._AgentStatusToProvisionedHost))
		for id := range m._AgentStatusToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_AgentStatusToTag != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToTag)
	}
	if m.removed_AgentStatusToProvisionedHost != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedHost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agentstatus.EdgeAgentStatusToTag:
		ids := make([]ent.Value, 0, len(m.removed_AgentStatusToTag))
		for id := range m.removed_AgentStatusToTag {
			ids = append(ids, id)
		}
		return ids
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		ids := make([]ent.Value, 0, len(m.removed_AgentStatusToProvisionedHost))
		for id := range m.removed_AgentStatusToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_AgentStatusToTag {
		edges = append(edges, agentstatus.EdgeAgentStatusToTag)
	}
	if m.cleared_AgentStatusToProvisionedHost {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case agentstatus.EdgeAgentStatusToTag:
		return m.cleared_AgentStatusToTag
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		return m.cleared_AgentStatusToProvisionedHost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AgentStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentStatusMutation) ResetEdge(name string) error {
	switch name {
	case agentstatus.EdgeAgentStatusToTag:
		m.ResetAgentStatusToTag()
		return nil
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		m.ResetAgentStatusToProvisionedHost()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus edge %s", name)
}

// BuildMutation represents an operation that mutates the Build nodes in the graph.
type BuildMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	revision                          *int
	addrevision                       *int
	_config                           *map[string]string
	clearedFields                     map[string]struct{}
	_BuildToUser                      map[int]struct{}
	removed_BuildToUser               map[int]struct{}
	cleared_BuildToUser               bool
	_BuildToTag                       map[int]struct{}
	removed_BuildToTag                map[int]struct{}
	cleared_BuildToTag                bool
	_BuildToProvisionedNetwork        map[int]struct{}
	removed_BuildToProvisionedNetwork map[int]struct{}
	cleared_BuildToProvisionedNetwork bool
	_BuildToTeam                      map[int]struct{}
	removed_BuildToTeam               map[int]struct{}
	cleared_BuildToTeam               bool
	_BuildToEnvironment               map[int]struct{}
	removed_BuildToEnvironment        map[int]struct{}
	cleared_BuildToEnvironment        bool
	done                              bool
	oldValue                          func(context.Context) (*Build, error)
	predicates                        []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows management of the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for the Build entity.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the ID field of the mutation.
func withBuildID(id int) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BuildMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRevision sets the "revision" field.
func (m *BuildMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *BuildMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *BuildMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *BuildMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *BuildMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetConfig sets the "config" field.
func (m *BuildMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *BuildMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *BuildMutation) ResetConfig() {
	m._config = nil
}

// AddBuildToUserIDs adds the "BuildToUser" edge to the User entity by ids.
func (m *BuildMutation) AddBuildToUserIDs(ids ...int) {
	if m._BuildToUser == nil {
		m._BuildToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._BuildToUser[ids[i]] = struct{}{}
	}
}

// ClearBuildToUser clears the "BuildToUser" edge to the User entity.
func (m *BuildMutation) ClearBuildToUser() {
	m.cleared_BuildToUser = true
}

// BuildToUserCleared returns if the "BuildToUser" edge to the User entity was cleared.
func (m *BuildMutation) BuildToUserCleared() bool {
	return m.cleared_BuildToUser
}

// RemoveBuildToUserIDs removes the "BuildToUser" edge to the User entity by IDs.
func (m *BuildMutation) RemoveBuildToUserIDs(ids ...int) {
	if m.removed_BuildToUser == nil {
		m.removed_BuildToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BuildToUser[ids[i]] = struct{}{}
	}
}

// RemovedBuildToUser returns the removed IDs of the "BuildToUser" edge to the User entity.
func (m *BuildMutation) RemovedBuildToUserIDs() (ids []int) {
	for id := range m.removed_BuildToUser {
		ids = append(ids, id)
	}
	return
}

// BuildToUserIDs returns the "BuildToUser" edge IDs in the mutation.
func (m *BuildMutation) BuildToUserIDs() (ids []int) {
	for id := range m._BuildToUser {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToUser resets all changes to the "BuildToUser" edge.
func (m *BuildMutation) ResetBuildToUser() {
	m._BuildToUser = nil
	m.cleared_BuildToUser = false
	m.removed_BuildToUser = nil
}

// AddBuildToTagIDs adds the "BuildToTag" edge to the Tag entity by ids.
func (m *BuildMutation) AddBuildToTagIDs(ids ...int) {
	if m._BuildToTag == nil {
		m._BuildToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._BuildToTag[ids[i]] = struct{}{}
	}
}

// ClearBuildToTag clears the "BuildToTag" edge to the Tag entity.
func (m *BuildMutation) ClearBuildToTag() {
	m.cleared_BuildToTag = true
}

// BuildToTagCleared returns if the "BuildToTag" edge to the Tag entity was cleared.
func (m *BuildMutation) BuildToTagCleared() bool {
	return m.cleared_BuildToTag
}

// RemoveBuildToTagIDs removes the "BuildToTag" edge to the Tag entity by IDs.
func (m *BuildMutation) RemoveBuildToTagIDs(ids ...int) {
	if m.removed_BuildToTag == nil {
		m.removed_BuildToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BuildToTag[ids[i]] = struct{}{}
	}
}

// RemovedBuildToTag returns the removed IDs of the "BuildToTag" edge to the Tag entity.
func (m *BuildMutation) RemovedBuildToTagIDs() (ids []int) {
	for id := range m.removed_BuildToTag {
		ids = append(ids, id)
	}
	return
}

// BuildToTagIDs returns the "BuildToTag" edge IDs in the mutation.
func (m *BuildMutation) BuildToTagIDs() (ids []int) {
	for id := range m._BuildToTag {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToTag resets all changes to the "BuildToTag" edge.
func (m *BuildMutation) ResetBuildToTag() {
	m._BuildToTag = nil
	m.cleared_BuildToTag = false
	m.removed_BuildToTag = nil
}

// AddBuildToProvisionedNetworkIDs adds the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity by ids.
func (m *BuildMutation) AddBuildToProvisionedNetworkIDs(ids ...int) {
	if m._BuildToProvisionedNetwork == nil {
		m._BuildToProvisionedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._BuildToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// ClearBuildToProvisionedNetwork clears the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *BuildMutation) ClearBuildToProvisionedNetwork() {
	m.cleared_BuildToProvisionedNetwork = true
}

// BuildToProvisionedNetworkCleared returns if the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *BuildMutation) BuildToProvisionedNetworkCleared() bool {
	return m.cleared_BuildToProvisionedNetwork
}

// RemoveBuildToProvisionedNetworkIDs removes the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity by IDs.
func (m *BuildMutation) RemoveBuildToProvisionedNetworkIDs(ids ...int) {
	if m.removed_BuildToProvisionedNetwork == nil {
		m.removed_BuildToProvisionedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BuildToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedBuildToProvisionedNetwork returns the removed IDs of the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *BuildMutation) RemovedBuildToProvisionedNetworkIDs() (ids []int) {
	for id := range m.removed_BuildToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// BuildToProvisionedNetworkIDs returns the "BuildToProvisionedNetwork" edge IDs in the mutation.
func (m *BuildMutation) BuildToProvisionedNetworkIDs() (ids []int) {
	for id := range m._BuildToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToProvisionedNetwork resets all changes to the "BuildToProvisionedNetwork" edge.
func (m *BuildMutation) ResetBuildToProvisionedNetwork() {
	m._BuildToProvisionedNetwork = nil
	m.cleared_BuildToProvisionedNetwork = false
	m.removed_BuildToProvisionedNetwork = nil
}

// AddBuildToTeamIDs adds the "BuildToTeam" edge to the Team entity by ids.
func (m *BuildMutation) AddBuildToTeamIDs(ids ...int) {
	if m._BuildToTeam == nil {
		m._BuildToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m._BuildToTeam[ids[i]] = struct{}{}
	}
}

// ClearBuildToTeam clears the "BuildToTeam" edge to the Team entity.
func (m *BuildMutation) ClearBuildToTeam() {
	m.cleared_BuildToTeam = true
}

// BuildToTeamCleared returns if the "BuildToTeam" edge to the Team entity was cleared.
func (m *BuildMutation) BuildToTeamCleared() bool {
	return m.cleared_BuildToTeam
}

// RemoveBuildToTeamIDs removes the "BuildToTeam" edge to the Team entity by IDs.
func (m *BuildMutation) RemoveBuildToTeamIDs(ids ...int) {
	if m.removed_BuildToTeam == nil {
		m.removed_BuildToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BuildToTeam[ids[i]] = struct{}{}
	}
}

// RemovedBuildToTeam returns the removed IDs of the "BuildToTeam" edge to the Team entity.
func (m *BuildMutation) RemovedBuildToTeamIDs() (ids []int) {
	for id := range m.removed_BuildToTeam {
		ids = append(ids, id)
	}
	return
}

// BuildToTeamIDs returns the "BuildToTeam" edge IDs in the mutation.
func (m *BuildMutation) BuildToTeamIDs() (ids []int) {
	for id := range m._BuildToTeam {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToTeam resets all changes to the "BuildToTeam" edge.
func (m *BuildMutation) ResetBuildToTeam() {
	m._BuildToTeam = nil
	m.cleared_BuildToTeam = false
	m.removed_BuildToTeam = nil
}

// AddBuildToEnvironmentIDs adds the "BuildToEnvironment" edge to the Environment entity by ids.
func (m *BuildMutation) AddBuildToEnvironmentIDs(ids ...int) {
	if m._BuildToEnvironment == nil {
		m._BuildToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._BuildToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearBuildToEnvironment clears the "BuildToEnvironment" edge to the Environment entity.
func (m *BuildMutation) ClearBuildToEnvironment() {
	m.cleared_BuildToEnvironment = true
}

// BuildToEnvironmentCleared returns if the "BuildToEnvironment" edge to the Environment entity was cleared.
func (m *BuildMutation) BuildToEnvironmentCleared() bool {
	return m.cleared_BuildToEnvironment
}

// RemoveBuildToEnvironmentIDs removes the "BuildToEnvironment" edge to the Environment entity by IDs.
func (m *BuildMutation) RemoveBuildToEnvironmentIDs(ids ...int) {
	if m.removed_BuildToEnvironment == nil {
		m.removed_BuildToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BuildToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedBuildToEnvironment returns the removed IDs of the "BuildToEnvironment" edge to the Environment entity.
func (m *BuildMutation) RemovedBuildToEnvironmentIDs() (ids []int) {
	for id := range m.removed_BuildToEnvironment {
		ids = append(ids, id)
	}
	return
}

// BuildToEnvironmentIDs returns the "BuildToEnvironment" edge IDs in the mutation.
func (m *BuildMutation) BuildToEnvironmentIDs() (ids []int) {
	for id := range m._BuildToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToEnvironment resets all changes to the "BuildToEnvironment" edge.
func (m *BuildMutation) ResetBuildToEnvironment() {
	m._BuildToEnvironment = nil
	m.cleared_BuildToEnvironment = false
	m.removed_BuildToEnvironment = nil
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.revision != nil {
		fields = append(fields, build.FieldRevision)
	}
	if m._config != nil {
		fields = append(fields, build.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.Revision()
	case build.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldRevision:
		return m.OldRevision(ctx)
	case build.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case build.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, build.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldRevision:
		m.ResetRevision()
		return nil
	case build.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._BuildToUser != nil {
		edges = append(edges, build.EdgeBuildToUser)
	}
	if m._BuildToTag != nil {
		edges = append(edges, build.EdgeBuildToTag)
	}
	if m._BuildToProvisionedNetwork != nil {
		edges = append(edges, build.EdgeBuildToProvisionedNetwork)
	}
	if m._BuildToTeam != nil {
		edges = append(edges, build.EdgeBuildToTeam)
	}
	if m._BuildToEnvironment != nil {
		edges = append(edges, build.EdgeBuildToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeBuildToUser:
		ids := make([]ent.Value, 0, len(m._BuildToUser))
		for id := range m._BuildToUser {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToTag:
		ids := make([]ent.Value, 0, len(m._BuildToTag))
		for id := range m._BuildToTag {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m._BuildToProvisionedNetwork))
		for id := range m._BuildToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToTeam:
		ids := make([]ent.Value, 0, len(m._BuildToTeam))
		for id := range m._BuildToTeam {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToEnvironment:
		ids := make([]ent.Value, 0, len(m._BuildToEnvironment))
		for id := range m._BuildToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_BuildToUser != nil {
		edges = append(edges, build.EdgeBuildToUser)
	}
	if m.removed_BuildToTag != nil {
		edges = append(edges, build.EdgeBuildToTag)
	}
	if m.removed_BuildToProvisionedNetwork != nil {
		edges = append(edges, build.EdgeBuildToProvisionedNetwork)
	}
	if m.removed_BuildToTeam != nil {
		edges = append(edges, build.EdgeBuildToTeam)
	}
	if m.removed_BuildToEnvironment != nil {
		edges = append(edges, build.EdgeBuildToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeBuildToUser:
		ids := make([]ent.Value, 0, len(m.removed_BuildToUser))
		for id := range m.removed_BuildToUser {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToTag:
		ids := make([]ent.Value, 0, len(m.removed_BuildToTag))
		for id := range m.removed_BuildToTag {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_BuildToProvisionedNetwork))
		for id := range m.removed_BuildToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToTeam:
		ids := make([]ent.Value, 0, len(m.removed_BuildToTeam))
		for id := range m.removed_BuildToTeam {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_BuildToEnvironment))
		for id := range m.removed_BuildToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_BuildToUser {
		edges = append(edges, build.EdgeBuildToUser)
	}
	if m.cleared_BuildToTag {
		edges = append(edges, build.EdgeBuildToTag)
	}
	if m.cleared_BuildToProvisionedNetwork {
		edges = append(edges, build.EdgeBuildToProvisionedNetwork)
	}
	if m.cleared_BuildToTeam {
		edges = append(edges, build.EdgeBuildToTeam)
	}
	if m.cleared_BuildToEnvironment {
		edges = append(edges, build.EdgeBuildToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeBuildToUser:
		return m.cleared_BuildToUser
	case build.EdgeBuildToTag:
		return m.cleared_BuildToTag
	case build.EdgeBuildToProvisionedNetwork:
		return m.cleared_BuildToProvisionedNetwork
	case build.EdgeBuildToTeam:
		return m.cleared_BuildToTeam
	case build.EdgeBuildToEnvironment:
		return m.cleared_BuildToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeBuildToUser:
		m.ResetBuildToUser()
		return nil
	case build.EdgeBuildToTag:
		m.ResetBuildToTag()
		return nil
	case build.EdgeBuildToProvisionedNetwork:
		m.ResetBuildToProvisionedNetwork()
		return nil
	case build.EdgeBuildToTeam:
		m.ResetBuildToTeam()
		return nil
	case build.EdgeBuildToEnvironment:
		m.ResetBuildToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// CommandMutation represents an operation that mutates the Command nodes in the graph.
type CommandMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	hcl_id                       *string
	name                         *string
	description                  *string
	program                      *string
	args                         *[]string
	ignore_errors                *bool
	disabled                     *bool
	cooldown                     *int
	addcooldown                  *int
	timeout                      *int
	addtimeout                   *int
	vars                         *map[string]string
	tags                         *map[string]string
	clearedFields                map[string]struct{}
	_CommandToUser               map[int]struct{}
	removed_CommandToUser        map[int]struct{}
	cleared_CommandToUser        bool
	_CommandToTag                map[int]struct{}
	removed_CommandToTag         map[int]struct{}
	cleared_CommandToTag         bool
	_CommandToEnvironment        map[int]struct{}
	removed_CommandToEnvironment map[int]struct{}
	cleared_CommandToEnvironment bool
	done                         bool
	oldValue                     func(context.Context) (*Command, error)
	predicates                   []predicate.Command
}

var _ ent.Mutation = (*CommandMutation)(nil)

// commandOption allows management of the mutation configuration using functional options.
type commandOption func(*CommandMutation)

// newCommandMutation creates new mutation for the Command entity.
func newCommandMutation(c config, op Op, opts ...commandOption) *CommandMutation {
	m := &CommandMutation{
		config:        c,
		op:            op,
		typ:           TypeCommand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommandID sets the ID field of the mutation.
func withCommandID(id int) commandOption {
	return func(m *CommandMutation) {
		var (
			err   error
			once  sync.Once
			value *Command
		)
		m.oldValue = func(ctx context.Context) (*Command, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Command.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommand sets the old Command of the mutation.
func withCommand(node *Command) commandOption {
	return func(m *CommandMutation) {
		m.oldValue = func(context.Context) (*Command, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CommandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *CommandMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *CommandMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *CommandMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *CommandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CommandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CommandMutation) ResetDescription() {
	m.description = nil
}

// SetProgram sets the "program" field.
func (m *CommandMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *CommandMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *CommandMutation) ResetProgram() {
	m.program = nil
}

// SetArgs sets the "args" field.
func (m *CommandMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *CommandMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *CommandMutation) ResetArgs() {
	m.args = nil
}

// SetIgnoreErrors sets the "ignore_errors" field.
func (m *CommandMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the value of the "ignore_errors" field in the mutation.
func (m *CommandMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old "ignore_errors" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIgnoreErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors resets all changes to the "ignore_errors" field.
func (m *CommandMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetDisabled sets the "disabled" field.
func (m *CommandMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *CommandMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *CommandMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCooldown sets the "cooldown" field.
func (m *CommandMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the value of the "cooldown" field in the mutation.
func (m *CommandMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old "cooldown" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCooldown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to the "cooldown" field.
func (m *CommandMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the "cooldown" field in this mutation.
func (m *CommandMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown resets all changes to the "cooldown" field.
func (m *CommandMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the "timeout" field.
func (m *CommandMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *CommandMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *CommandMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *CommandMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *CommandMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetVars sets the "vars" field.
func (m *CommandMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *CommandMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *CommandMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *CommandMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CommandMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CommandMutation) ResetTags() {
	m.tags = nil
}

// AddCommandToUserIDs adds the "CommandToUser" edge to the User entity by ids.
func (m *CommandMutation) AddCommandToUserIDs(ids ...int) {
	if m._CommandToUser == nil {
		m._CommandToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._CommandToUser[ids[i]] = struct{}{}
	}
}

// ClearCommandToUser clears the "CommandToUser" edge to the User entity.
func (m *CommandMutation) ClearCommandToUser() {
	m.cleared_CommandToUser = true
}

// CommandToUserCleared returns if the "CommandToUser" edge to the User entity was cleared.
func (m *CommandMutation) CommandToUserCleared() bool {
	return m.cleared_CommandToUser
}

// RemoveCommandToUserIDs removes the "CommandToUser" edge to the User entity by IDs.
func (m *CommandMutation) RemoveCommandToUserIDs(ids ...int) {
	if m.removed_CommandToUser == nil {
		m.removed_CommandToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_CommandToUser[ids[i]] = struct{}{}
	}
}

// RemovedCommandToUser returns the removed IDs of the "CommandToUser" edge to the User entity.
func (m *CommandMutation) RemovedCommandToUserIDs() (ids []int) {
	for id := range m.removed_CommandToUser {
		ids = append(ids, id)
	}
	return
}

// CommandToUserIDs returns the "CommandToUser" edge IDs in the mutation.
func (m *CommandMutation) CommandToUserIDs() (ids []int) {
	for id := range m._CommandToUser {
		ids = append(ids, id)
	}
	return
}

// ResetCommandToUser resets all changes to the "CommandToUser" edge.
func (m *CommandMutation) ResetCommandToUser() {
	m._CommandToUser = nil
	m.cleared_CommandToUser = false
	m.removed_CommandToUser = nil
}

// AddCommandToTagIDs adds the "CommandToTag" edge to the Tag entity by ids.
func (m *CommandMutation) AddCommandToTagIDs(ids ...int) {
	if m._CommandToTag == nil {
		m._CommandToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._CommandToTag[ids[i]] = struct{}{}
	}
}

// ClearCommandToTag clears the "CommandToTag" edge to the Tag entity.
func (m *CommandMutation) ClearCommandToTag() {
	m.cleared_CommandToTag = true
}

// CommandToTagCleared returns if the "CommandToTag" edge to the Tag entity was cleared.
func (m *CommandMutation) CommandToTagCleared() bool {
	return m.cleared_CommandToTag
}

// RemoveCommandToTagIDs removes the "CommandToTag" edge to the Tag entity by IDs.
func (m *CommandMutation) RemoveCommandToTagIDs(ids ...int) {
	if m.removed_CommandToTag == nil {
		m.removed_CommandToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_CommandToTag[ids[i]] = struct{}{}
	}
}

// RemovedCommandToTag returns the removed IDs of the "CommandToTag" edge to the Tag entity.
func (m *CommandMutation) RemovedCommandToTagIDs() (ids []int) {
	for id := range m.removed_CommandToTag {
		ids = append(ids, id)
	}
	return
}

// CommandToTagIDs returns the "CommandToTag" edge IDs in the mutation.
func (m *CommandMutation) CommandToTagIDs() (ids []int) {
	for id := range m._CommandToTag {
		ids = append(ids, id)
	}
	return
}

// ResetCommandToTag resets all changes to the "CommandToTag" edge.
func (m *CommandMutation) ResetCommandToTag() {
	m._CommandToTag = nil
	m.cleared_CommandToTag = false
	m.removed_CommandToTag = nil
}

// AddCommandToEnvironmentIDs adds the "CommandToEnvironment" edge to the Environment entity by ids.
func (m *CommandMutation) AddCommandToEnvironmentIDs(ids ...int) {
	if m._CommandToEnvironment == nil {
		m._CommandToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._CommandToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearCommandToEnvironment clears the "CommandToEnvironment" edge to the Environment entity.
func (m *CommandMutation) ClearCommandToEnvironment() {
	m.cleared_CommandToEnvironment = true
}

// CommandToEnvironmentCleared returns if the "CommandToEnvironment" edge to the Environment entity was cleared.
func (m *CommandMutation) CommandToEnvironmentCleared() bool {
	return m.cleared_CommandToEnvironment
}

// RemoveCommandToEnvironmentIDs removes the "CommandToEnvironment" edge to the Environment entity by IDs.
func (m *CommandMutation) RemoveCommandToEnvironmentIDs(ids ...int) {
	if m.removed_CommandToEnvironment == nil {
		m.removed_CommandToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_CommandToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedCommandToEnvironment returns the removed IDs of the "CommandToEnvironment" edge to the Environment entity.
func (m *CommandMutation) RemovedCommandToEnvironmentIDs() (ids []int) {
	for id := range m.removed_CommandToEnvironment {
		ids = append(ids, id)
	}
	return
}

// CommandToEnvironmentIDs returns the "CommandToEnvironment" edge IDs in the mutation.
func (m *CommandMutation) CommandToEnvironmentIDs() (ids []int) {
	for id := range m._CommandToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetCommandToEnvironment resets all changes to the "CommandToEnvironment" edge.
func (m *CommandMutation) ResetCommandToEnvironment() {
	m._CommandToEnvironment = nil
	m.cleared_CommandToEnvironment = false
	m.removed_CommandToEnvironment = nil
}

// Op returns the operation name.
func (m *CommandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Command).
func (m *CommandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommandMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, command.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, command.FieldName)
	}
	if m.description != nil {
		fields = append(fields, command.FieldDescription)
	}
	if m.program != nil {
		fields = append(fields, command.FieldProgram)
	}
	if m.args != nil {
		fields = append(fields, command.FieldArgs)
	}
	if m.ignore_errors != nil {
		fields = append(fields, command.FieldIgnoreErrors)
	}
	if m.disabled != nil {
		fields = append(fields, command.FieldDisabled)
	}
	if m.cooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	if m.vars != nil {
		fields = append(fields, command.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, command.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case command.FieldHclID:
		return m.HclID()
	case command.FieldName:
		return m.Name()
	case command.FieldDescription:
		return m.Description()
	case command.FieldProgram:
		return m.Program()
	case command.FieldArgs:
		return m.Args()
	case command.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case command.FieldDisabled:
		return m.Disabled()
	case command.FieldCooldown:
		return m.Cooldown()
	case command.FieldTimeout:
		return m.Timeout()
	case command.FieldVars:
		return m.Vars()
	case command.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case command.FieldHclID:
		return m.OldHclID(ctx)
	case command.FieldName:
		return m.OldName(ctx)
	case command.FieldDescription:
		return m.OldDescription(ctx)
	case command.FieldProgram:
		return m.OldProgram(ctx)
	case command.FieldArgs:
		return m.OldArgs(ctx)
	case command.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case command.FieldDisabled:
		return m.OldDisabled(ctx)
	case command.FieldCooldown:
		return m.OldCooldown(ctx)
	case command.FieldTimeout:
		return m.OldTimeout(ctx)
	case command.FieldVars:
		return m.OldVars(ctx)
	case command.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Command field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case command.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case command.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case command.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case command.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case command.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case command.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case command.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case command.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case command.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommandMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case command.FieldCooldown:
		return m.AddedCooldown()
	case command.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Command numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Command nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommandMutation) ResetField(name string) error {
	switch name {
	case command.FieldHclID:
		m.ResetHclID()
		return nil
	case command.FieldName:
		m.ResetName()
		return nil
	case command.FieldDescription:
		m.ResetDescription()
		return nil
	case command.FieldProgram:
		m.ResetProgram()
		return nil
	case command.FieldArgs:
		m.ResetArgs()
		return nil
	case command.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case command.FieldDisabled:
		m.ResetDisabled()
		return nil
	case command.FieldCooldown:
		m.ResetCooldown()
		return nil
	case command.FieldTimeout:
		m.ResetTimeout()
		return nil
	case command.FieldVars:
		m.ResetVars()
		return nil
	case command.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommandMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._CommandToUser != nil {
		edges = append(edges, command.EdgeCommandToUser)
	}
	if m._CommandToTag != nil {
		edges = append(edges, command.EdgeCommandToTag)
	}
	if m._CommandToEnvironment != nil {
		edges = append(edges, command.EdgeCommandToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeCommandToUser:
		ids := make([]ent.Value, 0, len(m._CommandToUser))
		for id := range m._CommandToUser {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeCommandToTag:
		ids := make([]ent.Value, 0, len(m._CommandToTag))
		for id := range m._CommandToTag {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeCommandToEnvironment:
		ids := make([]ent.Value, 0, len(m._CommandToEnvironment))
		for id := range m._CommandToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_CommandToUser != nil {
		edges = append(edges, command.EdgeCommandToUser)
	}
	if m.removed_CommandToTag != nil {
		edges = append(edges, command.EdgeCommandToTag)
	}
	if m.removed_CommandToEnvironment != nil {
		edges = append(edges, command.EdgeCommandToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeCommandToUser:
		ids := make([]ent.Value, 0, len(m.removed_CommandToUser))
		for id := range m.removed_CommandToUser {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeCommandToTag:
		ids := make([]ent.Value, 0, len(m.removed_CommandToTag))
		for id := range m.removed_CommandToTag {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeCommandToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_CommandToEnvironment))
		for id := range m.removed_CommandToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_CommandToUser {
		edges = append(edges, command.EdgeCommandToUser)
	}
	if m.cleared_CommandToTag {
		edges = append(edges, command.EdgeCommandToTag)
	}
	if m.cleared_CommandToEnvironment {
		edges = append(edges, command.EdgeCommandToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommandMutation) EdgeCleared(name string) bool {
	switch name {
	case command.EdgeCommandToUser:
		return m.cleared_CommandToUser
	case command.EdgeCommandToTag:
		return m.cleared_CommandToTag
	case command.EdgeCommandToEnvironment:
		return m.cleared_CommandToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Command unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommandMutation) ResetEdge(name string) error {
	switch name {
	case command.EdgeCommandToUser:
		m.ResetCommandToUser()
		return nil
	case command.EdgeCommandToTag:
		m.ResetCommandToTag()
		return nil
	case command.EdgeCommandToEnvironment:
		m.ResetCommandToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Command edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	hcl_id                           *string
	root_password                    *string
	_config                          *map[string]string
	tags                             *map[string]string
	clearedFields                    map[string]struct{}
	_CompetitionToTag                map[int]struct{}
	removed_CompetitionToTag         map[int]struct{}
	cleared_CompetitionToTag         bool
	_CompetitionToDNS                map[int]struct{}
	removed_CompetitionToDNS         map[int]struct{}
	cleared_CompetitionToDNS         bool
	_CompetitionToEnvironment        map[int]struct{}
	removed_CompetitionToEnvironment map[int]struct{}
	cleared_CompetitionToEnvironment bool
	done                             bool
	oldValue                         func(context.Context) (*Competition, error)
	predicates                       []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id int) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CompetitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *CompetitionMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *CompetitionMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *CompetitionMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetRootPassword sets the "root_password" field.
func (m *CompetitionMutation) SetRootPassword(s string) {
	m.root_password = &s
}

// RootPassword returns the value of the "root_password" field in the mutation.
func (m *CompetitionMutation) RootPassword() (r string, exists bool) {
	v := m.root_password
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPassword returns the old "root_password" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldRootPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPassword: %w", err)
	}
	return oldValue.RootPassword, nil
}

// ResetRootPassword resets all changes to the "root_password" field.
func (m *CompetitionMutation) ResetRootPassword() {
	m.root_password = nil
}

// SetConfig sets the "config" field.
func (m *CompetitionMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *CompetitionMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *CompetitionMutation) ResetConfig() {
	m._config = nil
}

// SetTags sets the "tags" field.
func (m *CompetitionMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CompetitionMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CompetitionMutation) ResetTags() {
	m.tags = nil
}

// AddCompetitionToTagIDs adds the "CompetitionToTag" edge to the Tag entity by ids.
func (m *CompetitionMutation) AddCompetitionToTagIDs(ids ...int) {
	if m._CompetitionToTag == nil {
		m._CompetitionToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._CompetitionToTag[ids[i]] = struct{}{}
	}
}

// ClearCompetitionToTag clears the "CompetitionToTag" edge to the Tag entity.
func (m *CompetitionMutation) ClearCompetitionToTag() {
	m.cleared_CompetitionToTag = true
}

// CompetitionToTagCleared returns if the "CompetitionToTag" edge to the Tag entity was cleared.
func (m *CompetitionMutation) CompetitionToTagCleared() bool {
	return m.cleared_CompetitionToTag
}

// RemoveCompetitionToTagIDs removes the "CompetitionToTag" edge to the Tag entity by IDs.
func (m *CompetitionMutation) RemoveCompetitionToTagIDs(ids ...int) {
	if m.removed_CompetitionToTag == nil {
		m.removed_CompetitionToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_CompetitionToTag[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionToTag returns the removed IDs of the "CompetitionToTag" edge to the Tag entity.
func (m *CompetitionMutation) RemovedCompetitionToTagIDs() (ids []int) {
	for id := range m.removed_CompetitionToTag {
		ids = append(ids, id)
	}
	return
}

// CompetitionToTagIDs returns the "CompetitionToTag" edge IDs in the mutation.
func (m *CompetitionMutation) CompetitionToTagIDs() (ids []int) {
	for id := range m._CompetitionToTag {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionToTag resets all changes to the "CompetitionToTag" edge.
func (m *CompetitionMutation) ResetCompetitionToTag() {
	m._CompetitionToTag = nil
	m.cleared_CompetitionToTag = false
	m.removed_CompetitionToTag = nil
}

// AddCompetitionToDNSIDs adds the "CompetitionToDNS" edge to the DNS entity by ids.
func (m *CompetitionMutation) AddCompetitionToDNSIDs(ids ...int) {
	if m._CompetitionToDNS == nil {
		m._CompetitionToDNS = make(map[int]struct{})
	}
	for i := range ids {
		m._CompetitionToDNS[ids[i]] = struct{}{}
	}
}

// ClearCompetitionToDNS clears the "CompetitionToDNS" edge to the DNS entity.
func (m *CompetitionMutation) ClearCompetitionToDNS() {
	m.cleared_CompetitionToDNS = true
}

// CompetitionToDNSCleared returns if the "CompetitionToDNS" edge to the DNS entity was cleared.
func (m *CompetitionMutation) CompetitionToDNSCleared() bool {
	return m.cleared_CompetitionToDNS
}

// RemoveCompetitionToDNSIDs removes the "CompetitionToDNS" edge to the DNS entity by IDs.
func (m *CompetitionMutation) RemoveCompetitionToDNSIDs(ids ...int) {
	if m.removed_CompetitionToDNS == nil {
		m.removed_CompetitionToDNS = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_CompetitionToDNS[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionToDNS returns the removed IDs of the "CompetitionToDNS" edge to the DNS entity.
func (m *CompetitionMutation) RemovedCompetitionToDNSIDs() (ids []int) {
	for id := range m.removed_CompetitionToDNS {
		ids = append(ids, id)
	}
	return
}

// CompetitionToDNSIDs returns the "CompetitionToDNS" edge IDs in the mutation.
func (m *CompetitionMutation) CompetitionToDNSIDs() (ids []int) {
	for id := range m._CompetitionToDNS {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionToDNS resets all changes to the "CompetitionToDNS" edge.
func (m *CompetitionMutation) ResetCompetitionToDNS() {
	m._CompetitionToDNS = nil
	m.cleared_CompetitionToDNS = false
	m.removed_CompetitionToDNS = nil
}

// AddCompetitionToEnvironmentIDs adds the "CompetitionToEnvironment" edge to the Environment entity by ids.
func (m *CompetitionMutation) AddCompetitionToEnvironmentIDs(ids ...int) {
	if m._CompetitionToEnvironment == nil {
		m._CompetitionToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._CompetitionToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearCompetitionToEnvironment clears the "CompetitionToEnvironment" edge to the Environment entity.
func (m *CompetitionMutation) ClearCompetitionToEnvironment() {
	m.cleared_CompetitionToEnvironment = true
}

// CompetitionToEnvironmentCleared returns if the "CompetitionToEnvironment" edge to the Environment entity was cleared.
func (m *CompetitionMutation) CompetitionToEnvironmentCleared() bool {
	return m.cleared_CompetitionToEnvironment
}

// RemoveCompetitionToEnvironmentIDs removes the "CompetitionToEnvironment" edge to the Environment entity by IDs.
func (m *CompetitionMutation) RemoveCompetitionToEnvironmentIDs(ids ...int) {
	if m.removed_CompetitionToEnvironment == nil {
		m.removed_CompetitionToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_CompetitionToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionToEnvironment returns the removed IDs of the "CompetitionToEnvironment" edge to the Environment entity.
func (m *CompetitionMutation) RemovedCompetitionToEnvironmentIDs() (ids []int) {
	for id := range m.removed_CompetitionToEnvironment {
		ids = append(ids, id)
	}
	return
}

// CompetitionToEnvironmentIDs returns the "CompetitionToEnvironment" edge IDs in the mutation.
func (m *CompetitionMutation) CompetitionToEnvironmentIDs() (ids []int) {
	for id := range m._CompetitionToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionToEnvironment resets all changes to the "CompetitionToEnvironment" edge.
func (m *CompetitionMutation) ResetCompetitionToEnvironment() {
	m._CompetitionToEnvironment = nil
	m.cleared_CompetitionToEnvironment = false
	m.removed_CompetitionToEnvironment = nil
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.hcl_id != nil {
		fields = append(fields, competition.FieldHclID)
	}
	if m.root_password != nil {
		fields = append(fields, competition.FieldRootPassword)
	}
	if m._config != nil {
		fields = append(fields, competition.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, competition.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldHclID:
		return m.HclID()
	case competition.FieldRootPassword:
		return m.RootPassword()
	case competition.FieldConfig:
		return m.Config()
	case competition.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldHclID:
		return m.OldHclID(ctx)
	case competition.FieldRootPassword:
		return m.OldRootPassword(ctx)
	case competition.FieldConfig:
		return m.OldConfig(ctx)
	case competition.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case competition.FieldRootPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPassword(v)
		return nil
	case competition.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case competition.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldHclID:
		m.ResetHclID()
		return nil
	case competition.FieldRootPassword:
		m.ResetRootPassword()
		return nil
	case competition.FieldConfig:
		m.ResetConfig()
		return nil
	case competition.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._CompetitionToTag != nil {
		edges = append(edges, competition.EdgeCompetitionToTag)
	}
	if m._CompetitionToDNS != nil {
		edges = append(edges, competition.EdgeCompetitionToDNS)
	}
	if m._CompetitionToEnvironment != nil {
		edges = append(edges, competition.EdgeCompetitionToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeCompetitionToTag:
		ids := make([]ent.Value, 0, len(m._CompetitionToTag))
		for id := range m._CompetitionToTag {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeCompetitionToDNS:
		ids := make([]ent.Value, 0, len(m._CompetitionToDNS))
		for id := range m._CompetitionToDNS {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeCompetitionToEnvironment:
		ids := make([]ent.Value, 0, len(m._CompetitionToEnvironment))
		for id := range m._CompetitionToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_CompetitionToTag != nil {
		edges = append(edges, competition.EdgeCompetitionToTag)
	}
	if m.removed_CompetitionToDNS != nil {
		edges = append(edges, competition.EdgeCompetitionToDNS)
	}
	if m.removed_CompetitionToEnvironment != nil {
		edges = append(edges, competition.EdgeCompetitionToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeCompetitionToTag:
		ids := make([]ent.Value, 0, len(m.removed_CompetitionToTag))
		for id := range m.removed_CompetitionToTag {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeCompetitionToDNS:
		ids := make([]ent.Value, 0, len(m.removed_CompetitionToDNS))
		for id := range m.removed_CompetitionToDNS {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeCompetitionToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_CompetitionToEnvironment))
		for id := range m.removed_CompetitionToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_CompetitionToTag {
		edges = append(edges, competition.EdgeCompetitionToTag)
	}
	if m.cleared_CompetitionToDNS {
		edges = append(edges, competition.EdgeCompetitionToDNS)
	}
	if m.cleared_CompetitionToEnvironment {
		edges = append(edges, competition.EdgeCompetitionToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeCompetitionToTag:
		return m.cleared_CompetitionToTag
	case competition.EdgeCompetitionToDNS:
		return m.cleared_CompetitionToDNS
	case competition.EdgeCompetitionToEnvironment:
		return m.cleared_CompetitionToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeCompetitionToTag:
		m.ResetCompetitionToTag()
		return nil
	case competition.EdgeCompetitionToDNS:
		m.ResetCompetitionToDNS()
		return nil
	case competition.EdgeCompetitionToEnvironment:
		m.ResetCompetitionToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// DNSMutation represents an operation that mutates the DNS nodes in the graph.
type DNSMutation struct {
	config
	op               Op
	typ              string
	id               *int
	hcl_id           *string
	_type            *string
	root_domain      *string
	dns_servers      *[]string
	ntp_servers      *[]string
	_config          *map[string]string
	clearedFields    map[string]struct{}
	_DNSToTag        map[int]struct{}
	removed_DNSToTag map[int]struct{}
	cleared_DNSToTag bool
	done             bool
	oldValue         func(context.Context) (*DNS, error)
	predicates       []predicate.DNS
}

var _ ent.Mutation = (*DNSMutation)(nil)

// dnsOption allows management of the mutation configuration using functional options.
type dnsOption func(*DNSMutation)

// newDNSMutation creates new mutation for the DNS entity.
func newDNSMutation(c config, op Op, opts ...dnsOption) *DNSMutation {
	m := &DNSMutation{
		config:        c,
		op:            op,
		typ:           TypeDNS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSID sets the ID field of the mutation.
func withDNSID(id int) dnsOption {
	return func(m *DNSMutation) {
		var (
			err   error
			once  sync.Once
			value *DNS
		)
		m.oldValue = func(ctx context.Context) (*DNS, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNS sets the old DNS of the mutation.
func withDNS(node *DNS) dnsOption {
	return func(m *DNSMutation) {
		m.oldValue = func(context.Context) (*DNS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DNSMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *DNSMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *DNSMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *DNSMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetType sets the "type" field.
func (m *DNSMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSMutation) ResetType() {
	m._type = nil
}

// SetRootDomain sets the "root_domain" field.
func (m *DNSMutation) SetRootDomain(s string) {
	m.root_domain = &s
}

// RootDomain returns the value of the "root_domain" field in the mutation.
func (m *DNSMutation) RootDomain() (r string, exists bool) {
	v := m.root_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldRootDomain returns the old "root_domain" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldRootDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootDomain: %w", err)
	}
	return oldValue.RootDomain, nil
}

// ResetRootDomain resets all changes to the "root_domain" field.
func (m *DNSMutation) ResetRootDomain() {
	m.root_domain = nil
}

// SetDNSServers sets the "dns_servers" field.
func (m *DNSMutation) SetDNSServers(s []string) {
	m.dns_servers = &s
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *DNSMutation) DNSServers() (r []string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldDNSServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *DNSMutation) ResetDNSServers() {
	m.dns_servers = nil
}

// SetNtpServers sets the "ntp_servers" field.
func (m *DNSMutation) SetNtpServers(s []string) {
	m.ntp_servers = &s
}

// NtpServers returns the value of the "ntp_servers" field in the mutation.
func (m *DNSMutation) NtpServers() (r []string, exists bool) {
	v := m.ntp_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldNtpServers returns the old "ntp_servers" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldNtpServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNtpServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNtpServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNtpServers: %w", err)
	}
	return oldValue.NtpServers, nil
}

// ResetNtpServers resets all changes to the "ntp_servers" field.
func (m *DNSMutation) ResetNtpServers() {
	m.ntp_servers = nil
}

// SetConfig sets the "config" field.
func (m *DNSMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *DNSMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *DNSMutation) ResetConfig() {
	m._config = nil
}

// AddDNSToTagIDs adds the "DNSToTag" edge to the Tag entity by ids.
func (m *DNSMutation) AddDNSToTagIDs(ids ...int) {
	if m._DNSToTag == nil {
		m._DNSToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._DNSToTag[ids[i]] = struct{}{}
	}
}

// ClearDNSToTag clears the "DNSToTag" edge to the Tag entity.
func (m *DNSMutation) ClearDNSToTag() {
	m.cleared_DNSToTag = true
}

// DNSToTagCleared returns if the "DNSToTag" edge to the Tag entity was cleared.
func (m *DNSMutation) DNSToTagCleared() bool {
	return m.cleared_DNSToTag
}

// RemoveDNSToTagIDs removes the "DNSToTag" edge to the Tag entity by IDs.
func (m *DNSMutation) RemoveDNSToTagIDs(ids ...int) {
	if m.removed_DNSToTag == nil {
		m.removed_DNSToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DNSToTag[ids[i]] = struct{}{}
	}
}

// RemovedDNSToTag returns the removed IDs of the "DNSToTag" edge to the Tag entity.
func (m *DNSMutation) RemovedDNSToTagIDs() (ids []int) {
	for id := range m.removed_DNSToTag {
		ids = append(ids, id)
	}
	return
}

// DNSToTagIDs returns the "DNSToTag" edge IDs in the mutation.
func (m *DNSMutation) DNSToTagIDs() (ids []int) {
	for id := range m._DNSToTag {
		ids = append(ids, id)
	}
	return
}

// ResetDNSToTag resets all changes to the "DNSToTag" edge.
func (m *DNSMutation) ResetDNSToTag() {
	m._DNSToTag = nil
	m.cleared_DNSToTag = false
	m.removed_DNSToTag = nil
}

// Op returns the operation name.
func (m *DNSMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNS).
func (m *DNSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, dns.FieldHclID)
	}
	if m._type != nil {
		fields = append(fields, dns.FieldType)
	}
	if m.root_domain != nil {
		fields = append(fields, dns.FieldRootDomain)
	}
	if m.dns_servers != nil {
		fields = append(fields, dns.FieldDNSServers)
	}
	if m.ntp_servers != nil {
		fields = append(fields, dns.FieldNtpServers)
	}
	if m._config != nil {
		fields = append(fields, dns.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dns.FieldHclID:
		return m.HclID()
	case dns.FieldType:
		return m.GetType()
	case dns.FieldRootDomain:
		return m.RootDomain()
	case dns.FieldDNSServers:
		return m.DNSServers()
	case dns.FieldNtpServers:
		return m.NtpServers()
	case dns.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dns.FieldHclID:
		return m.OldHclID(ctx)
	case dns.FieldType:
		return m.OldType(ctx)
	case dns.FieldRootDomain:
		return m.OldRootDomain(ctx)
	case dns.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case dns.FieldNtpServers:
		return m.OldNtpServers(ctx)
	case dns.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown DNS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dns.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case dns.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dns.FieldRootDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootDomain(v)
		return nil
	case dns.FieldDNSServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case dns.FieldNtpServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNtpServers(v)
		return nil
	case dns.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSMutation) ResetField(name string) error {
	switch name {
	case dns.FieldHclID:
		m.ResetHclID()
		return nil
	case dns.FieldType:
		m.ResetType()
		return nil
	case dns.FieldRootDomain:
		m.ResetRootDomain()
		return nil
	case dns.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case dns.FieldNtpServers:
		m.ResetNtpServers()
		return nil
	case dns.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._DNSToTag != nil {
		edges = append(edges, dns.EdgeDNSToTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dns.EdgeDNSToTag:
		ids := make([]ent.Value, 0, len(m._DNSToTag))
		for id := range m._DNSToTag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_DNSToTag != nil {
		edges = append(edges, dns.EdgeDNSToTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dns.EdgeDNSToTag:
		ids := make([]ent.Value, 0, len(m.removed_DNSToTag))
		for id := range m.removed_DNSToTag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_DNSToTag {
		edges = append(edges, dns.EdgeDNSToTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSMutation) EdgeCleared(name string) bool {
	switch name {
	case dns.EdgeDNSToTag:
		return m.cleared_DNSToTag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSMutation) ResetEdge(name string) error {
	switch name {
	case dns.EdgeDNSToTag:
		m.ResetDNSToTag()
		return nil
	}
	return fmt.Errorf("unknown DNS edge %s", name)
}

// DNSRecordMutation represents an operation that mutates the DNSRecord nodes in the graph.
type DNSRecordMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	hcl_id                         *string
	name                           *string
	values                         *[]string
	_type                          *string
	zone                           *string
	vars                           *map[string]string
	disabled                       *bool
	tags                           *map[string]string
	clearedFields                  map[string]struct{}
	_DNSRecordToTag                map[int]struct{}
	removed_DNSRecordToTag         map[int]struct{}
	cleared_DNSRecordToTag         bool
	_DNSRecordToEnvironment        map[int]struct{}
	removed_DNSRecordToEnvironment map[int]struct{}
	cleared_DNSRecordToEnvironment bool
	done                           bool
	oldValue                       func(context.Context) (*DNSRecord, error)
	predicates                     []predicate.DNSRecord
}

var _ ent.Mutation = (*DNSRecordMutation)(nil)

// dnsrecordOption allows management of the mutation configuration using functional options.
type dnsrecordOption func(*DNSRecordMutation)

// newDNSRecordMutation creates new mutation for the DNSRecord entity.
func newDNSRecordMutation(c config, op Op, opts ...dnsrecordOption) *DNSRecordMutation {
	m := &DNSRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSRecordID sets the ID field of the mutation.
func withDNSRecordID(id int) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSRecord
		)
		m.oldValue = func(ctx context.Context) (*DNSRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSRecord sets the old DNSRecord of the mutation.
func withDNSRecord(node *DNSRecord) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		m.oldValue = func(context.Context) (*DNSRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DNSRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *DNSRecordMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *DNSRecordMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *DNSRecordMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *DNSRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DNSRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DNSRecordMutation) ResetName() {
	m.name = nil
}

// SetValues sets the "values" field.
func (m *DNSRecordMutation) SetValues(s []string) {
	m.values = &s
}

// Values returns the value of the "values" field in the mutation.
func (m *DNSRecordMutation) Values() (r []string, exists bool) {
	v := m.values
	if v == nil {
		return
	}
	return *v, true
}

// OldValues returns the old "values" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValues: %w", err)
	}
	return oldValue.Values, nil
}

// ResetValues resets all changes to the "values" field.
func (m *DNSRecordMutation) ResetValues() {
	m.values = nil
}

// SetType sets the "type" field.
func (m *DNSRecordMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSRecordMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSRecordMutation) ResetType() {
	m._type = nil
}

// SetZone sets the "zone" field.
func (m *DNSRecordMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the value of the "zone" field in the mutation.
func (m *DNSRecordMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old "zone" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ResetZone resets all changes to the "zone" field.
func (m *DNSRecordMutation) ResetZone() {
	m.zone = nil
}

// SetVars sets the "vars" field.
func (m *DNSRecordMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *DNSRecordMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *DNSRecordMutation) ResetVars() {
	m.vars = nil
}

// SetDisabled sets the "disabled" field.
func (m *DNSRecordMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *DNSRecordMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *DNSRecordMutation) ResetDisabled() {
	m.disabled = nil
}

// SetTags sets the "tags" field.
func (m *DNSRecordMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DNSRecordMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *DNSRecordMutation) ResetTags() {
	m.tags = nil
}

// AddDNSRecordToTagIDs adds the "DNSRecordToTag" edge to the Tag entity by ids.
func (m *DNSRecordMutation) AddDNSRecordToTagIDs(ids ...int) {
	if m._DNSRecordToTag == nil {
		m._DNSRecordToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._DNSRecordToTag[ids[i]] = struct{}{}
	}
}

// ClearDNSRecordToTag clears the "DNSRecordToTag" edge to the Tag entity.
func (m *DNSRecordMutation) ClearDNSRecordToTag() {
	m.cleared_DNSRecordToTag = true
}

// DNSRecordToTagCleared returns if the "DNSRecordToTag" edge to the Tag entity was cleared.
func (m *DNSRecordMutation) DNSRecordToTagCleared() bool {
	return m.cleared_DNSRecordToTag
}

// RemoveDNSRecordToTagIDs removes the "DNSRecordToTag" edge to the Tag entity by IDs.
func (m *DNSRecordMutation) RemoveDNSRecordToTagIDs(ids ...int) {
	if m.removed_DNSRecordToTag == nil {
		m.removed_DNSRecordToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DNSRecordToTag[ids[i]] = struct{}{}
	}
}

// RemovedDNSRecordToTag returns the removed IDs of the "DNSRecordToTag" edge to the Tag entity.
func (m *DNSRecordMutation) RemovedDNSRecordToTagIDs() (ids []int) {
	for id := range m.removed_DNSRecordToTag {
		ids = append(ids, id)
	}
	return
}

// DNSRecordToTagIDs returns the "DNSRecordToTag" edge IDs in the mutation.
func (m *DNSRecordMutation) DNSRecordToTagIDs() (ids []int) {
	for id := range m._DNSRecordToTag {
		ids = append(ids, id)
	}
	return
}

// ResetDNSRecordToTag resets all changes to the "DNSRecordToTag" edge.
func (m *DNSRecordMutation) ResetDNSRecordToTag() {
	m._DNSRecordToTag = nil
	m.cleared_DNSRecordToTag = false
	m.removed_DNSRecordToTag = nil
}

// AddDNSRecordToEnvironmentIDs adds the "DNSRecordToEnvironment" edge to the Environment entity by ids.
func (m *DNSRecordMutation) AddDNSRecordToEnvironmentIDs(ids ...int) {
	if m._DNSRecordToEnvironment == nil {
		m._DNSRecordToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._DNSRecordToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearDNSRecordToEnvironment clears the "DNSRecordToEnvironment" edge to the Environment entity.
func (m *DNSRecordMutation) ClearDNSRecordToEnvironment() {
	m.cleared_DNSRecordToEnvironment = true
}

// DNSRecordToEnvironmentCleared returns if the "DNSRecordToEnvironment" edge to the Environment entity was cleared.
func (m *DNSRecordMutation) DNSRecordToEnvironmentCleared() bool {
	return m.cleared_DNSRecordToEnvironment
}

// RemoveDNSRecordToEnvironmentIDs removes the "DNSRecordToEnvironment" edge to the Environment entity by IDs.
func (m *DNSRecordMutation) RemoveDNSRecordToEnvironmentIDs(ids ...int) {
	if m.removed_DNSRecordToEnvironment == nil {
		m.removed_DNSRecordToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DNSRecordToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedDNSRecordToEnvironment returns the removed IDs of the "DNSRecordToEnvironment" edge to the Environment entity.
func (m *DNSRecordMutation) RemovedDNSRecordToEnvironmentIDs() (ids []int) {
	for id := range m.removed_DNSRecordToEnvironment {
		ids = append(ids, id)
	}
	return
}

// DNSRecordToEnvironmentIDs returns the "DNSRecordToEnvironment" edge IDs in the mutation.
func (m *DNSRecordMutation) DNSRecordToEnvironmentIDs() (ids []int) {
	for id := range m._DNSRecordToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetDNSRecordToEnvironment resets all changes to the "DNSRecordToEnvironment" edge.
func (m *DNSRecordMutation) ResetDNSRecordToEnvironment() {
	m._DNSRecordToEnvironment = nil
	m.cleared_DNSRecordToEnvironment = false
	m.removed_DNSRecordToEnvironment = nil
}

// Op returns the operation name.
func (m *DNSRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSRecord).
func (m *DNSRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.hcl_id != nil {
		fields = append(fields, dnsrecord.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, dnsrecord.FieldName)
	}
	if m.values != nil {
		fields = append(fields, dnsrecord.FieldValues)
	}
	if m._type != nil {
		fields = append(fields, dnsrecord.FieldType)
	}
	if m.zone != nil {
		fields = append(fields, dnsrecord.FieldZone)
	}
	if m.vars != nil {
		fields = append(fields, dnsrecord.FieldVars)
	}
	if m.disabled != nil {
		fields = append(fields, dnsrecord.FieldDisabled)
	}
	if m.tags != nil {
		fields = append(fields, dnsrecord.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsrecord.FieldHclID:
		return m.HclID()
	case dnsrecord.FieldName:
		return m.Name()
	case dnsrecord.FieldValues:
		return m.Values()
	case dnsrecord.FieldType:
		return m.GetType()
	case dnsrecord.FieldZone:
		return m.Zone()
	case dnsrecord.FieldVars:
		return m.Vars()
	case dnsrecord.FieldDisabled:
		return m.Disabled()
	case dnsrecord.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsrecord.FieldHclID:
		return m.OldHclID(ctx)
	case dnsrecord.FieldName:
		return m.OldName(ctx)
	case dnsrecord.FieldValues:
		return m.OldValues(ctx)
	case dnsrecord.FieldType:
		return m.OldType(ctx)
	case dnsrecord.FieldZone:
		return m.OldZone(ctx)
	case dnsrecord.FieldVars:
		return m.OldVars(ctx)
	case dnsrecord.FieldDisabled:
		return m.OldDisabled(ctx)
	case dnsrecord.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown DNSRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsrecord.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case dnsrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsrecord.FieldValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValues(v)
		return nil
	case dnsrecord.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dnsrecord.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	case dnsrecord.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case dnsrecord.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case dnsrecord.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSRecordMutation) ResetField(name string) error {
	switch name {
	case dnsrecord.FieldHclID:
		m.ResetHclID()
		return nil
	case dnsrecord.FieldName:
		m.ResetName()
		return nil
	case dnsrecord.FieldValues:
		m.ResetValues()
		return nil
	case dnsrecord.FieldType:
		m.ResetType()
		return nil
	case dnsrecord.FieldZone:
		m.ResetZone()
		return nil
	case dnsrecord.FieldVars:
		m.ResetVars()
		return nil
	case dnsrecord.FieldDisabled:
		m.ResetDisabled()
		return nil
	case dnsrecord.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._DNSRecordToTag != nil {
		edges = append(edges, dnsrecord.EdgeDNSRecordToTag)
	}
	if m._DNSRecordToEnvironment != nil {
		edges = append(edges, dnsrecord.EdgeDNSRecordToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dnsrecord.EdgeDNSRecordToTag:
		ids := make([]ent.Value, 0, len(m._DNSRecordToTag))
		for id := range m._DNSRecordToTag {
			ids = append(ids, id)
		}
		return ids
	case dnsrecord.EdgeDNSRecordToEnvironment:
		ids := make([]ent.Value, 0, len(m._DNSRecordToEnvironment))
		for id := range m._DNSRecordToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_DNSRecordToTag != nil {
		edges = append(edges, dnsrecord.EdgeDNSRecordToTag)
	}
	if m.removed_DNSRecordToEnvironment != nil {
		edges = append(edges, dnsrecord.EdgeDNSRecordToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dnsrecord.EdgeDNSRecordToTag:
		ids := make([]ent.Value, 0, len(m.removed_DNSRecordToTag))
		for id := range m.removed_DNSRecordToTag {
			ids = append(ids, id)
		}
		return ids
	case dnsrecord.EdgeDNSRecordToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_DNSRecordToEnvironment))
		for id := range m.removed_DNSRecordToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_DNSRecordToTag {
		edges = append(edges, dnsrecord.EdgeDNSRecordToTag)
	}
	if m.cleared_DNSRecordToEnvironment {
		edges = append(edges, dnsrecord.EdgeDNSRecordToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case dnsrecord.EdgeDNSRecordToTag:
		return m.cleared_DNSRecordToTag
	case dnsrecord.EdgeDNSRecordToEnvironment:
		return m.cleared_DNSRecordToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSRecordMutation) ResetEdge(name string) error {
	switch name {
	case dnsrecord.EdgeDNSRecordToTag:
		m.ResetDNSRecordToTag()
		return nil
	case dnsrecord.EdgeDNSRecordToEnvironment:
		m.ResetDNSRecordToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord edge %s", name)
}

// DiskMutation represents an operation that mutates the Disk nodes in the graph.
type DiskMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	size               *int
	addsize            *int
	clearedFields      map[string]struct{}
	_DiskToTag         map[int]struct{}
	removed_DiskToTag  map[int]struct{}
	cleared_DiskToTag  bool
	_DiskToHost        map[int]struct{}
	removed_DiskToHost map[int]struct{}
	cleared_DiskToHost bool
	done               bool
	oldValue           func(context.Context) (*Disk, error)
	predicates         []predicate.Disk
}

var _ ent.Mutation = (*DiskMutation)(nil)

// diskOption allows management of the mutation configuration using functional options.
type diskOption func(*DiskMutation)

// newDiskMutation creates new mutation for the Disk entity.
func newDiskMutation(c config, op Op, opts ...diskOption) *DiskMutation {
	m := &DiskMutation{
		config:        c,
		op:            op,
		typ:           TypeDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiskID sets the ID field of the mutation.
func withDiskID(id int) diskOption {
	return func(m *DiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Disk
		)
		m.oldValue = func(ctx context.Context) (*Disk, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisk sets the old Disk of the mutation.
func withDisk(node *Disk) diskOption {
	return func(m *DiskMutation) {
		m.oldValue = func(context.Context) (*Disk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSize sets the "size" field.
func (m *DiskMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *DiskMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *DiskMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *DiskMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *DiskMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// AddDiskToTagIDs adds the "DiskToTag" edge to the Tag entity by ids.
func (m *DiskMutation) AddDiskToTagIDs(ids ...int) {
	if m._DiskToTag == nil {
		m._DiskToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._DiskToTag[ids[i]] = struct{}{}
	}
}

// ClearDiskToTag clears the "DiskToTag" edge to the Tag entity.
func (m *DiskMutation) ClearDiskToTag() {
	m.cleared_DiskToTag = true
}

// DiskToTagCleared returns if the "DiskToTag" edge to the Tag entity was cleared.
func (m *DiskMutation) DiskToTagCleared() bool {
	return m.cleared_DiskToTag
}

// RemoveDiskToTagIDs removes the "DiskToTag" edge to the Tag entity by IDs.
func (m *DiskMutation) RemoveDiskToTagIDs(ids ...int) {
	if m.removed_DiskToTag == nil {
		m.removed_DiskToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DiskToTag[ids[i]] = struct{}{}
	}
}

// RemovedDiskToTag returns the removed IDs of the "DiskToTag" edge to the Tag entity.
func (m *DiskMutation) RemovedDiskToTagIDs() (ids []int) {
	for id := range m.removed_DiskToTag {
		ids = append(ids, id)
	}
	return
}

// DiskToTagIDs returns the "DiskToTag" edge IDs in the mutation.
func (m *DiskMutation) DiskToTagIDs() (ids []int) {
	for id := range m._DiskToTag {
		ids = append(ids, id)
	}
	return
}

// ResetDiskToTag resets all changes to the "DiskToTag" edge.
func (m *DiskMutation) ResetDiskToTag() {
	m._DiskToTag = nil
	m.cleared_DiskToTag = false
	m.removed_DiskToTag = nil
}

// AddDiskToHostIDs adds the "DiskToHost" edge to the Host entity by ids.
func (m *DiskMutation) AddDiskToHostIDs(ids ...int) {
	if m._DiskToHost == nil {
		m._DiskToHost = make(map[int]struct{})
	}
	for i := range ids {
		m._DiskToHost[ids[i]] = struct{}{}
	}
}

// ClearDiskToHost clears the "DiskToHost" edge to the Host entity.
func (m *DiskMutation) ClearDiskToHost() {
	m.cleared_DiskToHost = true
}

// DiskToHostCleared returns if the "DiskToHost" edge to the Host entity was cleared.
func (m *DiskMutation) DiskToHostCleared() bool {
	return m.cleared_DiskToHost
}

// RemoveDiskToHostIDs removes the "DiskToHost" edge to the Host entity by IDs.
func (m *DiskMutation) RemoveDiskToHostIDs(ids ...int) {
	if m.removed_DiskToHost == nil {
		m.removed_DiskToHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DiskToHost[ids[i]] = struct{}{}
	}
}

// RemovedDiskToHost returns the removed IDs of the "DiskToHost" edge to the Host entity.
func (m *DiskMutation) RemovedDiskToHostIDs() (ids []int) {
	for id := range m.removed_DiskToHost {
		ids = append(ids, id)
	}
	return
}

// DiskToHostIDs returns the "DiskToHost" edge IDs in the mutation.
func (m *DiskMutation) DiskToHostIDs() (ids []int) {
	for id := range m._DiskToHost {
		ids = append(ids, id)
	}
	return
}

// ResetDiskToHost resets all changes to the "DiskToHost" edge.
func (m *DiskMutation) ResetDiskToHost() {
	m._DiskToHost = nil
	m.cleared_DiskToHost = false
	m.removed_DiskToHost = nil
}

// Op returns the operation name.
func (m *DiskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disk).
func (m *DiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiskMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.size != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disk.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown Disk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiskMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiskMutation) ResetField(name string) error {
	switch name {
	case disk.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._DiskToTag != nil {
		edges = append(edges, disk.EdgeDiskToTag)
	}
	if m._DiskToHost != nil {
		edges = append(edges, disk.EdgeDiskToHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeDiskToTag:
		ids := make([]ent.Value, 0, len(m._DiskToTag))
		for id := range m._DiskToTag {
			ids = append(ids, id)
		}
		return ids
	case disk.EdgeDiskToHost:
		ids := make([]ent.Value, 0, len(m._DiskToHost))
		for id := range m._DiskToHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_DiskToTag != nil {
		edges = append(edges, disk.EdgeDiskToTag)
	}
	if m.removed_DiskToHost != nil {
		edges = append(edges, disk.EdgeDiskToHost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeDiskToTag:
		ids := make([]ent.Value, 0, len(m.removed_DiskToTag))
		for id := range m.removed_DiskToTag {
			ids = append(ids, id)
		}
		return ids
	case disk.EdgeDiskToHost:
		ids := make([]ent.Value, 0, len(m.removed_DiskToHost))
		for id := range m.removed_DiskToHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_DiskToTag {
		edges = append(edges, disk.EdgeDiskToTag)
	}
	if m.cleared_DiskToHost {
		edges = append(edges, disk.EdgeDiskToHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiskMutation) EdgeCleared(name string) bool {
	switch name {
	case disk.EdgeDiskToTag:
		return m.cleared_DiskToTag
	case disk.EdgeDiskToHost:
		return m.cleared_DiskToHost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiskMutation) ResetEdge(name string) error {
	switch name {
	case disk.EdgeDiskToTag:
		m.ResetDiskToTag()
		return nil
	case disk.EdgeDiskToHost:
		m.ResetDiskToHost()
		return nil
	}
	return fmt.Errorf("unknown Disk edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	hcl_id                               *string
	competition_id                       *string
	name                                 *string
	description                          *string
	builder                              *string
	team_count                           *int
	addteam_count                        *int
	revision                             *int
	addrevision                          *int
	admin_cidrs                          *[]string
	exposed_vdi_ports                    *[]string
	_config                              *map[string]string
	tags                                 *map[string]string
	clearedFields                        map[string]struct{}
	_EnvironmentToTag                    map[int]struct{}
	removed_EnvironmentToTag             map[int]struct{}
	cleared_EnvironmentToTag             bool
	_EnvironmentToUser                   map[int]struct{}
	removed_EnvironmentToUser            map[int]struct{}
	cleared_EnvironmentToUser            bool
	_EnvironmentToHost                   map[int]struct{}
	removed_EnvironmentToHost            map[int]struct{}
	cleared_EnvironmentToHost            bool
	_EnvironmentToCompetition            map[int]struct{}
	removed_EnvironmentToCompetition     map[int]struct{}
	cleared_EnvironmentToCompetition     bool
	_EnvironmentToBuild                  map[int]struct{}
	removed_EnvironmentToBuild           map[int]struct{}
	cleared_EnvironmentToBuild           bool
	_EnvironmentToIdentity               map[int]struct{}
	removed_EnvironmentToIdentity        map[int]struct{}
	cleared_EnvironmentToIdentity        bool
	_EnvironmentToCommand                map[int]struct{}
	removed_EnvironmentToCommand         map[int]struct{}
	cleared_EnvironmentToCommand         bool
	_EnvironmentToScript                 map[int]struct{}
	removed_EnvironmentToScript          map[int]struct{}
	cleared_EnvironmentToScript          bool
	_EnvironmentToFileDownload           map[int]struct{}
	removed_EnvironmentToFileDownload    map[int]struct{}
	cleared_EnvironmentToFileDownload    bool
	_EnvironmentToFileDelete             map[int]struct{}
	removed_EnvironmentToFileDelete      map[int]struct{}
	cleared_EnvironmentToFileDelete      bool
	_EnvironmentToFileExtract            map[int]struct{}
	removed_EnvironmentToFileExtract     map[int]struct{}
	cleared_EnvironmentToFileExtract     bool
	_EnvironmentToIncludedNetwork        map[int]struct{}
	removed_EnvironmentToIncludedNetwork map[int]struct{}
	cleared_EnvironmentToIncludedNetwork bool
	_EnvironmentToFinding                map[int]struct{}
	removed_EnvironmentToFinding         map[int]struct{}
	cleared_EnvironmentToFinding         bool
	_EnvironmentToDNSRecord              map[int]struct{}
	removed_EnvironmentToDNSRecord       map[int]struct{}
	cleared_EnvironmentToDNSRecord       bool
	_EnvironmentToNetwork                map[int]struct{}
	removed_EnvironmentToNetwork         map[int]struct{}
	cleared_EnvironmentToNetwork         bool
	_EnvironmentToHostDependency         map[int]struct{}
	removed_EnvironmentToHostDependency  map[int]struct{}
	cleared_EnvironmentToHostDependency  bool
	_EnvironmentToTeam                   map[int]struct{}
	removed_EnvironmentToTeam            map[int]struct{}
	cleared_EnvironmentToTeam            bool
	done                                 bool
	oldValue                             func(context.Context) (*Environment, error)
	predicates                           []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id int) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *EnvironmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *EnvironmentMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *EnvironmentMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *EnvironmentMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *EnvironmentMutation) SetCompetitionID(s string) {
	m.competition_id = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *EnvironmentMutation) CompetitionID() (r string, exists bool) {
	v := m.competition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *EnvironmentMutation) ResetCompetitionID() {
	m.competition_id = nil
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
}

// SetBuilder sets the "builder" field.
func (m *EnvironmentMutation) SetBuilder(s string) {
	m.builder = &s
}

// Builder returns the value of the "builder" field in the mutation.
func (m *EnvironmentMutation) Builder() (r string, exists bool) {
	v := m.builder
	if v == nil {
		return
	}
	return *v, true
}

// OldBuilder returns the old "builder" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldBuilder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuilder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuilder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuilder: %w", err)
	}
	return oldValue.Builder, nil
}

// ResetBuilder resets all changes to the "builder" field.
func (m *EnvironmentMutation) ResetBuilder() {
	m.builder = nil
}

// SetTeamCount sets the "team_count" field.
func (m *EnvironmentMutation) SetTeamCount(i int) {
	m.team_count = &i
	m.addteam_count = nil
}

// TeamCount returns the value of the "team_count" field in the mutation.
func (m *EnvironmentMutation) TeamCount() (r int, exists bool) {
	v := m.team_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamCount returns the old "team_count" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldTeamCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeamCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeamCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamCount: %w", err)
	}
	return oldValue.TeamCount, nil
}

// AddTeamCount adds i to the "team_count" field.
func (m *EnvironmentMutation) AddTeamCount(i int) {
	if m.addteam_count != nil {
		*m.addteam_count += i
	} else {
		m.addteam_count = &i
	}
}

// AddedTeamCount returns the value that was added to the "team_count" field in this mutation.
func (m *EnvironmentMutation) AddedTeamCount() (r int, exists bool) {
	v := m.addteam_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamCount resets all changes to the "team_count" field.
func (m *EnvironmentMutation) ResetTeamCount() {
	m.team_count = nil
	m.addteam_count = nil
}

// SetRevision sets the "revision" field.
func (m *EnvironmentMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *EnvironmentMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *EnvironmentMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *EnvironmentMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *EnvironmentMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetAdminCidrs sets the "admin_cidrs" field.
func (m *EnvironmentMutation) SetAdminCidrs(s []string) {
	m.admin_cidrs = &s
}

// AdminCidrs returns the value of the "admin_cidrs" field in the mutation.
func (m *EnvironmentMutation) AdminCidrs() (r []string, exists bool) {
	v := m.admin_cidrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminCidrs returns the old "admin_cidrs" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldAdminCidrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminCidrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminCidrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminCidrs: %w", err)
	}
	return oldValue.AdminCidrs, nil
}

// ResetAdminCidrs resets all changes to the "admin_cidrs" field.
func (m *EnvironmentMutation) ResetAdminCidrs() {
	m.admin_cidrs = nil
}

// SetExposedVdiPorts sets the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) SetExposedVdiPorts(s []string) {
	m.exposed_vdi_ports = &s
}

// ExposedVdiPorts returns the value of the "exposed_vdi_ports" field in the mutation.
func (m *EnvironmentMutation) ExposedVdiPorts() (r []string, exists bool) {
	v := m.exposed_vdi_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedVdiPorts returns the old "exposed_vdi_ports" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldExposedVdiPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExposedVdiPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExposedVdiPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedVdiPorts: %w", err)
	}
	return oldValue.ExposedVdiPorts, nil
}

// ResetExposedVdiPorts resets all changes to the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) ResetExposedVdiPorts() {
	m.exposed_vdi_ports = nil
}

// SetConfig sets the "config" field.
func (m *EnvironmentMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *EnvironmentMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *EnvironmentMutation) ResetConfig() {
	m._config = nil
}

// SetTags sets the "tags" field.
func (m *EnvironmentMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EnvironmentMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *EnvironmentMutation) ResetTags() {
	m.tags = nil
}

// AddEnvironmentToTagIDs adds the "EnvironmentToTag" edge to the Tag entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToTagIDs(ids ...int) {
	if m._EnvironmentToTag == nil {
		m._EnvironmentToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToTag[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToTag clears the "EnvironmentToTag" edge to the Tag entity.
func (m *EnvironmentMutation) ClearEnvironmentToTag() {
	m.cleared_EnvironmentToTag = true
}

// EnvironmentToTagCleared returns if the "EnvironmentToTag" edge to the Tag entity was cleared.
func (m *EnvironmentMutation) EnvironmentToTagCleared() bool {
	return m.cleared_EnvironmentToTag
}

// RemoveEnvironmentToTagIDs removes the "EnvironmentToTag" edge to the Tag entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToTagIDs(ids ...int) {
	if m.removed_EnvironmentToTag == nil {
		m.removed_EnvironmentToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToTag[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToTag returns the removed IDs of the "EnvironmentToTag" edge to the Tag entity.
func (m *EnvironmentMutation) RemovedEnvironmentToTagIDs() (ids []int) {
	for id := range m.removed_EnvironmentToTag {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToTagIDs returns the "EnvironmentToTag" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToTagIDs() (ids []int) {
	for id := range m._EnvironmentToTag {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToTag resets all changes to the "EnvironmentToTag" edge.
func (m *EnvironmentMutation) ResetEnvironmentToTag() {
	m._EnvironmentToTag = nil
	m.cleared_EnvironmentToTag = false
	m.removed_EnvironmentToTag = nil
}

// AddEnvironmentToUserIDs adds the "EnvironmentToUser" edge to the User entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToUserIDs(ids ...int) {
	if m._EnvironmentToUser == nil {
		m._EnvironmentToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToUser[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToUser clears the "EnvironmentToUser" edge to the User entity.
func (m *EnvironmentMutation) ClearEnvironmentToUser() {
	m.cleared_EnvironmentToUser = true
}

// EnvironmentToUserCleared returns if the "EnvironmentToUser" edge to the User entity was cleared.
func (m *EnvironmentMutation) EnvironmentToUserCleared() bool {
	return m.cleared_EnvironmentToUser
}

// RemoveEnvironmentToUserIDs removes the "EnvironmentToUser" edge to the User entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToUserIDs(ids ...int) {
	if m.removed_EnvironmentToUser == nil {
		m.removed_EnvironmentToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToUser[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToUser returns the removed IDs of the "EnvironmentToUser" edge to the User entity.
func (m *EnvironmentMutation) RemovedEnvironmentToUserIDs() (ids []int) {
	for id := range m.removed_EnvironmentToUser {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToUserIDs returns the "EnvironmentToUser" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToUserIDs() (ids []int) {
	for id := range m._EnvironmentToUser {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToUser resets all changes to the "EnvironmentToUser" edge.
func (m *EnvironmentMutation) ResetEnvironmentToUser() {
	m._EnvironmentToUser = nil
	m.cleared_EnvironmentToUser = false
	m.removed_EnvironmentToUser = nil
}

// AddEnvironmentToHostIDs adds the "EnvironmentToHost" edge to the Host entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToHostIDs(ids ...int) {
	if m._EnvironmentToHost == nil {
		m._EnvironmentToHost = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToHost[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToHost clears the "EnvironmentToHost" edge to the Host entity.
func (m *EnvironmentMutation) ClearEnvironmentToHost() {
	m.cleared_EnvironmentToHost = true
}

// EnvironmentToHostCleared returns if the "EnvironmentToHost" edge to the Host entity was cleared.
func (m *EnvironmentMutation) EnvironmentToHostCleared() bool {
	return m.cleared_EnvironmentToHost
}

// RemoveEnvironmentToHostIDs removes the "EnvironmentToHost" edge to the Host entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToHostIDs(ids ...int) {
	if m.removed_EnvironmentToHost == nil {
		m.removed_EnvironmentToHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToHost[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToHost returns the removed IDs of the "EnvironmentToHost" edge to the Host entity.
func (m *EnvironmentMutation) RemovedEnvironmentToHostIDs() (ids []int) {
	for id := range m.removed_EnvironmentToHost {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToHostIDs returns the "EnvironmentToHost" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToHostIDs() (ids []int) {
	for id := range m._EnvironmentToHost {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToHost resets all changes to the "EnvironmentToHost" edge.
func (m *EnvironmentMutation) ResetEnvironmentToHost() {
	m._EnvironmentToHost = nil
	m.cleared_EnvironmentToHost = false
	m.removed_EnvironmentToHost = nil
}

// AddEnvironmentToCompetitionIDs adds the "EnvironmentToCompetition" edge to the Competition entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToCompetitionIDs(ids ...int) {
	if m._EnvironmentToCompetition == nil {
		m._EnvironmentToCompetition = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToCompetition[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToCompetition clears the "EnvironmentToCompetition" edge to the Competition entity.
func (m *EnvironmentMutation) ClearEnvironmentToCompetition() {
	m.cleared_EnvironmentToCompetition = true
}

// EnvironmentToCompetitionCleared returns if the "EnvironmentToCompetition" edge to the Competition entity was cleared.
func (m *EnvironmentMutation) EnvironmentToCompetitionCleared() bool {
	return m.cleared_EnvironmentToCompetition
}

// RemoveEnvironmentToCompetitionIDs removes the "EnvironmentToCompetition" edge to the Competition entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToCompetitionIDs(ids ...int) {
	if m.removed_EnvironmentToCompetition == nil {
		m.removed_EnvironmentToCompetition = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToCompetition[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToCompetition returns the removed IDs of the "EnvironmentToCompetition" edge to the Competition entity.
func (m *EnvironmentMutation) RemovedEnvironmentToCompetitionIDs() (ids []int) {
	for id := range m.removed_EnvironmentToCompetition {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToCompetitionIDs returns the "EnvironmentToCompetition" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToCompetitionIDs() (ids []int) {
	for id := range m._EnvironmentToCompetition {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToCompetition resets all changes to the "EnvironmentToCompetition" edge.
func (m *EnvironmentMutation) ResetEnvironmentToCompetition() {
	m._EnvironmentToCompetition = nil
	m.cleared_EnvironmentToCompetition = false
	m.removed_EnvironmentToCompetition = nil
}

// AddEnvironmentToBuildIDs adds the "EnvironmentToBuild" edge to the Build entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToBuildIDs(ids ...int) {
	if m._EnvironmentToBuild == nil {
		m._EnvironmentToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToBuild[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToBuild clears the "EnvironmentToBuild" edge to the Build entity.
func (m *EnvironmentMutation) ClearEnvironmentToBuild() {
	m.cleared_EnvironmentToBuild = true
}

// EnvironmentToBuildCleared returns if the "EnvironmentToBuild" edge to the Build entity was cleared.
func (m *EnvironmentMutation) EnvironmentToBuildCleared() bool {
	return m.cleared_EnvironmentToBuild
}

// RemoveEnvironmentToBuildIDs removes the "EnvironmentToBuild" edge to the Build entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToBuildIDs(ids ...int) {
	if m.removed_EnvironmentToBuild == nil {
		m.removed_EnvironmentToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToBuild[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToBuild returns the removed IDs of the "EnvironmentToBuild" edge to the Build entity.
func (m *EnvironmentMutation) RemovedEnvironmentToBuildIDs() (ids []int) {
	for id := range m.removed_EnvironmentToBuild {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToBuildIDs returns the "EnvironmentToBuild" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToBuildIDs() (ids []int) {
	for id := range m._EnvironmentToBuild {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToBuild resets all changes to the "EnvironmentToBuild" edge.
func (m *EnvironmentMutation) ResetEnvironmentToBuild() {
	m._EnvironmentToBuild = nil
	m.cleared_EnvironmentToBuild = false
	m.removed_EnvironmentToBuild = nil
}

// AddEnvironmentToIdentityIDs adds the "EnvironmentToIdentity" edge to the Identity entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToIdentityIDs(ids ...int) {
	if m._EnvironmentToIdentity == nil {
		m._EnvironmentToIdentity = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToIdentity[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToIdentity clears the "EnvironmentToIdentity" edge to the Identity entity.
func (m *EnvironmentMutation) ClearEnvironmentToIdentity() {
	m.cleared_EnvironmentToIdentity = true
}

// EnvironmentToIdentityCleared returns if the "EnvironmentToIdentity" edge to the Identity entity was cleared.
func (m *EnvironmentMutation) EnvironmentToIdentityCleared() bool {
	return m.cleared_EnvironmentToIdentity
}

// RemoveEnvironmentToIdentityIDs removes the "EnvironmentToIdentity" edge to the Identity entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToIdentityIDs(ids ...int) {
	if m.removed_EnvironmentToIdentity == nil {
		m.removed_EnvironmentToIdentity = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToIdentity[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToIdentity returns the removed IDs of the "EnvironmentToIdentity" edge to the Identity entity.
func (m *EnvironmentMutation) RemovedEnvironmentToIdentityIDs() (ids []int) {
	for id := range m.removed_EnvironmentToIdentity {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToIdentityIDs returns the "EnvironmentToIdentity" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToIdentityIDs() (ids []int) {
	for id := range m._EnvironmentToIdentity {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToIdentity resets all changes to the "EnvironmentToIdentity" edge.
func (m *EnvironmentMutation) ResetEnvironmentToIdentity() {
	m._EnvironmentToIdentity = nil
	m.cleared_EnvironmentToIdentity = false
	m.removed_EnvironmentToIdentity = nil
}

// AddEnvironmentToCommandIDs adds the "EnvironmentToCommand" edge to the Command entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToCommandIDs(ids ...int) {
	if m._EnvironmentToCommand == nil {
		m._EnvironmentToCommand = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToCommand[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToCommand clears the "EnvironmentToCommand" edge to the Command entity.
func (m *EnvironmentMutation) ClearEnvironmentToCommand() {
	m.cleared_EnvironmentToCommand = true
}

// EnvironmentToCommandCleared returns if the "EnvironmentToCommand" edge to the Command entity was cleared.
func (m *EnvironmentMutation) EnvironmentToCommandCleared() bool {
	return m.cleared_EnvironmentToCommand
}

// RemoveEnvironmentToCommandIDs removes the "EnvironmentToCommand" edge to the Command entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToCommandIDs(ids ...int) {
	if m.removed_EnvironmentToCommand == nil {
		m.removed_EnvironmentToCommand = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToCommand[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToCommand returns the removed IDs of the "EnvironmentToCommand" edge to the Command entity.
func (m *EnvironmentMutation) RemovedEnvironmentToCommandIDs() (ids []int) {
	for id := range m.removed_EnvironmentToCommand {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToCommandIDs returns the "EnvironmentToCommand" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToCommandIDs() (ids []int) {
	for id := range m._EnvironmentToCommand {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToCommand resets all changes to the "EnvironmentToCommand" edge.
func (m *EnvironmentMutation) ResetEnvironmentToCommand() {
	m._EnvironmentToCommand = nil
	m.cleared_EnvironmentToCommand = false
	m.removed_EnvironmentToCommand = nil
}

// AddEnvironmentToScriptIDs adds the "EnvironmentToScript" edge to the Script entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToScriptIDs(ids ...int) {
	if m._EnvironmentToScript == nil {
		m._EnvironmentToScript = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToScript[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToScript clears the "EnvironmentToScript" edge to the Script entity.
func (m *EnvironmentMutation) ClearEnvironmentToScript() {
	m.cleared_EnvironmentToScript = true
}

// EnvironmentToScriptCleared returns if the "EnvironmentToScript" edge to the Script entity was cleared.
func (m *EnvironmentMutation) EnvironmentToScriptCleared() bool {
	return m.cleared_EnvironmentToScript
}

// RemoveEnvironmentToScriptIDs removes the "EnvironmentToScript" edge to the Script entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToScriptIDs(ids ...int) {
	if m.removed_EnvironmentToScript == nil {
		m.removed_EnvironmentToScript = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToScript[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToScript returns the removed IDs of the "EnvironmentToScript" edge to the Script entity.
func (m *EnvironmentMutation) RemovedEnvironmentToScriptIDs() (ids []int) {
	for id := range m.removed_EnvironmentToScript {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToScriptIDs returns the "EnvironmentToScript" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToScriptIDs() (ids []int) {
	for id := range m._EnvironmentToScript {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToScript resets all changes to the "EnvironmentToScript" edge.
func (m *EnvironmentMutation) ResetEnvironmentToScript() {
	m._EnvironmentToScript = nil
	m.cleared_EnvironmentToScript = false
	m.removed_EnvironmentToScript = nil
}

// AddEnvironmentToFileDownloadIDs adds the "EnvironmentToFileDownload" edge to the FileDownload entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFileDownloadIDs(ids ...int) {
	if m._EnvironmentToFileDownload == nil {
		m._EnvironmentToFileDownload = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToFileDownload[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFileDownload clears the "EnvironmentToFileDownload" edge to the FileDownload entity.
func (m *EnvironmentMutation) ClearEnvironmentToFileDownload() {
	m.cleared_EnvironmentToFileDownload = true
}

// EnvironmentToFileDownloadCleared returns if the "EnvironmentToFileDownload" edge to the FileDownload entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFileDownloadCleared() bool {
	return m.cleared_EnvironmentToFileDownload
}

// RemoveEnvironmentToFileDownloadIDs removes the "EnvironmentToFileDownload" edge to the FileDownload entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFileDownloadIDs(ids ...int) {
	if m.removed_EnvironmentToFileDownload == nil {
		m.removed_EnvironmentToFileDownload = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToFileDownload[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFileDownload returns the removed IDs of the "EnvironmentToFileDownload" edge to the FileDownload entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFileDownloadIDs() (ids []int) {
	for id := range m.removed_EnvironmentToFileDownload {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFileDownloadIDs returns the "EnvironmentToFileDownload" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFileDownloadIDs() (ids []int) {
	for id := range m._EnvironmentToFileDownload {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFileDownload resets all changes to the "EnvironmentToFileDownload" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFileDownload() {
	m._EnvironmentToFileDownload = nil
	m.cleared_EnvironmentToFileDownload = false
	m.removed_EnvironmentToFileDownload = nil
}

// AddEnvironmentToFileDeleteIDs adds the "EnvironmentToFileDelete" edge to the FileDelete entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFileDeleteIDs(ids ...int) {
	if m._EnvironmentToFileDelete == nil {
		m._EnvironmentToFileDelete = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToFileDelete[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFileDelete clears the "EnvironmentToFileDelete" edge to the FileDelete entity.
func (m *EnvironmentMutation) ClearEnvironmentToFileDelete() {
	m.cleared_EnvironmentToFileDelete = true
}

// EnvironmentToFileDeleteCleared returns if the "EnvironmentToFileDelete" edge to the FileDelete entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFileDeleteCleared() bool {
	return m.cleared_EnvironmentToFileDelete
}

// RemoveEnvironmentToFileDeleteIDs removes the "EnvironmentToFileDelete" edge to the FileDelete entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFileDeleteIDs(ids ...int) {
	if m.removed_EnvironmentToFileDelete == nil {
		m.removed_EnvironmentToFileDelete = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToFileDelete[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFileDelete returns the removed IDs of the "EnvironmentToFileDelete" edge to the FileDelete entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFileDeleteIDs() (ids []int) {
	for id := range m.removed_EnvironmentToFileDelete {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFileDeleteIDs returns the "EnvironmentToFileDelete" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFileDeleteIDs() (ids []int) {
	for id := range m._EnvironmentToFileDelete {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFileDelete resets all changes to the "EnvironmentToFileDelete" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFileDelete() {
	m._EnvironmentToFileDelete = nil
	m.cleared_EnvironmentToFileDelete = false
	m.removed_EnvironmentToFileDelete = nil
}

// AddEnvironmentToFileExtractIDs adds the "EnvironmentToFileExtract" edge to the FileExtract entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFileExtractIDs(ids ...int) {
	if m._EnvironmentToFileExtract == nil {
		m._EnvironmentToFileExtract = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToFileExtract[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFileExtract clears the "EnvironmentToFileExtract" edge to the FileExtract entity.
func (m *EnvironmentMutation) ClearEnvironmentToFileExtract() {
	m.cleared_EnvironmentToFileExtract = true
}

// EnvironmentToFileExtractCleared returns if the "EnvironmentToFileExtract" edge to the FileExtract entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFileExtractCleared() bool {
	return m.cleared_EnvironmentToFileExtract
}

// RemoveEnvironmentToFileExtractIDs removes the "EnvironmentToFileExtract" edge to the FileExtract entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFileExtractIDs(ids ...int) {
	if m.removed_EnvironmentToFileExtract == nil {
		m.removed_EnvironmentToFileExtract = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToFileExtract[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFileExtract returns the removed IDs of the "EnvironmentToFileExtract" edge to the FileExtract entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFileExtractIDs() (ids []int) {
	for id := range m.removed_EnvironmentToFileExtract {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFileExtractIDs returns the "EnvironmentToFileExtract" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFileExtractIDs() (ids []int) {
	for id := range m._EnvironmentToFileExtract {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFileExtract resets all changes to the "EnvironmentToFileExtract" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFileExtract() {
	m._EnvironmentToFileExtract = nil
	m.cleared_EnvironmentToFileExtract = false
	m.removed_EnvironmentToFileExtract = nil
}

// AddEnvironmentToIncludedNetworkIDs adds the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToIncludedNetworkIDs(ids ...int) {
	if m._EnvironmentToIncludedNetwork == nil {
		m._EnvironmentToIncludedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToIncludedNetwork clears the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *EnvironmentMutation) ClearEnvironmentToIncludedNetwork() {
	m.cleared_EnvironmentToIncludedNetwork = true
}

// EnvironmentToIncludedNetworkCleared returns if the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity was cleared.
func (m *EnvironmentMutation) EnvironmentToIncludedNetworkCleared() bool {
	return m.cleared_EnvironmentToIncludedNetwork
}

// RemoveEnvironmentToIncludedNetworkIDs removes the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToIncludedNetworkIDs(ids ...int) {
	if m.removed_EnvironmentToIncludedNetwork == nil {
		m.removed_EnvironmentToIncludedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToIncludedNetwork returns the removed IDs of the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *EnvironmentMutation) RemovedEnvironmentToIncludedNetworkIDs() (ids []int) {
	for id := range m.removed_EnvironmentToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToIncludedNetworkIDs returns the "EnvironmentToIncludedNetwork" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToIncludedNetworkIDs() (ids []int) {
	for id := range m._EnvironmentToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToIncludedNetwork resets all changes to the "EnvironmentToIncludedNetwork" edge.
func (m *EnvironmentMutation) ResetEnvironmentToIncludedNetwork() {
	m._EnvironmentToIncludedNetwork = nil
	m.cleared_EnvironmentToIncludedNetwork = false
	m.removed_EnvironmentToIncludedNetwork = nil
}

// AddEnvironmentToFindingIDs adds the "EnvironmentToFinding" edge to the Finding entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFindingIDs(ids ...int) {
	if m._EnvironmentToFinding == nil {
		m._EnvironmentToFinding = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToFinding[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFinding clears the "EnvironmentToFinding" edge to the Finding entity.
func (m *EnvironmentMutation) ClearEnvironmentToFinding() {
	m.cleared_EnvironmentToFinding = true
}

// EnvironmentToFindingCleared returns if the "EnvironmentToFinding" edge to the Finding entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFindingCleared() bool {
	return m.cleared_EnvironmentToFinding
}

// RemoveEnvironmentToFindingIDs removes the "EnvironmentToFinding" edge to the Finding entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFindingIDs(ids ...int) {
	if m.removed_EnvironmentToFinding == nil {
		m.removed_EnvironmentToFinding = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToFinding[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFinding returns the removed IDs of the "EnvironmentToFinding" edge to the Finding entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFindingIDs() (ids []int) {
	for id := range m.removed_EnvironmentToFinding {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFindingIDs returns the "EnvironmentToFinding" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFindingIDs() (ids []int) {
	for id := range m._EnvironmentToFinding {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFinding resets all changes to the "EnvironmentToFinding" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFinding() {
	m._EnvironmentToFinding = nil
	m.cleared_EnvironmentToFinding = false
	m.removed_EnvironmentToFinding = nil
}

// AddEnvironmentToDNSRecordIDs adds the "EnvironmentToDNSRecord" edge to the DNSRecord entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToDNSRecordIDs(ids ...int) {
	if m._EnvironmentToDNSRecord == nil {
		m._EnvironmentToDNSRecord = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToDNSRecord[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToDNSRecord clears the "EnvironmentToDNSRecord" edge to the DNSRecord entity.
func (m *EnvironmentMutation) ClearEnvironmentToDNSRecord() {
	m.cleared_EnvironmentToDNSRecord = true
}

// EnvironmentToDNSRecordCleared returns if the "EnvironmentToDNSRecord" edge to the DNSRecord entity was cleared.
func (m *EnvironmentMutation) EnvironmentToDNSRecordCleared() bool {
	return m.cleared_EnvironmentToDNSRecord
}

// RemoveEnvironmentToDNSRecordIDs removes the "EnvironmentToDNSRecord" edge to the DNSRecord entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToDNSRecordIDs(ids ...int) {
	if m.removed_EnvironmentToDNSRecord == nil {
		m.removed_EnvironmentToDNSRecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToDNSRecord[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToDNSRecord returns the removed IDs of the "EnvironmentToDNSRecord" edge to the DNSRecord entity.
func (m *EnvironmentMutation) RemovedEnvironmentToDNSRecordIDs() (ids []int) {
	for id := range m.removed_EnvironmentToDNSRecord {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToDNSRecordIDs returns the "EnvironmentToDNSRecord" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToDNSRecordIDs() (ids []int) {
	for id := range m._EnvironmentToDNSRecord {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToDNSRecord resets all changes to the "EnvironmentToDNSRecord" edge.
func (m *EnvironmentMutation) ResetEnvironmentToDNSRecord() {
	m._EnvironmentToDNSRecord = nil
	m.cleared_EnvironmentToDNSRecord = false
	m.removed_EnvironmentToDNSRecord = nil
}

// AddEnvironmentToNetworkIDs adds the "EnvironmentToNetwork" edge to the Network entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToNetworkIDs(ids ...int) {
	if m._EnvironmentToNetwork == nil {
		m._EnvironmentToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToNetwork[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToNetwork clears the "EnvironmentToNetwork" edge to the Network entity.
func (m *EnvironmentMutation) ClearEnvironmentToNetwork() {
	m.cleared_EnvironmentToNetwork = true
}

// EnvironmentToNetworkCleared returns if the "EnvironmentToNetwork" edge to the Network entity was cleared.
func (m *EnvironmentMutation) EnvironmentToNetworkCleared() bool {
	return m.cleared_EnvironmentToNetwork
}

// RemoveEnvironmentToNetworkIDs removes the "EnvironmentToNetwork" edge to the Network entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToNetworkIDs(ids ...int) {
	if m.removed_EnvironmentToNetwork == nil {
		m.removed_EnvironmentToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToNetwork[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToNetwork returns the removed IDs of the "EnvironmentToNetwork" edge to the Network entity.
func (m *EnvironmentMutation) RemovedEnvironmentToNetworkIDs() (ids []int) {
	for id := range m.removed_EnvironmentToNetwork {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToNetworkIDs returns the "EnvironmentToNetwork" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToNetworkIDs() (ids []int) {
	for id := range m._EnvironmentToNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToNetwork resets all changes to the "EnvironmentToNetwork" edge.
func (m *EnvironmentMutation) ResetEnvironmentToNetwork() {
	m._EnvironmentToNetwork = nil
	m.cleared_EnvironmentToNetwork = false
	m.removed_EnvironmentToNetwork = nil
}

// AddEnvironmentToHostDependencyIDs adds the "EnvironmentToHostDependency" edge to the HostDependency entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToHostDependencyIDs(ids ...int) {
	if m._EnvironmentToHostDependency == nil {
		m._EnvironmentToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToHostDependency clears the "EnvironmentToHostDependency" edge to the HostDependency entity.
func (m *EnvironmentMutation) ClearEnvironmentToHostDependency() {
	m.cleared_EnvironmentToHostDependency = true
}

// EnvironmentToHostDependencyCleared returns if the "EnvironmentToHostDependency" edge to the HostDependency entity was cleared.
func (m *EnvironmentMutation) EnvironmentToHostDependencyCleared() bool {
	return m.cleared_EnvironmentToHostDependency
}

// RemoveEnvironmentToHostDependencyIDs removes the "EnvironmentToHostDependency" edge to the HostDependency entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToHostDependencyIDs(ids ...int) {
	if m.removed_EnvironmentToHostDependency == nil {
		m.removed_EnvironmentToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToHostDependency returns the removed IDs of the "EnvironmentToHostDependency" edge to the HostDependency entity.
func (m *EnvironmentMutation) RemovedEnvironmentToHostDependencyIDs() (ids []int) {
	for id := range m.removed_EnvironmentToHostDependency {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToHostDependencyIDs returns the "EnvironmentToHostDependency" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToHostDependencyIDs() (ids []int) {
	for id := range m._EnvironmentToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToHostDependency resets all changes to the "EnvironmentToHostDependency" edge.
func (m *EnvironmentMutation) ResetEnvironmentToHostDependency() {
	m._EnvironmentToHostDependency = nil
	m.cleared_EnvironmentToHostDependency = false
	m.removed_EnvironmentToHostDependency = nil
}

// AddEnvironmentToTeamIDs adds the "EnvironmentToTeam" edge to the Team entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToTeamIDs(ids ...int) {
	if m._EnvironmentToTeam == nil {
		m._EnvironmentToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m._EnvironmentToTeam[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToTeam clears the "EnvironmentToTeam" edge to the Team entity.
func (m *EnvironmentMutation) ClearEnvironmentToTeam() {
	m.cleared_EnvironmentToTeam = true
}

// EnvironmentToTeamCleared returns if the "EnvironmentToTeam" edge to the Team entity was cleared.
func (m *EnvironmentMutation) EnvironmentToTeamCleared() bool {
	return m.cleared_EnvironmentToTeam
}

// RemoveEnvironmentToTeamIDs removes the "EnvironmentToTeam" edge to the Team entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToTeamIDs(ids ...int) {
	if m.removed_EnvironmentToTeam == nil {
		m.removed_EnvironmentToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EnvironmentToTeam[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToTeam returns the removed IDs of the "EnvironmentToTeam" edge to the Team entity.
func (m *EnvironmentMutation) RemovedEnvironmentToTeamIDs() (ids []int) {
	for id := range m.removed_EnvironmentToTeam {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToTeamIDs returns the "EnvironmentToTeam" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToTeamIDs() (ids []int) {
	for id := range m._EnvironmentToTeam {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToTeam resets all changes to the "EnvironmentToTeam" edge.
func (m *EnvironmentMutation) ResetEnvironmentToTeam() {
	m._EnvironmentToTeam = nil
	m.cleared_EnvironmentToTeam = false
	m.removed_EnvironmentToTeam = nil
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, environment.FieldHclID)
	}
	if m.competition_id != nil {
		fields = append(fields, environment.FieldCompetitionID)
	}
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.builder != nil {
		fields = append(fields, environment.FieldBuilder)
	}
	if m.team_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.revision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	if m.admin_cidrs != nil {
		fields = append(fields, environment.FieldAdminCidrs)
	}
	if m.exposed_vdi_ports != nil {
		fields = append(fields, environment.FieldExposedVdiPorts)
	}
	if m._config != nil {
		fields = append(fields, environment.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, environment.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldHclID:
		return m.HclID()
	case environment.FieldCompetitionID:
		return m.CompetitionID()
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldBuilder:
		return m.Builder()
	case environment.FieldTeamCount:
		return m.TeamCount()
	case environment.FieldRevision:
		return m.Revision()
	case environment.FieldAdminCidrs:
		return m.AdminCidrs()
	case environment.FieldExposedVdiPorts:
		return m.ExposedVdiPorts()
	case environment.FieldConfig:
		return m.Config()
	case environment.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldHclID:
		return m.OldHclID(ctx)
	case environment.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldBuilder:
		return m.OldBuilder(ctx)
	case environment.FieldTeamCount:
		return m.OldTeamCount(ctx)
	case environment.FieldRevision:
		return m.OldRevision(ctx)
	case environment.FieldAdminCidrs:
		return m.OldAdminCidrs(ctx)
	case environment.FieldExposedVdiPorts:
		return m.OldExposedVdiPorts(ctx)
	case environment.FieldConfig:
		return m.OldConfig(ctx)
	case environment.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case environment.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldBuilder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuilder(v)
		return nil
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case environment.FieldAdminCidrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminCidrs(v)
		return nil
	case environment.FieldExposedVdiPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedVdiPorts(v)
		return nil
	case environment.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case environment.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	var fields []string
	if m.addteam_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.addrevision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldTeamCount:
		return m.AddedTeamCount()
	case environment.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldHclID:
		m.ResetHclID()
		return nil
	case environment.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldBuilder:
		m.ResetBuilder()
		return nil
	case environment.FieldTeamCount:
		m.ResetTeamCount()
		return nil
	case environment.FieldRevision:
		m.ResetRevision()
		return nil
	case environment.FieldAdminCidrs:
		m.ResetAdminCidrs()
		return nil
	case environment.FieldExposedVdiPorts:
		m.ResetExposedVdiPorts()
		return nil
	case environment.FieldConfig:
		m.ResetConfig()
		return nil
	case environment.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m._EnvironmentToTag != nil {
		edges = append(edges, environment.EdgeEnvironmentToTag)
	}
	if m._EnvironmentToUser != nil {
		edges = append(edges, environment.EdgeEnvironmentToUser)
	}
	if m._EnvironmentToHost != nil {
		edges = append(edges, environment.EdgeEnvironmentToHost)
	}
	if m._EnvironmentToCompetition != nil {
		edges = append(edges, environment.EdgeEnvironmentToCompetition)
	}
	if m._EnvironmentToBuild != nil {
		edges = append(edges, environment.EdgeEnvironmentToBuild)
	}
	if m._EnvironmentToIdentity != nil {
		edges = append(edges, environment.EdgeEnvironmentToIdentity)
	}
	if m._EnvironmentToCommand != nil {
		edges = append(edges, environment.EdgeEnvironmentToCommand)
	}
	if m._EnvironmentToScript != nil {
		edges = append(edges, environment.EdgeEnvironmentToScript)
	}
	if m._EnvironmentToFileDownload != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDownload)
	}
	if m._EnvironmentToFileDelete != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDelete)
	}
	if m._EnvironmentToFileExtract != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileExtract)
	}
	if m._EnvironmentToIncludedNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToIncludedNetwork)
	}
	if m._EnvironmentToFinding != nil {
		edges = append(edges, environment.EdgeEnvironmentToFinding)
	}
	if m._EnvironmentToDNSRecord != nil {
		edges = append(edges, environment.EdgeEnvironmentToDNSRecord)
	}
	if m._EnvironmentToNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToNetwork)
	}
	if m._EnvironmentToHostDependency != nil {
		edges = append(edges, environment.EdgeEnvironmentToHostDependency)
	}
	if m._EnvironmentToTeam != nil {
		edges = append(edges, environment.EdgeEnvironmentToTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeEnvironmentToTag:
		ids := make([]ent.Value, 0, len(m._EnvironmentToTag))
		for id := range m._EnvironmentToTag {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToUser:
		ids := make([]ent.Value, 0, len(m._EnvironmentToUser))
		for id := range m._EnvironmentToUser {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHost:
		ids := make([]ent.Value, 0, len(m._EnvironmentToHost))
		for id := range m._EnvironmentToHost {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCompetition:
		ids := make([]ent.Value, 0, len(m._EnvironmentToCompetition))
		for id := range m._EnvironmentToCompetition {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToBuild:
		ids := make([]ent.Value, 0, len(m._EnvironmentToBuild))
		for id := range m._EnvironmentToBuild {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIdentity:
		ids := make([]ent.Value, 0, len(m._EnvironmentToIdentity))
		for id := range m._EnvironmentToIdentity {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCommand:
		ids := make([]ent.Value, 0, len(m._EnvironmentToCommand))
		for id := range m._EnvironmentToCommand {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToScript:
		ids := make([]ent.Value, 0, len(m._EnvironmentToScript))
		for id := range m._EnvironmentToScript {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDownload:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFileDownload))
		for id := range m._EnvironmentToFileDownload {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDelete:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFileDelete))
		for id := range m._EnvironmentToFileDelete {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileExtract:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFileExtract))
		for id := range m._EnvironmentToFileExtract {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m._EnvironmentToIncludedNetwork))
		for id := range m._EnvironmentToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFinding:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFinding))
		for id := range m._EnvironmentToFinding {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToDNSRecord:
		ids := make([]ent.Value, 0, len(m._EnvironmentToDNSRecord))
		for id := range m._EnvironmentToDNSRecord {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToNetwork:
		ids := make([]ent.Value, 0, len(m._EnvironmentToNetwork))
		for id := range m._EnvironmentToNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHostDependency:
		ids := make([]ent.Value, 0, len(m._EnvironmentToHostDependency))
		for id := range m._EnvironmentToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToTeam:
		ids := make([]ent.Value, 0, len(m._EnvironmentToTeam))
		for id := range m._EnvironmentToTeam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removed_EnvironmentToTag != nil {
		edges = append(edges, environment.EdgeEnvironmentToTag)
	}
	if m.removed_EnvironmentToUser != nil {
		edges = append(edges, environment.EdgeEnvironmentToUser)
	}
	if m.removed_EnvironmentToHost != nil {
		edges = append(edges, environment.EdgeEnvironmentToHost)
	}
	if m.removed_EnvironmentToCompetition != nil {
		edges = append(edges, environment.EdgeEnvironmentToCompetition)
	}
	if m.removed_EnvironmentToBuild != nil {
		edges = append(edges, environment.EdgeEnvironmentToBuild)
	}
	if m.removed_EnvironmentToIdentity != nil {
		edges = append(edges, environment.EdgeEnvironmentToIdentity)
	}
	if m.removed_EnvironmentToCommand != nil {
		edges = append(edges, environment.EdgeEnvironmentToCommand)
	}
	if m.removed_EnvironmentToScript != nil {
		edges = append(edges, environment.EdgeEnvironmentToScript)
	}
	if m.removed_EnvironmentToFileDownload != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDownload)
	}
	if m.removed_EnvironmentToFileDelete != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDelete)
	}
	if m.removed_EnvironmentToFileExtract != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileExtract)
	}
	if m.removed_EnvironmentToIncludedNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToIncludedNetwork)
	}
	if m.removed_EnvironmentToFinding != nil {
		edges = append(edges, environment.EdgeEnvironmentToFinding)
	}
	if m.removed_EnvironmentToDNSRecord != nil {
		edges = append(edges, environment.EdgeEnvironmentToDNSRecord)
	}
	if m.removed_EnvironmentToNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToNetwork)
	}
	if m.removed_EnvironmentToHostDependency != nil {
		edges = append(edges, environment.EdgeEnvironmentToHostDependency)
	}
	if m.removed_EnvironmentToTeam != nil {
		edges = append(edges, environment.EdgeEnvironmentToTeam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeEnvironmentToTag:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToTag))
		for id := range m.removed_EnvironmentToTag {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToUser:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToUser))
		for id := range m.removed_EnvironmentToUser {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHost:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToHost))
		for id := range m.removed_EnvironmentToHost {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCompetition:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToCompetition))
		for id := range m.removed_EnvironmentToCompetition {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToBuild:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToBuild))
		for id := range m.removed_EnvironmentToBuild {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIdentity:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToIdentity))
		for id := range m.removed_EnvironmentToIdentity {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCommand:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToCommand))
		for id := range m.removed_EnvironmentToCommand {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToScript:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToScript))
		for id := range m.removed_EnvironmentToScript {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDownload:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFileDownload))
		for id := range m.removed_EnvironmentToFileDownload {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDelete:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFileDelete))
		for id := range m.removed_EnvironmentToFileDelete {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileExtract:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFileExtract))
		for id := range m.removed_EnvironmentToFileExtract {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToIncludedNetwork))
		for id := range m.removed_EnvironmentToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFinding:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFinding))
		for id := range m.removed_EnvironmentToFinding {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToDNSRecord:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToDNSRecord))
		for id := range m.removed_EnvironmentToDNSRecord {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToNetwork:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToNetwork))
		for id := range m.removed_EnvironmentToNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToHostDependency))
		for id := range m.removed_EnvironmentToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToTeam:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToTeam))
		for id := range m.removed_EnvironmentToTeam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.cleared_EnvironmentToTag {
		edges = append(edges, environment.EdgeEnvironmentToTag)
	}
	if m.cleared_EnvironmentToUser {
		edges = append(edges, environment.EdgeEnvironmentToUser)
	}
	if m.cleared_EnvironmentToHost {
		edges = append(edges, environment.EdgeEnvironmentToHost)
	}
	if m.cleared_EnvironmentToCompetition {
		edges = append(edges, environment.EdgeEnvironmentToCompetition)
	}
	if m.cleared_EnvironmentToBuild {
		edges = append(edges, environment.EdgeEnvironmentToBuild)
	}
	if m.cleared_EnvironmentToIdentity {
		edges = append(edges, environment.EdgeEnvironmentToIdentity)
	}
	if m.cleared_EnvironmentToCommand {
		edges = append(edges, environment.EdgeEnvironmentToCommand)
	}
	if m.cleared_EnvironmentToScript {
		edges = append(edges, environment.EdgeEnvironmentToScript)
	}
	if m.cleared_EnvironmentToFileDownload {
		edges = append(edges, environment.EdgeEnvironmentToFileDownload)
	}
	if m.cleared_EnvironmentToFileDelete {
		edges = append(edges, environment.EdgeEnvironmentToFileDelete)
	}
	if m.cleared_EnvironmentToFileExtract {
		edges = append(edges, environment.EdgeEnvironmentToFileExtract)
	}
	if m.cleared_EnvironmentToIncludedNetwork {
		edges = append(edges, environment.EdgeEnvironmentToIncludedNetwork)
	}
	if m.cleared_EnvironmentToFinding {
		edges = append(edges, environment.EdgeEnvironmentToFinding)
	}
	if m.cleared_EnvironmentToDNSRecord {
		edges = append(edges, environment.EdgeEnvironmentToDNSRecord)
	}
	if m.cleared_EnvironmentToNetwork {
		edges = append(edges, environment.EdgeEnvironmentToNetwork)
	}
	if m.cleared_EnvironmentToHostDependency {
		edges = append(edges, environment.EdgeEnvironmentToHostDependency)
	}
	if m.cleared_EnvironmentToTeam {
		edges = append(edges, environment.EdgeEnvironmentToTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeEnvironmentToTag:
		return m.cleared_EnvironmentToTag
	case environment.EdgeEnvironmentToUser:
		return m.cleared_EnvironmentToUser
	case environment.EdgeEnvironmentToHost:
		return m.cleared_EnvironmentToHost
	case environment.EdgeEnvironmentToCompetition:
		return m.cleared_EnvironmentToCompetition
	case environment.EdgeEnvironmentToBuild:
		return m.cleared_EnvironmentToBuild
	case environment.EdgeEnvironmentToIdentity:
		return m.cleared_EnvironmentToIdentity
	case environment.EdgeEnvironmentToCommand:
		return m.cleared_EnvironmentToCommand
	case environment.EdgeEnvironmentToScript:
		return m.cleared_EnvironmentToScript
	case environment.EdgeEnvironmentToFileDownload:
		return m.cleared_EnvironmentToFileDownload
	case environment.EdgeEnvironmentToFileDelete:
		return m.cleared_EnvironmentToFileDelete
	case environment.EdgeEnvironmentToFileExtract:
		return m.cleared_EnvironmentToFileExtract
	case environment.EdgeEnvironmentToIncludedNetwork:
		return m.cleared_EnvironmentToIncludedNetwork
	case environment.EdgeEnvironmentToFinding:
		return m.cleared_EnvironmentToFinding
	case environment.EdgeEnvironmentToDNSRecord:
		return m.cleared_EnvironmentToDNSRecord
	case environment.EdgeEnvironmentToNetwork:
		return m.cleared_EnvironmentToNetwork
	case environment.EdgeEnvironmentToHostDependency:
		return m.cleared_EnvironmentToHostDependency
	case environment.EdgeEnvironmentToTeam:
		return m.cleared_EnvironmentToTeam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeEnvironmentToTag:
		m.ResetEnvironmentToTag()
		return nil
	case environment.EdgeEnvironmentToUser:
		m.ResetEnvironmentToUser()
		return nil
	case environment.EdgeEnvironmentToHost:
		m.ResetEnvironmentToHost()
		return nil
	case environment.EdgeEnvironmentToCompetition:
		m.ResetEnvironmentToCompetition()
		return nil
	case environment.EdgeEnvironmentToBuild:
		m.ResetEnvironmentToBuild()
		return nil
	case environment.EdgeEnvironmentToIdentity:
		m.ResetEnvironmentToIdentity()
		return nil
	case environment.EdgeEnvironmentToCommand:
		m.ResetEnvironmentToCommand()
		return nil
	case environment.EdgeEnvironmentToScript:
		m.ResetEnvironmentToScript()
		return nil
	case environment.EdgeEnvironmentToFileDownload:
		m.ResetEnvironmentToFileDownload()
		return nil
	case environment.EdgeEnvironmentToFileDelete:
		m.ResetEnvironmentToFileDelete()
		return nil
	case environment.EdgeEnvironmentToFileExtract:
		m.ResetEnvironmentToFileExtract()
		return nil
	case environment.EdgeEnvironmentToIncludedNetwork:
		m.ResetEnvironmentToIncludedNetwork()
		return nil
	case environment.EdgeEnvironmentToFinding:
		m.ResetEnvironmentToFinding()
		return nil
	case environment.EdgeEnvironmentToDNSRecord:
		m.ResetEnvironmentToDNSRecord()
		return nil
	case environment.EdgeEnvironmentToNetwork:
		m.ResetEnvironmentToNetwork()
		return nil
	case environment.EdgeEnvironmentToHostDependency:
		m.ResetEnvironmentToHostDependency()
		return nil
	case environment.EdgeEnvironmentToTeam:
		m.ResetEnvironmentToTeam()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// FileDeleteMutation represents an operation that mutates the FileDelete nodes in the graph.
type FileDeleteMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	hcl_id                          *string
	_path                           *string
	tags                            *map[string]string
	clearedFields                   map[string]struct{}
	_FileDeleteToTag                map[int]struct{}
	removed_FileDeleteToTag         map[int]struct{}
	cleared_FileDeleteToTag         bool
	_FileDeleteToEnvironment        map[int]struct{}
	removed_FileDeleteToEnvironment map[int]struct{}
	cleared_FileDeleteToEnvironment bool
	done                            bool
	oldValue                        func(context.Context) (*FileDelete, error)
	predicates                      []predicate.FileDelete
}

var _ ent.Mutation = (*FileDeleteMutation)(nil)

// filedeleteOption allows management of the mutation configuration using functional options.
type filedeleteOption func(*FileDeleteMutation)

// newFileDeleteMutation creates new mutation for the FileDelete entity.
func newFileDeleteMutation(c config, op Op, opts ...filedeleteOption) *FileDeleteMutation {
	m := &FileDeleteMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDelete,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDeleteID sets the ID field of the mutation.
func withFileDeleteID(id int) filedeleteOption {
	return func(m *FileDeleteMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDelete
		)
		m.oldValue = func(ctx context.Context) (*FileDelete, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDelete.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDelete sets the old FileDelete of the mutation.
func withFileDelete(node *FileDelete) filedeleteOption {
	return func(m *FileDeleteMutation) {
		m.oldValue = func(context.Context) (*FileDelete, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDeleteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDeleteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FileDeleteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *FileDeleteMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *FileDeleteMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *FileDeleteMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetPath sets the "path" field.
func (m *FileDeleteMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileDeleteMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileDeleteMutation) ResetPath() {
	m._path = nil
}

// SetTags sets the "tags" field.
func (m *FileDeleteMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileDeleteMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileDeleteMutation) ResetTags() {
	m.tags = nil
}

// AddFileDeleteToTagIDs adds the "FileDeleteToTag" edge to the Tag entity by ids.
func (m *FileDeleteMutation) AddFileDeleteToTagIDs(ids ...int) {
	if m._FileDeleteToTag == nil {
		m._FileDeleteToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._FileDeleteToTag[ids[i]] = struct{}{}
	}
}

// ClearFileDeleteToTag clears the "FileDeleteToTag" edge to the Tag entity.
func (m *FileDeleteMutation) ClearFileDeleteToTag() {
	m.cleared_FileDeleteToTag = true
}

// FileDeleteToTagCleared returns if the "FileDeleteToTag" edge to the Tag entity was cleared.
func (m *FileDeleteMutation) FileDeleteToTagCleared() bool {
	return m.cleared_FileDeleteToTag
}

// RemoveFileDeleteToTagIDs removes the "FileDeleteToTag" edge to the Tag entity by IDs.
func (m *FileDeleteMutation) RemoveFileDeleteToTagIDs(ids ...int) {
	if m.removed_FileDeleteToTag == nil {
		m.removed_FileDeleteToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FileDeleteToTag[ids[i]] = struct{}{}
	}
}

// RemovedFileDeleteToTag returns the removed IDs of the "FileDeleteToTag" edge to the Tag entity.
func (m *FileDeleteMutation) RemovedFileDeleteToTagIDs() (ids []int) {
	for id := range m.removed_FileDeleteToTag {
		ids = append(ids, id)
	}
	return
}

// FileDeleteToTagIDs returns the "FileDeleteToTag" edge IDs in the mutation.
func (m *FileDeleteMutation) FileDeleteToTagIDs() (ids []int) {
	for id := range m._FileDeleteToTag {
		ids = append(ids, id)
	}
	return
}

// ResetFileDeleteToTag resets all changes to the "FileDeleteToTag" edge.
func (m *FileDeleteMutation) ResetFileDeleteToTag() {
	m._FileDeleteToTag = nil
	m.cleared_FileDeleteToTag = false
	m.removed_FileDeleteToTag = nil
}

// AddFileDeleteToEnvironmentIDs adds the "FileDeleteToEnvironment" edge to the Environment entity by ids.
func (m *FileDeleteMutation) AddFileDeleteToEnvironmentIDs(ids ...int) {
	if m._FileDeleteToEnvironment == nil {
		m._FileDeleteToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._FileDeleteToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearFileDeleteToEnvironment clears the "FileDeleteToEnvironment" edge to the Environment entity.
func (m *FileDeleteMutation) ClearFileDeleteToEnvironment() {
	m.cleared_FileDeleteToEnvironment = true
}

// FileDeleteToEnvironmentCleared returns if the "FileDeleteToEnvironment" edge to the Environment entity was cleared.
func (m *FileDeleteMutation) FileDeleteToEnvironmentCleared() bool {
	return m.cleared_FileDeleteToEnvironment
}

// RemoveFileDeleteToEnvironmentIDs removes the "FileDeleteToEnvironment" edge to the Environment entity by IDs.
func (m *FileDeleteMutation) RemoveFileDeleteToEnvironmentIDs(ids ...int) {
	if m.removed_FileDeleteToEnvironment == nil {
		m.removed_FileDeleteToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FileDeleteToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedFileDeleteToEnvironment returns the removed IDs of the "FileDeleteToEnvironment" edge to the Environment entity.
func (m *FileDeleteMutation) RemovedFileDeleteToEnvironmentIDs() (ids []int) {
	for id := range m.removed_FileDeleteToEnvironment {
		ids = append(ids, id)
	}
	return
}

// FileDeleteToEnvironmentIDs returns the "FileDeleteToEnvironment" edge IDs in the mutation.
func (m *FileDeleteMutation) FileDeleteToEnvironmentIDs() (ids []int) {
	for id := range m._FileDeleteToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetFileDeleteToEnvironment resets all changes to the "FileDeleteToEnvironment" edge.
func (m *FileDeleteMutation) ResetFileDeleteToEnvironment() {
	m._FileDeleteToEnvironment = nil
	m.cleared_FileDeleteToEnvironment = false
	m.removed_FileDeleteToEnvironment = nil
}

// Op returns the operation name.
func (m *FileDeleteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileDelete).
func (m *FileDeleteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileDeleteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.hcl_id != nil {
		fields = append(fields, filedelete.FieldHclID)
	}
	if m._path != nil {
		fields = append(fields, filedelete.FieldPath)
	}
	if m.tags != nil {
		fields = append(fields, filedelete.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileDeleteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedelete.FieldHclID:
		return m.HclID()
	case filedelete.FieldPath:
		return m.Path()
	case filedelete.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileDeleteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedelete.FieldHclID:
		return m.OldHclID(ctx)
	case filedelete.FieldPath:
		return m.OldPath(ctx)
	case filedelete.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileDelete field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDeleteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedelete.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case filedelete.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case filedelete.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileDeleteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileDeleteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDeleteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDelete numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileDeleteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileDeleteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDeleteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDelete nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileDeleteMutation) ResetField(name string) error {
	switch name {
	case filedelete.FieldHclID:
		m.ResetHclID()
		return nil
	case filedelete.FieldPath:
		m.ResetPath()
		return nil
	case filedelete.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileDeleteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._FileDeleteToTag != nil {
		edges = append(edges, filedelete.EdgeFileDeleteToTag)
	}
	if m._FileDeleteToEnvironment != nil {
		edges = append(edges, filedelete.EdgeFileDeleteToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileDeleteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedelete.EdgeFileDeleteToTag:
		ids := make([]ent.Value, 0, len(m._FileDeleteToTag))
		for id := range m._FileDeleteToTag {
			ids = append(ids, id)
		}
		return ids
	case filedelete.EdgeFileDeleteToEnvironment:
		ids := make([]ent.Value, 0, len(m._FileDeleteToEnvironment))
		for id := range m._FileDeleteToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileDeleteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_FileDeleteToTag != nil {
		edges = append(edges, filedelete.EdgeFileDeleteToTag)
	}
	if m.removed_FileDeleteToEnvironment != nil {
		edges = append(edges, filedelete.EdgeFileDeleteToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileDeleteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filedelete.EdgeFileDeleteToTag:
		ids := make([]ent.Value, 0, len(m.removed_FileDeleteToTag))
		for id := range m.removed_FileDeleteToTag {
			ids = append(ids, id)
		}
		return ids
	case filedelete.EdgeFileDeleteToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_FileDeleteToEnvironment))
		for id := range m.removed_FileDeleteToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileDeleteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_FileDeleteToTag {
		edges = append(edges, filedelete.EdgeFileDeleteToTag)
	}
	if m.cleared_FileDeleteToEnvironment {
		edges = append(edges, filedelete.EdgeFileDeleteToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileDeleteMutation) EdgeCleared(name string) bool {
	switch name {
	case filedelete.EdgeFileDeleteToTag:
		return m.cleared_FileDeleteToTag
	case filedelete.EdgeFileDeleteToEnvironment:
		return m.cleared_FileDeleteToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileDeleteMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDelete unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileDeleteMutation) ResetEdge(name string) error {
	switch name {
	case filedelete.EdgeFileDeleteToTag:
		m.ResetFileDeleteToTag()
		return nil
	case filedelete.EdgeFileDeleteToEnvironment:
		m.ResetFileDeleteToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDelete edge %s", name)
}

// FileDownloadMutation represents an operation that mutates the FileDownload nodes in the graph.
type FileDownloadMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	hcl_id                            *string
	source_type                       *string
	source                            *string
	destination                       *string
	template                          *bool
	perms                             *string
	disabled                          *bool
	md5                               *string
	abs_path                          *string
	tags                              *map[string]string
	clearedFields                     map[string]struct{}
	_FileDownloadToTag                map[int]struct{}
	removed_FileDownloadToTag         map[int]struct{}
	cleared_FileDownloadToTag         bool
	_FileDownloadToEnvironment        map[int]struct{}
	removed_FileDownloadToEnvironment map[int]struct{}
	cleared_FileDownloadToEnvironment bool
	done                              bool
	oldValue                          func(context.Context) (*FileDownload, error)
	predicates                        []predicate.FileDownload
}

var _ ent.Mutation = (*FileDownloadMutation)(nil)

// filedownloadOption allows management of the mutation configuration using functional options.
type filedownloadOption func(*FileDownloadMutation)

// newFileDownloadMutation creates new mutation for the FileDownload entity.
func newFileDownloadMutation(c config, op Op, opts ...filedownloadOption) *FileDownloadMutation {
	m := &FileDownloadMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDownload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDownloadID sets the ID field of the mutation.
func withFileDownloadID(id int) filedownloadOption {
	return func(m *FileDownloadMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDownload
		)
		m.oldValue = func(ctx context.Context) (*FileDownload, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDownload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDownload sets the old FileDownload of the mutation.
func withFileDownload(node *FileDownload) filedownloadOption {
	return func(m *FileDownloadMutation) {
		m.oldValue = func(context.Context) (*FileDownload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDownloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDownloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FileDownloadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *FileDownloadMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *FileDownloadMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *FileDownloadMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetSourceType sets the "source_type" field.
func (m *FileDownloadMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *FileDownloadMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *FileDownloadMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSource sets the "source" field.
func (m *FileDownloadMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileDownloadMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileDownloadMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the "destination" field.
func (m *FileDownloadMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *FileDownloadMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *FileDownloadMutation) ResetDestination() {
	m.destination = nil
}

// SetTemplate sets the "template" field.
func (m *FileDownloadMutation) SetTemplate(b bool) {
	m.template = &b
}

// Template returns the value of the "template" field in the mutation.
func (m *FileDownloadMutation) Template() (r bool, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *FileDownloadMutation) ResetTemplate() {
	m.template = nil
}

// SetPerms sets the "perms" field.
func (m *FileDownloadMutation) SetPerms(s string) {
	m.perms = &s
}

// Perms returns the value of the "perms" field in the mutation.
func (m *FileDownloadMutation) Perms() (r string, exists bool) {
	v := m.perms
	if v == nil {
		return
	}
	return *v, true
}

// OldPerms returns the old "perms" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldPerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerms: %w", err)
	}
	return oldValue.Perms, nil
}

// ResetPerms resets all changes to the "perms" field.
func (m *FileDownloadMutation) ResetPerms() {
	m.perms = nil
}

// SetDisabled sets the "disabled" field.
func (m *FileDownloadMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *FileDownloadMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *FileDownloadMutation) ResetDisabled() {
	m.disabled = nil
}

// SetMd5 sets the "md5" field.
func (m *FileDownloadMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileDownloadMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileDownloadMutation) ResetMd5() {
	m.md5 = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *FileDownloadMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *FileDownloadMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *FileDownloadMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetTags sets the "tags" field.
func (m *FileDownloadMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileDownloadMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileDownloadMutation) ResetTags() {
	m.tags = nil
}

// AddFileDownloadToTagIDs adds the "FileDownloadToTag" edge to the Tag entity by ids.
func (m *FileDownloadMutation) AddFileDownloadToTagIDs(ids ...int) {
	if m._FileDownloadToTag == nil {
		m._FileDownloadToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._FileDownloadToTag[ids[i]] = struct{}{}
	}
}

// ClearFileDownloadToTag clears the "FileDownloadToTag" edge to the Tag entity.
func (m *FileDownloadMutation) ClearFileDownloadToTag() {
	m.cleared_FileDownloadToTag = true
}

// FileDownloadToTagCleared returns if the "FileDownloadToTag" edge to the Tag entity was cleared.
func (m *FileDownloadMutation) FileDownloadToTagCleared() bool {
	return m.cleared_FileDownloadToTag
}

// RemoveFileDownloadToTagIDs removes the "FileDownloadToTag" edge to the Tag entity by IDs.
func (m *FileDownloadMutation) RemoveFileDownloadToTagIDs(ids ...int) {
	if m.removed_FileDownloadToTag == nil {
		m.removed_FileDownloadToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FileDownloadToTag[ids[i]] = struct{}{}
	}
}

// RemovedFileDownloadToTag returns the removed IDs of the "FileDownloadToTag" edge to the Tag entity.
func (m *FileDownloadMutation) RemovedFileDownloadToTagIDs() (ids []int) {
	for id := range m.removed_FileDownloadToTag {
		ids = append(ids, id)
	}
	return
}

// FileDownloadToTagIDs returns the "FileDownloadToTag" edge IDs in the mutation.
func (m *FileDownloadMutation) FileDownloadToTagIDs() (ids []int) {
	for id := range m._FileDownloadToTag {
		ids = append(ids, id)
	}
	return
}

// ResetFileDownloadToTag resets all changes to the "FileDownloadToTag" edge.
func (m *FileDownloadMutation) ResetFileDownloadToTag() {
	m._FileDownloadToTag = nil
	m.cleared_FileDownloadToTag = false
	m.removed_FileDownloadToTag = nil
}

// AddFileDownloadToEnvironmentIDs adds the "FileDownloadToEnvironment" edge to the Environment entity by ids.
func (m *FileDownloadMutation) AddFileDownloadToEnvironmentIDs(ids ...int) {
	if m._FileDownloadToEnvironment == nil {
		m._FileDownloadToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._FileDownloadToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearFileDownloadToEnvironment clears the "FileDownloadToEnvironment" edge to the Environment entity.
func (m *FileDownloadMutation) ClearFileDownloadToEnvironment() {
	m.cleared_FileDownloadToEnvironment = true
}

// FileDownloadToEnvironmentCleared returns if the "FileDownloadToEnvironment" edge to the Environment entity was cleared.
func (m *FileDownloadMutation) FileDownloadToEnvironmentCleared() bool {
	return m.cleared_FileDownloadToEnvironment
}

// RemoveFileDownloadToEnvironmentIDs removes the "FileDownloadToEnvironment" edge to the Environment entity by IDs.
func (m *FileDownloadMutation) RemoveFileDownloadToEnvironmentIDs(ids ...int) {
	if m.removed_FileDownloadToEnvironment == nil {
		m.removed_FileDownloadToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FileDownloadToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedFileDownloadToEnvironment returns the removed IDs of the "FileDownloadToEnvironment" edge to the Environment entity.
func (m *FileDownloadMutation) RemovedFileDownloadToEnvironmentIDs() (ids []int) {
	for id := range m.removed_FileDownloadToEnvironment {
		ids = append(ids, id)
	}
	return
}

// FileDownloadToEnvironmentIDs returns the "FileDownloadToEnvironment" edge IDs in the mutation.
func (m *FileDownloadMutation) FileDownloadToEnvironmentIDs() (ids []int) {
	for id := range m._FileDownloadToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetFileDownloadToEnvironment resets all changes to the "FileDownloadToEnvironment" edge.
func (m *FileDownloadMutation) ResetFileDownloadToEnvironment() {
	m._FileDownloadToEnvironment = nil
	m.cleared_FileDownloadToEnvironment = false
	m.removed_FileDownloadToEnvironment = nil
}

// Op returns the operation name.
func (m *FileDownloadMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileDownload).
func (m *FileDownloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileDownloadMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.hcl_id != nil {
		fields = append(fields, filedownload.FieldHclID)
	}
	if m.source_type != nil {
		fields = append(fields, filedownload.FieldSourceType)
	}
	if m.source != nil {
		fields = append(fields, filedownload.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, filedownload.FieldDestination)
	}
	if m.template != nil {
		fields = append(fields, filedownload.FieldTemplate)
	}
	if m.perms != nil {
		fields = append(fields, filedownload.FieldPerms)
	}
	if m.disabled != nil {
		fields = append(fields, filedownload.FieldDisabled)
	}
	if m.md5 != nil {
		fields = append(fields, filedownload.FieldMd5)
	}
	if m.abs_path != nil {
		fields = append(fields, filedownload.FieldAbsPath)
	}
	if m.tags != nil {
		fields = append(fields, filedownload.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileDownloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedownload.FieldHclID:
		return m.HclID()
	case filedownload.FieldSourceType:
		return m.SourceType()
	case filedownload.FieldSource:
		return m.Source()
	case filedownload.FieldDestination:
		return m.Destination()
	case filedownload.FieldTemplate:
		return m.Template()
	case filedownload.FieldPerms:
		return m.Perms()
	case filedownload.FieldDisabled:
		return m.Disabled()
	case filedownload.FieldMd5:
		return m.Md5()
	case filedownload.FieldAbsPath:
		return m.AbsPath()
	case filedownload.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileDownloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedownload.FieldHclID:
		return m.OldHclID(ctx)
	case filedownload.FieldSourceType:
		return m.OldSourceType(ctx)
	case filedownload.FieldSource:
		return m.OldSource(ctx)
	case filedownload.FieldDestination:
		return m.OldDestination(ctx)
	case filedownload.FieldTemplate:
		return m.OldTemplate(ctx)
	case filedownload.FieldPerms:
		return m.OldPerms(ctx)
	case filedownload.FieldDisabled:
		return m.OldDisabled(ctx)
	case filedownload.FieldMd5:
		return m.OldMd5(ctx)
	case filedownload.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case filedownload.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileDownload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDownloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedownload.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case filedownload.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case filedownload.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case filedownload.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case filedownload.FieldTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case filedownload.FieldPerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerms(v)
		return nil
	case filedownload.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case filedownload.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case filedownload.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case filedownload.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileDownloadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileDownloadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDownloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDownload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileDownloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileDownloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDownloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDownload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileDownloadMutation) ResetField(name string) error {
	switch name {
	case filedownload.FieldHclID:
		m.ResetHclID()
		return nil
	case filedownload.FieldSourceType:
		m.ResetSourceType()
		return nil
	case filedownload.FieldSource:
		m.ResetSource()
		return nil
	case filedownload.FieldDestination:
		m.ResetDestination()
		return nil
	case filedownload.FieldTemplate:
		m.ResetTemplate()
		return nil
	case filedownload.FieldPerms:
		m.ResetPerms()
		return nil
	case filedownload.FieldDisabled:
		m.ResetDisabled()
		return nil
	case filedownload.FieldMd5:
		m.ResetMd5()
		return nil
	case filedownload.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case filedownload.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileDownloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._FileDownloadToTag != nil {
		edges = append(edges, filedownload.EdgeFileDownloadToTag)
	}
	if m._FileDownloadToEnvironment != nil {
		edges = append(edges, filedownload.EdgeFileDownloadToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileDownloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedownload.EdgeFileDownloadToTag:
		ids := make([]ent.Value, 0, len(m._FileDownloadToTag))
		for id := range m._FileDownloadToTag {
			ids = append(ids, id)
		}
		return ids
	case filedownload.EdgeFileDownloadToEnvironment:
		ids := make([]ent.Value, 0, len(m._FileDownloadToEnvironment))
		for id := range m._FileDownloadToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileDownloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_FileDownloadToTag != nil {
		edges = append(edges, filedownload.EdgeFileDownloadToTag)
	}
	if m.removed_FileDownloadToEnvironment != nil {
		edges = append(edges, filedownload.EdgeFileDownloadToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileDownloadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filedownload.EdgeFileDownloadToTag:
		ids := make([]ent.Value, 0, len(m.removed_FileDownloadToTag))
		for id := range m.removed_FileDownloadToTag {
			ids = append(ids, id)
		}
		return ids
	case filedownload.EdgeFileDownloadToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_FileDownloadToEnvironment))
		for id := range m.removed_FileDownloadToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileDownloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_FileDownloadToTag {
		edges = append(edges, filedownload.EdgeFileDownloadToTag)
	}
	if m.cleared_FileDownloadToEnvironment {
		edges = append(edges, filedownload.EdgeFileDownloadToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileDownloadMutation) EdgeCleared(name string) bool {
	switch name {
	case filedownload.EdgeFileDownloadToTag:
		return m.cleared_FileDownloadToTag
	case filedownload.EdgeFileDownloadToEnvironment:
		return m.cleared_FileDownloadToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileDownloadMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDownload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileDownloadMutation) ResetEdge(name string) error {
	switch name {
	case filedownload.EdgeFileDownloadToTag:
		m.ResetFileDownloadToTag()
		return nil
	case filedownload.EdgeFileDownloadToEnvironment:
		m.ResetFileDownloadToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDownload edge %s", name)
}

// FileExtractMutation represents an operation that mutates the FileExtract nodes in the graph.
type FileExtractMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	hcl_id                           *string
	source                           *string
	destination                      *string
	_type                            *string
	tags                             *map[string]string
	clearedFields                    map[string]struct{}
	_FileExtractToTag                map[int]struct{}
	removed_FileExtractToTag         map[int]struct{}
	cleared_FileExtractToTag         bool
	_FileExtractToEnvironment        map[int]struct{}
	removed_FileExtractToEnvironment map[int]struct{}
	cleared_FileExtractToEnvironment bool
	done                             bool
	oldValue                         func(context.Context) (*FileExtract, error)
	predicates                       []predicate.FileExtract
}

var _ ent.Mutation = (*FileExtractMutation)(nil)

// fileextractOption allows management of the mutation configuration using functional options.
type fileextractOption func(*FileExtractMutation)

// newFileExtractMutation creates new mutation for the FileExtract entity.
func newFileExtractMutation(c config, op Op, opts ...fileextractOption) *FileExtractMutation {
	m := &FileExtractMutation{
		config:        c,
		op:            op,
		typ:           TypeFileExtract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileExtractID sets the ID field of the mutation.
func withFileExtractID(id int) fileextractOption {
	return func(m *FileExtractMutation) {
		var (
			err   error
			once  sync.Once
			value *FileExtract
		)
		m.oldValue = func(ctx context.Context) (*FileExtract, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileExtract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileExtract sets the old FileExtract of the mutation.
func withFileExtract(node *FileExtract) fileextractOption {
	return func(m *FileExtractMutation) {
		m.oldValue = func(context.Context) (*FileExtract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileExtractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileExtractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FileExtractMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *FileExtractMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *FileExtractMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *FileExtractMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetSource sets the "source" field.
func (m *FileExtractMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileExtractMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileExtractMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the "destination" field.
func (m *FileExtractMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *FileExtractMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *FileExtractMutation) ResetDestination() {
	m.destination = nil
}

// SetType sets the "type" field.
func (m *FileExtractMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileExtractMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileExtractMutation) ResetType() {
	m._type = nil
}

// SetTags sets the "tags" field.
func (m *FileExtractMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileExtractMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileExtractMutation) ResetTags() {
	m.tags = nil
}

// AddFileExtractToTagIDs adds the "FileExtractToTag" edge to the Tag entity by ids.
func (m *FileExtractMutation) AddFileExtractToTagIDs(ids ...int) {
	if m._FileExtractToTag == nil {
		m._FileExtractToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._FileExtractToTag[ids[i]] = struct{}{}
	}
}

// ClearFileExtractToTag clears the "FileExtractToTag" edge to the Tag entity.
func (m *FileExtractMutation) ClearFileExtractToTag() {
	m.cleared_FileExtractToTag = true
}

// FileExtractToTagCleared returns if the "FileExtractToTag" edge to the Tag entity was cleared.
func (m *FileExtractMutation) FileExtractToTagCleared() bool {
	return m.cleared_FileExtractToTag
}

// RemoveFileExtractToTagIDs removes the "FileExtractToTag" edge to the Tag entity by IDs.
func (m *FileExtractMutation) RemoveFileExtractToTagIDs(ids ...int) {
	if m.removed_FileExtractToTag == nil {
		m.removed_FileExtractToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FileExtractToTag[ids[i]] = struct{}{}
	}
}

// RemovedFileExtractToTag returns the removed IDs of the "FileExtractToTag" edge to the Tag entity.
func (m *FileExtractMutation) RemovedFileExtractToTagIDs() (ids []int) {
	for id := range m.removed_FileExtractToTag {
		ids = append(ids, id)
	}
	return
}

// FileExtractToTagIDs returns the "FileExtractToTag" edge IDs in the mutation.
func (m *FileExtractMutation) FileExtractToTagIDs() (ids []int) {
	for id := range m._FileExtractToTag {
		ids = append(ids, id)
	}
	return
}

// ResetFileExtractToTag resets all changes to the "FileExtractToTag" edge.
func (m *FileExtractMutation) ResetFileExtractToTag() {
	m._FileExtractToTag = nil
	m.cleared_FileExtractToTag = false
	m.removed_FileExtractToTag = nil
}

// AddFileExtractToEnvironmentIDs adds the "FileExtractToEnvironment" edge to the Environment entity by ids.
func (m *FileExtractMutation) AddFileExtractToEnvironmentIDs(ids ...int) {
	if m._FileExtractToEnvironment == nil {
		m._FileExtractToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._FileExtractToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearFileExtractToEnvironment clears the "FileExtractToEnvironment" edge to the Environment entity.
func (m *FileExtractMutation) ClearFileExtractToEnvironment() {
	m.cleared_FileExtractToEnvironment = true
}

// FileExtractToEnvironmentCleared returns if the "FileExtractToEnvironment" edge to the Environment entity was cleared.
func (m *FileExtractMutation) FileExtractToEnvironmentCleared() bool {
	return m.cleared_FileExtractToEnvironment
}

// RemoveFileExtractToEnvironmentIDs removes the "FileExtractToEnvironment" edge to the Environment entity by IDs.
func (m *FileExtractMutation) RemoveFileExtractToEnvironmentIDs(ids ...int) {
	if m.removed_FileExtractToEnvironment == nil {
		m.removed_FileExtractToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FileExtractToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedFileExtractToEnvironment returns the removed IDs of the "FileExtractToEnvironment" edge to the Environment entity.
func (m *FileExtractMutation) RemovedFileExtractToEnvironmentIDs() (ids []int) {
	for id := range m.removed_FileExtractToEnvironment {
		ids = append(ids, id)
	}
	return
}

// FileExtractToEnvironmentIDs returns the "FileExtractToEnvironment" edge IDs in the mutation.
func (m *FileExtractMutation) FileExtractToEnvironmentIDs() (ids []int) {
	for id := range m._FileExtractToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetFileExtractToEnvironment resets all changes to the "FileExtractToEnvironment" edge.
func (m *FileExtractMutation) ResetFileExtractToEnvironment() {
	m._FileExtractToEnvironment = nil
	m.cleared_FileExtractToEnvironment = false
	m.removed_FileExtractToEnvironment = nil
}

// Op returns the operation name.
func (m *FileExtractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileExtract).
func (m *FileExtractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileExtractMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.hcl_id != nil {
		fields = append(fields, fileextract.FieldHclID)
	}
	if m.source != nil {
		fields = append(fields, fileextract.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, fileextract.FieldDestination)
	}
	if m._type != nil {
		fields = append(fields, fileextract.FieldType)
	}
	if m.tags != nil {
		fields = append(fields, fileextract.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileExtractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileextract.FieldHclID:
		return m.HclID()
	case fileextract.FieldSource:
		return m.Source()
	case fileextract.FieldDestination:
		return m.Destination()
	case fileextract.FieldType:
		return m.GetType()
	case fileextract.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileExtractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileextract.FieldHclID:
		return m.OldHclID(ctx)
	case fileextract.FieldSource:
		return m.OldSource(ctx)
	case fileextract.FieldDestination:
		return m.OldDestination(ctx)
	case fileextract.FieldType:
		return m.OldType(ctx)
	case fileextract.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileExtract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileExtractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileextract.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case fileextract.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case fileextract.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case fileextract.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case fileextract.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileExtractMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileExtractMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileExtractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileExtract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileExtractMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileExtractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileExtractMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileExtract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileExtractMutation) ResetField(name string) error {
	switch name {
	case fileextract.FieldHclID:
		m.ResetHclID()
		return nil
	case fileextract.FieldSource:
		m.ResetSource()
		return nil
	case fileextract.FieldDestination:
		m.ResetDestination()
		return nil
	case fileextract.FieldType:
		m.ResetType()
		return nil
	case fileextract.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileExtractMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._FileExtractToTag != nil {
		edges = append(edges, fileextract.EdgeFileExtractToTag)
	}
	if m._FileExtractToEnvironment != nil {
		edges = append(edges, fileextract.EdgeFileExtractToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileExtractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileextract.EdgeFileExtractToTag:
		ids := make([]ent.Value, 0, len(m._FileExtractToTag))
		for id := range m._FileExtractToTag {
			ids = append(ids, id)
		}
		return ids
	case fileextract.EdgeFileExtractToEnvironment:
		ids := make([]ent.Value, 0, len(m._FileExtractToEnvironment))
		for id := range m._FileExtractToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileExtractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_FileExtractToTag != nil {
		edges = append(edges, fileextract.EdgeFileExtractToTag)
	}
	if m.removed_FileExtractToEnvironment != nil {
		edges = append(edges, fileextract.EdgeFileExtractToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileExtractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fileextract.EdgeFileExtractToTag:
		ids := make([]ent.Value, 0, len(m.removed_FileExtractToTag))
		for id := range m.removed_FileExtractToTag {
			ids = append(ids, id)
		}
		return ids
	case fileextract.EdgeFileExtractToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_FileExtractToEnvironment))
		for id := range m.removed_FileExtractToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileExtractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_FileExtractToTag {
		edges = append(edges, fileextract.EdgeFileExtractToTag)
	}
	if m.cleared_FileExtractToEnvironment {
		edges = append(edges, fileextract.EdgeFileExtractToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileExtractMutation) EdgeCleared(name string) bool {
	switch name {
	case fileextract.EdgeFileExtractToTag:
		return m.cleared_FileExtractToTag
	case fileextract.EdgeFileExtractToEnvironment:
		return m.cleared_FileExtractToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileExtractMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileExtract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileExtractMutation) ResetEdge(name string) error {
	switch name {
	case fileextract.EdgeFileExtractToTag:
		m.ResetFileExtractToTag()
		return nil
	case fileextract.EdgeFileExtractToEnvironment:
		m.ResetFileExtractToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileExtract edge %s", name)
}

// FindingMutation represents an operation that mutates the Finding nodes in the graph.
type FindingMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	description                  *string
	severity                     *finding.Severity
	difficulty                   *finding.Difficulty
	tags                         *map[string]string
	clearedFields                map[string]struct{}
	_FindingToUser               map[int]struct{}
	removed_FindingToUser        map[int]struct{}
	cleared_FindingToUser        bool
	_FindingToTag                map[int]struct{}
	removed_FindingToTag         map[int]struct{}
	cleared_FindingToTag         bool
	_FindingToHost               map[int]struct{}
	removed_FindingToHost        map[int]struct{}
	cleared_FindingToHost        bool
	_FindingToScript             map[int]struct{}
	removed_FindingToScript      map[int]struct{}
	cleared_FindingToScript      bool
	_FindingToEnvironment        map[int]struct{}
	removed_FindingToEnvironment map[int]struct{}
	cleared_FindingToEnvironment bool
	done                         bool
	oldValue                     func(context.Context) (*Finding, error)
	predicates                   []predicate.Finding
}

var _ ent.Mutation = (*FindingMutation)(nil)

// findingOption allows management of the mutation configuration using functional options.
type findingOption func(*FindingMutation)

// newFindingMutation creates new mutation for the Finding entity.
func newFindingMutation(c config, op Op, opts ...findingOption) *FindingMutation {
	m := &FindingMutation{
		config:        c,
		op:            op,
		typ:           TypeFinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFindingID sets the ID field of the mutation.
func withFindingID(id int) findingOption {
	return func(m *FindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Finding
		)
		m.oldValue = func(ctx context.Context) (*Finding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Finding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinding sets the old Finding of the mutation.
func withFinding(node *Finding) findingOption {
	return func(m *FindingMutation) {
		m.oldValue = func(context.Context) (*Finding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FindingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *FindingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FindingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FindingMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FindingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FindingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FindingMutation) ResetDescription() {
	m.description = nil
}

// SetSeverity sets the "severity" field.
func (m *FindingMutation) SetSeverity(f finding.Severity) {
	m.severity = &f
}

// Severity returns the value of the "severity" field in the mutation.
func (m *FindingMutation) Severity() (r finding.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldSeverity(ctx context.Context) (v finding.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *FindingMutation) ResetSeverity() {
	m.severity = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *FindingMutation) SetDifficulty(f finding.Difficulty) {
	m.difficulty = &f
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *FindingMutation) Difficulty() (r finding.Difficulty, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldDifficulty(ctx context.Context) (v finding.Difficulty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *FindingMutation) ResetDifficulty() {
	m.difficulty = nil
}

// SetTags sets the "tags" field.
func (m *FindingMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FindingMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FindingMutation) ResetTags() {
	m.tags = nil
}

// AddFindingToUserIDs adds the "FindingToUser" edge to the User entity by ids.
func (m *FindingMutation) AddFindingToUserIDs(ids ...int) {
	if m._FindingToUser == nil {
		m._FindingToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._FindingToUser[ids[i]] = struct{}{}
	}
}

// ClearFindingToUser clears the "FindingToUser" edge to the User entity.
func (m *FindingMutation) ClearFindingToUser() {
	m.cleared_FindingToUser = true
}

// FindingToUserCleared returns if the "FindingToUser" edge to the User entity was cleared.
func (m *FindingMutation) FindingToUserCleared() bool {
	return m.cleared_FindingToUser
}

// RemoveFindingToUserIDs removes the "FindingToUser" edge to the User entity by IDs.
func (m *FindingMutation) RemoveFindingToUserIDs(ids ...int) {
	if m.removed_FindingToUser == nil {
		m.removed_FindingToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FindingToUser[ids[i]] = struct{}{}
	}
}

// RemovedFindingToUser returns the removed IDs of the "FindingToUser" edge to the User entity.
func (m *FindingMutation) RemovedFindingToUserIDs() (ids []int) {
	for id := range m.removed_FindingToUser {
		ids = append(ids, id)
	}
	return
}

// FindingToUserIDs returns the "FindingToUser" edge IDs in the mutation.
func (m *FindingMutation) FindingToUserIDs() (ids []int) {
	for id := range m._FindingToUser {
		ids = append(ids, id)
	}
	return
}

// ResetFindingToUser resets all changes to the "FindingToUser" edge.
func (m *FindingMutation) ResetFindingToUser() {
	m._FindingToUser = nil
	m.cleared_FindingToUser = false
	m.removed_FindingToUser = nil
}

// AddFindingToTagIDs adds the "FindingToTag" edge to the Tag entity by ids.
func (m *FindingMutation) AddFindingToTagIDs(ids ...int) {
	if m._FindingToTag == nil {
		m._FindingToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._FindingToTag[ids[i]] = struct{}{}
	}
}

// ClearFindingToTag clears the "FindingToTag" edge to the Tag entity.
func (m *FindingMutation) ClearFindingToTag() {
	m.cleared_FindingToTag = true
}

// FindingToTagCleared returns if the "FindingToTag" edge to the Tag entity was cleared.
func (m *FindingMutation) FindingToTagCleared() bool {
	return m.cleared_FindingToTag
}

// RemoveFindingToTagIDs removes the "FindingToTag" edge to the Tag entity by IDs.
func (m *FindingMutation) RemoveFindingToTagIDs(ids ...int) {
	if m.removed_FindingToTag == nil {
		m.removed_FindingToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FindingToTag[ids[i]] = struct{}{}
	}
}

// RemovedFindingToTag returns the removed IDs of the "FindingToTag" edge to the Tag entity.
func (m *FindingMutation) RemovedFindingToTagIDs() (ids []int) {
	for id := range m.removed_FindingToTag {
		ids = append(ids, id)
	}
	return
}

// FindingToTagIDs returns the "FindingToTag" edge IDs in the mutation.
func (m *FindingMutation) FindingToTagIDs() (ids []int) {
	for id := range m._FindingToTag {
		ids = append(ids, id)
	}
	return
}

// ResetFindingToTag resets all changes to the "FindingToTag" edge.
func (m *FindingMutation) ResetFindingToTag() {
	m._FindingToTag = nil
	m.cleared_FindingToTag = false
	m.removed_FindingToTag = nil
}

// AddFindingToHostIDs adds the "FindingToHost" edge to the Host entity by ids.
func (m *FindingMutation) AddFindingToHostIDs(ids ...int) {
	if m._FindingToHost == nil {
		m._FindingToHost = make(map[int]struct{})
	}
	for i := range ids {
		m._FindingToHost[ids[i]] = struct{}{}
	}
}

// ClearFindingToHost clears the "FindingToHost" edge to the Host entity.
func (m *FindingMutation) ClearFindingToHost() {
	m.cleared_FindingToHost = true
}

// FindingToHostCleared returns if the "FindingToHost" edge to the Host entity was cleared.
func (m *FindingMutation) FindingToHostCleared() bool {
	return m.cleared_FindingToHost
}

// RemoveFindingToHostIDs removes the "FindingToHost" edge to the Host entity by IDs.
func (m *FindingMutation) RemoveFindingToHostIDs(ids ...int) {
	if m.removed_FindingToHost == nil {
		m.removed_FindingToHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FindingToHost[ids[i]] = struct{}{}
	}
}

// RemovedFindingToHost returns the removed IDs of the "FindingToHost" edge to the Host entity.
func (m *FindingMutation) RemovedFindingToHostIDs() (ids []int) {
	for id := range m.removed_FindingToHost {
		ids = append(ids, id)
	}
	return
}

// FindingToHostIDs returns the "FindingToHost" edge IDs in the mutation.
func (m *FindingMutation) FindingToHostIDs() (ids []int) {
	for id := range m._FindingToHost {
		ids = append(ids, id)
	}
	return
}

// ResetFindingToHost resets all changes to the "FindingToHost" edge.
func (m *FindingMutation) ResetFindingToHost() {
	m._FindingToHost = nil
	m.cleared_FindingToHost = false
	m.removed_FindingToHost = nil
}

// AddFindingToScriptIDs adds the "FindingToScript" edge to the Script entity by ids.
func (m *FindingMutation) AddFindingToScriptIDs(ids ...int) {
	if m._FindingToScript == nil {
		m._FindingToScript = make(map[int]struct{})
	}
	for i := range ids {
		m._FindingToScript[ids[i]] = struct{}{}
	}
}

// ClearFindingToScript clears the "FindingToScript" edge to the Script entity.
func (m *FindingMutation) ClearFindingToScript() {
	m.cleared_FindingToScript = true
}

// FindingToScriptCleared returns if the "FindingToScript" edge to the Script entity was cleared.
func (m *FindingMutation) FindingToScriptCleared() bool {
	return m.cleared_FindingToScript
}

// RemoveFindingToScriptIDs removes the "FindingToScript" edge to the Script entity by IDs.
func (m *FindingMutation) RemoveFindingToScriptIDs(ids ...int) {
	if m.removed_FindingToScript == nil {
		m.removed_FindingToScript = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FindingToScript[ids[i]] = struct{}{}
	}
}

// RemovedFindingToScript returns the removed IDs of the "FindingToScript" edge to the Script entity.
func (m *FindingMutation) RemovedFindingToScriptIDs() (ids []int) {
	for id := range m.removed_FindingToScript {
		ids = append(ids, id)
	}
	return
}

// FindingToScriptIDs returns the "FindingToScript" edge IDs in the mutation.
func (m *FindingMutation) FindingToScriptIDs() (ids []int) {
	for id := range m._FindingToScript {
		ids = append(ids, id)
	}
	return
}

// ResetFindingToScript resets all changes to the "FindingToScript" edge.
func (m *FindingMutation) ResetFindingToScript() {
	m._FindingToScript = nil
	m.cleared_FindingToScript = false
	m.removed_FindingToScript = nil
}

// AddFindingToEnvironmentIDs adds the "FindingToEnvironment" edge to the Environment entity by ids.
func (m *FindingMutation) AddFindingToEnvironmentIDs(ids ...int) {
	if m._FindingToEnvironment == nil {
		m._FindingToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._FindingToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearFindingToEnvironment clears the "FindingToEnvironment" edge to the Environment entity.
func (m *FindingMutation) ClearFindingToEnvironment() {
	m.cleared_FindingToEnvironment = true
}

// FindingToEnvironmentCleared returns if the "FindingToEnvironment" edge to the Environment entity was cleared.
func (m *FindingMutation) FindingToEnvironmentCleared() bool {
	return m.cleared_FindingToEnvironment
}

// RemoveFindingToEnvironmentIDs removes the "FindingToEnvironment" edge to the Environment entity by IDs.
func (m *FindingMutation) RemoveFindingToEnvironmentIDs(ids ...int) {
	if m.removed_FindingToEnvironment == nil {
		m.removed_FindingToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_FindingToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedFindingToEnvironment returns the removed IDs of the "FindingToEnvironment" edge to the Environment entity.
func (m *FindingMutation) RemovedFindingToEnvironmentIDs() (ids []int) {
	for id := range m.removed_FindingToEnvironment {
		ids = append(ids, id)
	}
	return
}

// FindingToEnvironmentIDs returns the "FindingToEnvironment" edge IDs in the mutation.
func (m *FindingMutation) FindingToEnvironmentIDs() (ids []int) {
	for id := range m._FindingToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetFindingToEnvironment resets all changes to the "FindingToEnvironment" edge.
func (m *FindingMutation) ResetFindingToEnvironment() {
	m._FindingToEnvironment = nil
	m.cleared_FindingToEnvironment = false
	m.removed_FindingToEnvironment = nil
}

// Op returns the operation name.
func (m *FindingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Finding).
func (m *FindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FindingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, finding.FieldName)
	}
	if m.description != nil {
		fields = append(fields, finding.FieldDescription)
	}
	if m.severity != nil {
		fields = append(fields, finding.FieldSeverity)
	}
	if m.difficulty != nil {
		fields = append(fields, finding.FieldDifficulty)
	}
	if m.tags != nil {
		fields = append(fields, finding.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case finding.FieldName:
		return m.Name()
	case finding.FieldDescription:
		return m.Description()
	case finding.FieldSeverity:
		return m.Severity()
	case finding.FieldDifficulty:
		return m.Difficulty()
	case finding.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case finding.FieldName:
		return m.OldName(ctx)
	case finding.FieldDescription:
		return m.OldDescription(ctx)
	case finding.FieldSeverity:
		return m.OldSeverity(ctx)
	case finding.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case finding.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Finding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case finding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case finding.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case finding.FieldSeverity:
		v, ok := value.(finding.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case finding.FieldDifficulty:
		v, ok := value.(finding.Difficulty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case finding.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Finding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Finding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FindingMutation) ResetField(name string) error {
	switch name {
	case finding.FieldName:
		m.ResetName()
		return nil
	case finding.FieldDescription:
		m.ResetDescription()
		return nil
	case finding.FieldSeverity:
		m.ResetSeverity()
		return nil
	case finding.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case finding.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._FindingToUser != nil {
		edges = append(edges, finding.EdgeFindingToUser)
	}
	if m._FindingToTag != nil {
		edges = append(edges, finding.EdgeFindingToTag)
	}
	if m._FindingToHost != nil {
		edges = append(edges, finding.EdgeFindingToHost)
	}
	if m._FindingToScript != nil {
		edges = append(edges, finding.EdgeFindingToScript)
	}
	if m._FindingToEnvironment != nil {
		edges = append(edges, finding.EdgeFindingToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeFindingToUser:
		ids := make([]ent.Value, 0, len(m._FindingToUser))
		for id := range m._FindingToUser {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToTag:
		ids := make([]ent.Value, 0, len(m._FindingToTag))
		for id := range m._FindingToTag {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToHost:
		ids := make([]ent.Value, 0, len(m._FindingToHost))
		for id := range m._FindingToHost {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToScript:
		ids := make([]ent.Value, 0, len(m._FindingToScript))
		for id := range m._FindingToScript {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToEnvironment:
		ids := make([]ent.Value, 0, len(m._FindingToEnvironment))
		for id := range m._FindingToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_FindingToUser != nil {
		edges = append(edges, finding.EdgeFindingToUser)
	}
	if m.removed_FindingToTag != nil {
		edges = append(edges, finding.EdgeFindingToTag)
	}
	if m.removed_FindingToHost != nil {
		edges = append(edges, finding.EdgeFindingToHost)
	}
	if m.removed_FindingToScript != nil {
		edges = append(edges, finding.EdgeFindingToScript)
	}
	if m.removed_FindingToEnvironment != nil {
		edges = append(edges, finding.EdgeFindingToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FindingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeFindingToUser:
		ids := make([]ent.Value, 0, len(m.removed_FindingToUser))
		for id := range m.removed_FindingToUser {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToTag:
		ids := make([]ent.Value, 0, len(m.removed_FindingToTag))
		for id := range m.removed_FindingToTag {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToHost:
		ids := make([]ent.Value, 0, len(m.removed_FindingToHost))
		for id := range m.removed_FindingToHost {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToScript:
		ids := make([]ent.Value, 0, len(m.removed_FindingToScript))
		for id := range m.removed_FindingToScript {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_FindingToEnvironment))
		for id := range m.removed_FindingToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_FindingToUser {
		edges = append(edges, finding.EdgeFindingToUser)
	}
	if m.cleared_FindingToTag {
		edges = append(edges, finding.EdgeFindingToTag)
	}
	if m.cleared_FindingToHost {
		edges = append(edges, finding.EdgeFindingToHost)
	}
	if m.cleared_FindingToScript {
		edges = append(edges, finding.EdgeFindingToScript)
	}
	if m.cleared_FindingToEnvironment {
		edges = append(edges, finding.EdgeFindingToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FindingMutation) EdgeCleared(name string) bool {
	switch name {
	case finding.EdgeFindingToUser:
		return m.cleared_FindingToUser
	case finding.EdgeFindingToTag:
		return m.cleared_FindingToTag
	case finding.EdgeFindingToHost:
		return m.cleared_FindingToHost
	case finding.EdgeFindingToScript:
		return m.cleared_FindingToScript
	case finding.EdgeFindingToEnvironment:
		return m.cleared_FindingToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FindingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Finding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FindingMutation) ResetEdge(name string) error {
	switch name {
	case finding.EdgeFindingToUser:
		m.ResetFindingToUser()
		return nil
	case finding.EdgeFindingToTag:
		m.ResetFindingToTag()
		return nil
	case finding.EdgeFindingToHost:
		m.ResetFindingToHost()
		return nil
	case finding.EdgeFindingToScript:
		m.ResetFindingToScript()
		return nil
	case finding.EdgeFindingToEnvironment:
		m.ResetFindingToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Finding edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	hcl_id                               *string
	hostname                             *string
	description                          *string
	_OS                                  *string
	last_octet                           *int
	addlast_octet                        *int
	instance_size                        *string
	allow_mac_changes                    *bool
	exposed_tcp_ports                    *[]string
	exposed_udp_ports                    *[]string
	override_password                    *string
	vars                                 *map[string]string
	user_groups                          *[]string
	provision_steps                      *[]string
	tags                                 *map[string]string
	clearedFields                        map[string]struct{}
	_HostToDisk                          map[int]struct{}
	removed_HostToDisk                   map[int]struct{}
	cleared_HostToDisk                   bool
	_HostToUser                          map[int]struct{}
	removed_HostToUser                   map[int]struct{}
	cleared_HostToUser                   bool
	_HostToTag                           map[int]struct{}
	removed_HostToTag                    map[int]struct{}
	cleared_HostToTag                    bool
	_HostToEnvironment                   map[int]struct{}
	removed_HostToEnvironment            map[int]struct{}
	cleared_HostToEnvironment            bool
	_HostToIncludedNetwork               map[int]struct{}
	removed_HostToIncludedNetwork        map[int]struct{}
	cleared_HostToIncludedNetwork        bool
	_DependOnHostToHostDependency        map[int]struct{}
	removed_DependOnHostToHostDependency map[int]struct{}
	cleared_DependOnHostToHostDependency bool
	_DependByHostToHostDependency        map[int]struct{}
	removed_DependByHostToHostDependency map[int]struct{}
	cleared_DependByHostToHostDependency bool
	done                                 bool
	oldValue                             func(context.Context) (*Host, error)
	predicates                           []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id int) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *HostMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *HostMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *HostMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetHostname sets the "hostname" field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetDescription sets the "description" field.
func (m *HostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HostMutation) ResetDescription() {
	m.description = nil
}

// SetOS sets the "OS" field.
func (m *HostMutation) SetOS(s string) {
	m._OS = &s
}

// OS returns the value of the "OS" field in the mutation.
func (m *HostMutation) OS() (r string, exists bool) {
	v := m._OS
	if v == nil {
		return
	}
	return *v, true
}

// OldOS returns the old "OS" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOS: %w", err)
	}
	return oldValue.OS, nil
}

// ResetOS resets all changes to the "OS" field.
func (m *HostMutation) ResetOS() {
	m._OS = nil
}

// SetLastOctet sets the "last_octet" field.
func (m *HostMutation) SetLastOctet(i int) {
	m.last_octet = &i
	m.addlast_octet = nil
}

// LastOctet returns the value of the "last_octet" field in the mutation.
func (m *HostMutation) LastOctet() (r int, exists bool) {
	v := m.last_octet
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOctet returns the old "last_octet" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldLastOctet(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastOctet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastOctet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOctet: %w", err)
	}
	return oldValue.LastOctet, nil
}

// AddLastOctet adds i to the "last_octet" field.
func (m *HostMutation) AddLastOctet(i int) {
	if m.addlast_octet != nil {
		*m.addlast_octet += i
	} else {
		m.addlast_octet = &i
	}
}

// AddedLastOctet returns the value that was added to the "last_octet" field in this mutation.
func (m *HostMutation) AddedLastOctet() (r int, exists bool) {
	v := m.addlast_octet
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastOctet resets all changes to the "last_octet" field.
func (m *HostMutation) ResetLastOctet() {
	m.last_octet = nil
	m.addlast_octet = nil
}

// SetInstanceSize sets the "instance_size" field.
func (m *HostMutation) SetInstanceSize(s string) {
	m.instance_size = &s
}

// InstanceSize returns the value of the "instance_size" field in the mutation.
func (m *HostMutation) InstanceSize() (r string, exists bool) {
	v := m.instance_size
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceSize returns the old "instance_size" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldInstanceSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstanceSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstanceSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceSize: %w", err)
	}
	return oldValue.InstanceSize, nil
}

// ResetInstanceSize resets all changes to the "instance_size" field.
func (m *HostMutation) ResetInstanceSize() {
	m.instance_size = nil
}

// SetAllowMACChanges sets the "allow_mac_changes" field.
func (m *HostMutation) SetAllowMACChanges(b bool) {
	m.allow_mac_changes = &b
}

// AllowMACChanges returns the value of the "allow_mac_changes" field in the mutation.
func (m *HostMutation) AllowMACChanges() (r bool, exists bool) {
	v := m.allow_mac_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowMACChanges returns the old "allow_mac_changes" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAllowMACChanges(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllowMACChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllowMACChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowMACChanges: %w", err)
	}
	return oldValue.AllowMACChanges, nil
}

// ResetAllowMACChanges resets all changes to the "allow_mac_changes" field.
func (m *HostMutation) ResetAllowMACChanges() {
	m.allow_mac_changes = nil
}

// SetExposedTCPPorts sets the "exposed_tcp_ports" field.
func (m *HostMutation) SetExposedTCPPorts(s []string) {
	m.exposed_tcp_ports = &s
}

// ExposedTCPPorts returns the value of the "exposed_tcp_ports" field in the mutation.
func (m *HostMutation) ExposedTCPPorts() (r []string, exists bool) {
	v := m.exposed_tcp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedTCPPorts returns the old "exposed_tcp_ports" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldExposedTCPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExposedTCPPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExposedTCPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedTCPPorts: %w", err)
	}
	return oldValue.ExposedTCPPorts, nil
}

// ResetExposedTCPPorts resets all changes to the "exposed_tcp_ports" field.
func (m *HostMutation) ResetExposedTCPPorts() {
	m.exposed_tcp_ports = nil
}

// SetExposedUDPPorts sets the "exposed_udp_ports" field.
func (m *HostMutation) SetExposedUDPPorts(s []string) {
	m.exposed_udp_ports = &s
}

// ExposedUDPPorts returns the value of the "exposed_udp_ports" field in the mutation.
func (m *HostMutation) ExposedUDPPorts() (r []string, exists bool) {
	v := m.exposed_udp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedUDPPorts returns the old "exposed_udp_ports" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldExposedUDPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExposedUDPPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExposedUDPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedUDPPorts: %w", err)
	}
	return oldValue.ExposedUDPPorts, nil
}

// ResetExposedUDPPorts resets all changes to the "exposed_udp_ports" field.
func (m *HostMutation) ResetExposedUDPPorts() {
	m.exposed_udp_ports = nil
}

// SetOverridePassword sets the "override_password" field.
func (m *HostMutation) SetOverridePassword(s string) {
	m.override_password = &s
}

// OverridePassword returns the value of the "override_password" field in the mutation.
func (m *HostMutation) OverridePassword() (r string, exists bool) {
	v := m.override_password
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePassword returns the old "override_password" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOverridePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOverridePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOverridePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePassword: %w", err)
	}
	return oldValue.OverridePassword, nil
}

// ResetOverridePassword resets all changes to the "override_password" field.
func (m *HostMutation) ResetOverridePassword() {
	m.override_password = nil
}

// SetVars sets the "vars" field.
func (m *HostMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *HostMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *HostMutation) ResetVars() {
	m.vars = nil
}

// SetUserGroups sets the "user_groups" field.
func (m *HostMutation) SetUserGroups(s []string) {
	m.user_groups = &s
}

// UserGroups returns the value of the "user_groups" field in the mutation.
func (m *HostMutation) UserGroups() (r []string, exists bool) {
	v := m.user_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldUserGroups returns the old "user_groups" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUserGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserGroups: %w", err)
	}
	return oldValue.UserGroups, nil
}

// ResetUserGroups resets all changes to the "user_groups" field.
func (m *HostMutation) ResetUserGroups() {
	m.user_groups = nil
}

// SetProvisionSteps sets the "provision_steps" field.
func (m *HostMutation) SetProvisionSteps(s []string) {
	m.provision_steps = &s
}

// ProvisionSteps returns the value of the "provision_steps" field in the mutation.
func (m *HostMutation) ProvisionSteps() (r []string, exists bool) {
	v := m.provision_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldProvisionSteps returns the old "provision_steps" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldProvisionSteps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvisionSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvisionSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvisionSteps: %w", err)
	}
	return oldValue.ProvisionSteps, nil
}

// ClearProvisionSteps clears the value of the "provision_steps" field.
func (m *HostMutation) ClearProvisionSteps() {
	m.provision_steps = nil
	m.clearedFields[host.FieldProvisionSteps] = struct{}{}
}

// ProvisionStepsCleared returns if the "provision_steps" field was cleared in this mutation.
func (m *HostMutation) ProvisionStepsCleared() bool {
	_, ok := m.clearedFields[host.FieldProvisionSteps]
	return ok
}

// ResetProvisionSteps resets all changes to the "provision_steps" field.
func (m *HostMutation) ResetProvisionSteps() {
	m.provision_steps = nil
	delete(m.clearedFields, host.FieldProvisionSteps)
}

// SetTags sets the "tags" field.
func (m *HostMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *HostMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *HostMutation) ResetTags() {
	m.tags = nil
}

// AddHostToDiskIDs adds the "HostToDisk" edge to the Disk entity by ids.
func (m *HostMutation) AddHostToDiskIDs(ids ...int) {
	if m._HostToDisk == nil {
		m._HostToDisk = make(map[int]struct{})
	}
	for i := range ids {
		m._HostToDisk[ids[i]] = struct{}{}
	}
}

// ClearHostToDisk clears the "HostToDisk" edge to the Disk entity.
func (m *HostMutation) ClearHostToDisk() {
	m.cleared_HostToDisk = true
}

// HostToDiskCleared returns if the "HostToDisk" edge to the Disk entity was cleared.
func (m *HostMutation) HostToDiskCleared() bool {
	return m.cleared_HostToDisk
}

// RemoveHostToDiskIDs removes the "HostToDisk" edge to the Disk entity by IDs.
func (m *HostMutation) RemoveHostToDiskIDs(ids ...int) {
	if m.removed_HostToDisk == nil {
		m.removed_HostToDisk = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostToDisk[ids[i]] = struct{}{}
	}
}

// RemovedHostToDisk returns the removed IDs of the "HostToDisk" edge to the Disk entity.
func (m *HostMutation) RemovedHostToDiskIDs() (ids []int) {
	for id := range m.removed_HostToDisk {
		ids = append(ids, id)
	}
	return
}

// HostToDiskIDs returns the "HostToDisk" edge IDs in the mutation.
func (m *HostMutation) HostToDiskIDs() (ids []int) {
	for id := range m._HostToDisk {
		ids = append(ids, id)
	}
	return
}

// ResetHostToDisk resets all changes to the "HostToDisk" edge.
func (m *HostMutation) ResetHostToDisk() {
	m._HostToDisk = nil
	m.cleared_HostToDisk = false
	m.removed_HostToDisk = nil
}

// AddHostToUserIDs adds the "HostToUser" edge to the User entity by ids.
func (m *HostMutation) AddHostToUserIDs(ids ...int) {
	if m._HostToUser == nil {
		m._HostToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._HostToUser[ids[i]] = struct{}{}
	}
}

// ClearHostToUser clears the "HostToUser" edge to the User entity.
func (m *HostMutation) ClearHostToUser() {
	m.cleared_HostToUser = true
}

// HostToUserCleared returns if the "HostToUser" edge to the User entity was cleared.
func (m *HostMutation) HostToUserCleared() bool {
	return m.cleared_HostToUser
}

// RemoveHostToUserIDs removes the "HostToUser" edge to the User entity by IDs.
func (m *HostMutation) RemoveHostToUserIDs(ids ...int) {
	if m.removed_HostToUser == nil {
		m.removed_HostToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostToUser[ids[i]] = struct{}{}
	}
}

// RemovedHostToUser returns the removed IDs of the "HostToUser" edge to the User entity.
func (m *HostMutation) RemovedHostToUserIDs() (ids []int) {
	for id := range m.removed_HostToUser {
		ids = append(ids, id)
	}
	return
}

// HostToUserIDs returns the "HostToUser" edge IDs in the mutation.
func (m *HostMutation) HostToUserIDs() (ids []int) {
	for id := range m._HostToUser {
		ids = append(ids, id)
	}
	return
}

// ResetHostToUser resets all changes to the "HostToUser" edge.
func (m *HostMutation) ResetHostToUser() {
	m._HostToUser = nil
	m.cleared_HostToUser = false
	m.removed_HostToUser = nil
}

// AddHostToTagIDs adds the "HostToTag" edge to the Tag entity by ids.
func (m *HostMutation) AddHostToTagIDs(ids ...int) {
	if m._HostToTag == nil {
		m._HostToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._HostToTag[ids[i]] = struct{}{}
	}
}

// ClearHostToTag clears the "HostToTag" edge to the Tag entity.
func (m *HostMutation) ClearHostToTag() {
	m.cleared_HostToTag = true
}

// HostToTagCleared returns if the "HostToTag" edge to the Tag entity was cleared.
func (m *HostMutation) HostToTagCleared() bool {
	return m.cleared_HostToTag
}

// RemoveHostToTagIDs removes the "HostToTag" edge to the Tag entity by IDs.
func (m *HostMutation) RemoveHostToTagIDs(ids ...int) {
	if m.removed_HostToTag == nil {
		m.removed_HostToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostToTag[ids[i]] = struct{}{}
	}
}

// RemovedHostToTag returns the removed IDs of the "HostToTag" edge to the Tag entity.
func (m *HostMutation) RemovedHostToTagIDs() (ids []int) {
	for id := range m.removed_HostToTag {
		ids = append(ids, id)
	}
	return
}

// HostToTagIDs returns the "HostToTag" edge IDs in the mutation.
func (m *HostMutation) HostToTagIDs() (ids []int) {
	for id := range m._HostToTag {
		ids = append(ids, id)
	}
	return
}

// ResetHostToTag resets all changes to the "HostToTag" edge.
func (m *HostMutation) ResetHostToTag() {
	m._HostToTag = nil
	m.cleared_HostToTag = false
	m.removed_HostToTag = nil
}

// AddHostToEnvironmentIDs adds the "HostToEnvironment" edge to the Environment entity by ids.
func (m *HostMutation) AddHostToEnvironmentIDs(ids ...int) {
	if m._HostToEnvironment == nil {
		m._HostToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._HostToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearHostToEnvironment clears the "HostToEnvironment" edge to the Environment entity.
func (m *HostMutation) ClearHostToEnvironment() {
	m.cleared_HostToEnvironment = true
}

// HostToEnvironmentCleared returns if the "HostToEnvironment" edge to the Environment entity was cleared.
func (m *HostMutation) HostToEnvironmentCleared() bool {
	return m.cleared_HostToEnvironment
}

// RemoveHostToEnvironmentIDs removes the "HostToEnvironment" edge to the Environment entity by IDs.
func (m *HostMutation) RemoveHostToEnvironmentIDs(ids ...int) {
	if m.removed_HostToEnvironment == nil {
		m.removed_HostToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedHostToEnvironment returns the removed IDs of the "HostToEnvironment" edge to the Environment entity.
func (m *HostMutation) RemovedHostToEnvironmentIDs() (ids []int) {
	for id := range m.removed_HostToEnvironment {
		ids = append(ids, id)
	}
	return
}

// HostToEnvironmentIDs returns the "HostToEnvironment" edge IDs in the mutation.
func (m *HostMutation) HostToEnvironmentIDs() (ids []int) {
	for id := range m._HostToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetHostToEnvironment resets all changes to the "HostToEnvironment" edge.
func (m *HostMutation) ResetHostToEnvironment() {
	m._HostToEnvironment = nil
	m.cleared_HostToEnvironment = false
	m.removed_HostToEnvironment = nil
}

// AddHostToIncludedNetworkIDs adds the "HostToIncludedNetwork" edge to the IncludedNetwork entity by ids.
func (m *HostMutation) AddHostToIncludedNetworkIDs(ids ...int) {
	if m._HostToIncludedNetwork == nil {
		m._HostToIncludedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._HostToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// ClearHostToIncludedNetwork clears the "HostToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *HostMutation) ClearHostToIncludedNetwork() {
	m.cleared_HostToIncludedNetwork = true
}

// HostToIncludedNetworkCleared returns if the "HostToIncludedNetwork" edge to the IncludedNetwork entity was cleared.
func (m *HostMutation) HostToIncludedNetworkCleared() bool {
	return m.cleared_HostToIncludedNetwork
}

// RemoveHostToIncludedNetworkIDs removes the "HostToIncludedNetwork" edge to the IncludedNetwork entity by IDs.
func (m *HostMutation) RemoveHostToIncludedNetworkIDs(ids ...int) {
	if m.removed_HostToIncludedNetwork == nil {
		m.removed_HostToIncludedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedHostToIncludedNetwork returns the removed IDs of the "HostToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *HostMutation) RemovedHostToIncludedNetworkIDs() (ids []int) {
	for id := range m.removed_HostToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// HostToIncludedNetworkIDs returns the "HostToIncludedNetwork" edge IDs in the mutation.
func (m *HostMutation) HostToIncludedNetworkIDs() (ids []int) {
	for id := range m._HostToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetHostToIncludedNetwork resets all changes to the "HostToIncludedNetwork" edge.
func (m *HostMutation) ResetHostToIncludedNetwork() {
	m._HostToIncludedNetwork = nil
	m.cleared_HostToIncludedNetwork = false
	m.removed_HostToIncludedNetwork = nil
}

// AddDependOnHostToHostDependencyIDs adds the "DependOnHostToHostDependency" edge to the HostDependency entity by ids.
func (m *HostMutation) AddDependOnHostToHostDependencyIDs(ids ...int) {
	if m._DependOnHostToHostDependency == nil {
		m._DependOnHostToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m._DependOnHostToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearDependOnHostToHostDependency clears the "DependOnHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) ClearDependOnHostToHostDependency() {
	m.cleared_DependOnHostToHostDependency = true
}

// DependOnHostToHostDependencyCleared returns if the "DependOnHostToHostDependency" edge to the HostDependency entity was cleared.
func (m *HostMutation) DependOnHostToHostDependencyCleared() bool {
	return m.cleared_DependOnHostToHostDependency
}

// RemoveDependOnHostToHostDependencyIDs removes the "DependOnHostToHostDependency" edge to the HostDependency entity by IDs.
func (m *HostMutation) RemoveDependOnHostToHostDependencyIDs(ids ...int) {
	if m.removed_DependOnHostToHostDependency == nil {
		m.removed_DependOnHostToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DependOnHostToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedDependOnHostToHostDependency returns the removed IDs of the "DependOnHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) RemovedDependOnHostToHostDependencyIDs() (ids []int) {
	for id := range m.removed_DependOnHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// DependOnHostToHostDependencyIDs returns the "DependOnHostToHostDependency" edge IDs in the mutation.
func (m *HostMutation) DependOnHostToHostDependencyIDs() (ids []int) {
	for id := range m._DependOnHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetDependOnHostToHostDependency resets all changes to the "DependOnHostToHostDependency" edge.
func (m *HostMutation) ResetDependOnHostToHostDependency() {
	m._DependOnHostToHostDependency = nil
	m.cleared_DependOnHostToHostDependency = false
	m.removed_DependOnHostToHostDependency = nil
}

// AddDependByHostToHostDependencyIDs adds the "DependByHostToHostDependency" edge to the HostDependency entity by ids.
func (m *HostMutation) AddDependByHostToHostDependencyIDs(ids ...int) {
	if m._DependByHostToHostDependency == nil {
		m._DependByHostToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m._DependByHostToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearDependByHostToHostDependency clears the "DependByHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) ClearDependByHostToHostDependency() {
	m.cleared_DependByHostToHostDependency = true
}

// DependByHostToHostDependencyCleared returns if the "DependByHostToHostDependency" edge to the HostDependency entity was cleared.
func (m *HostMutation) DependByHostToHostDependencyCleared() bool {
	return m.cleared_DependByHostToHostDependency
}

// RemoveDependByHostToHostDependencyIDs removes the "DependByHostToHostDependency" edge to the HostDependency entity by IDs.
func (m *HostMutation) RemoveDependByHostToHostDependencyIDs(ids ...int) {
	if m.removed_DependByHostToHostDependency == nil {
		m.removed_DependByHostToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_DependByHostToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedDependByHostToHostDependency returns the removed IDs of the "DependByHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) RemovedDependByHostToHostDependencyIDs() (ids []int) {
	for id := range m.removed_DependByHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// DependByHostToHostDependencyIDs returns the "DependByHostToHostDependency" edge IDs in the mutation.
func (m *HostMutation) DependByHostToHostDependencyIDs() (ids []int) {
	for id := range m._DependByHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetDependByHostToHostDependency resets all changes to the "DependByHostToHostDependency" edge.
func (m *HostMutation) ResetDependByHostToHostDependency() {
	m._DependByHostToHostDependency = nil
	m.cleared_DependByHostToHostDependency = false
	m.removed_DependByHostToHostDependency = nil
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hcl_id != nil {
		fields = append(fields, host.FieldHclID)
	}
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.description != nil {
		fields = append(fields, host.FieldDescription)
	}
	if m._OS != nil {
		fields = append(fields, host.FieldOS)
	}
	if m.last_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	if m.instance_size != nil {
		fields = append(fields, host.FieldInstanceSize)
	}
	if m.allow_mac_changes != nil {
		fields = append(fields, host.FieldAllowMACChanges)
	}
	if m.exposed_tcp_ports != nil {
		fields = append(fields, host.FieldExposedTCPPorts)
	}
	if m.exposed_udp_ports != nil {
		fields = append(fields, host.FieldExposedUDPPorts)
	}
	if m.override_password != nil {
		fields = append(fields, host.FieldOverridePassword)
	}
	if m.vars != nil {
		fields = append(fields, host.FieldVars)
	}
	if m.user_groups != nil {
		fields = append(fields, host.FieldUserGroups)
	}
	if m.provision_steps != nil {
		fields = append(fields, host.FieldProvisionSteps)
	}
	if m.tags != nil {
		fields = append(fields, host.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldHclID:
		return m.HclID()
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldDescription:
		return m.Description()
	case host.FieldOS:
		return m.OS()
	case host.FieldLastOctet:
		return m.LastOctet()
	case host.FieldInstanceSize:
		return m.InstanceSize()
	case host.FieldAllowMACChanges:
		return m.AllowMACChanges()
	case host.FieldExposedTCPPorts:
		return m.ExposedTCPPorts()
	case host.FieldExposedUDPPorts:
		return m.ExposedUDPPorts()
	case host.FieldOverridePassword:
		return m.OverridePassword()
	case host.FieldVars:
		return m.Vars()
	case host.FieldUserGroups:
		return m.UserGroups()
	case host.FieldProvisionSteps:
		return m.ProvisionSteps()
	case host.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldHclID:
		return m.OldHclID(ctx)
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldDescription:
		return m.OldDescription(ctx)
	case host.FieldOS:
		return m.OldOS(ctx)
	case host.FieldLastOctet:
		return m.OldLastOctet(ctx)
	case host.FieldInstanceSize:
		return m.OldInstanceSize(ctx)
	case host.FieldAllowMACChanges:
		return m.OldAllowMACChanges(ctx)
	case host.FieldExposedTCPPorts:
		return m.OldExposedTCPPorts(ctx)
	case host.FieldExposedUDPPorts:
		return m.OldExposedUDPPorts(ctx)
	case host.FieldOverridePassword:
		return m.OldOverridePassword(ctx)
	case host.FieldVars:
		return m.OldVars(ctx)
	case host.FieldUserGroups:
		return m.OldUserGroups(ctx)
	case host.FieldProvisionSteps:
		return m.OldProvisionSteps(ctx)
	case host.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case host.FieldOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOS(v)
		return nil
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOctet(v)
		return nil
	case host.FieldInstanceSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceSize(v)
		return nil
	case host.FieldAllowMACChanges:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowMACChanges(v)
		return nil
	case host.FieldExposedTCPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedTCPPorts(v)
		return nil
	case host.FieldExposedUDPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedUDPPorts(v)
		return nil
	case host.FieldOverridePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePassword(v)
		return nil
	case host.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case host.FieldUserGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserGroups(v)
		return nil
	case host.FieldProvisionSteps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvisionSteps(v)
		return nil
	case host.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	if m.addlast_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case host.FieldLastOctet:
		return m.AddedLastOctet()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastOctet(v)
		return nil
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldProvisionSteps) {
		fields = append(fields, host.FieldProvisionSteps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldProvisionSteps:
		m.ClearProvisionSteps()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldHclID:
		m.ResetHclID()
		return nil
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldDescription:
		m.ResetDescription()
		return nil
	case host.FieldOS:
		m.ResetOS()
		return nil
	case host.FieldLastOctet:
		m.ResetLastOctet()
		return nil
	case host.FieldInstanceSize:
		m.ResetInstanceSize()
		return nil
	case host.FieldAllowMACChanges:
		m.ResetAllowMACChanges()
		return nil
	case host.FieldExposedTCPPorts:
		m.ResetExposedTCPPorts()
		return nil
	case host.FieldExposedUDPPorts:
		m.ResetExposedUDPPorts()
		return nil
	case host.FieldOverridePassword:
		m.ResetOverridePassword()
		return nil
	case host.FieldVars:
		m.ResetVars()
		return nil
	case host.FieldUserGroups:
		m.ResetUserGroups()
		return nil
	case host.FieldProvisionSteps:
		m.ResetProvisionSteps()
		return nil
	case host.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m._HostToDisk != nil {
		edges = append(edges, host.EdgeHostToDisk)
	}
	if m._HostToUser != nil {
		edges = append(edges, host.EdgeHostToUser)
	}
	if m._HostToTag != nil {
		edges = append(edges, host.EdgeHostToTag)
	}
	if m._HostToEnvironment != nil {
		edges = append(edges, host.EdgeHostToEnvironment)
	}
	if m._HostToIncludedNetwork != nil {
		edges = append(edges, host.EdgeHostToIncludedNetwork)
	}
	if m._DependOnHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependOnHostToHostDependency)
	}
	if m._DependByHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependByHostToHostDependency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostToDisk:
		ids := make([]ent.Value, 0, len(m._HostToDisk))
		for id := range m._HostToDisk {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToUser:
		ids := make([]ent.Value, 0, len(m._HostToUser))
		for id := range m._HostToUser {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToTag:
		ids := make([]ent.Value, 0, len(m._HostToTag))
		for id := range m._HostToTag {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToEnvironment:
		ids := make([]ent.Value, 0, len(m._HostToEnvironment))
		for id := range m._HostToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m._HostToIncludedNetwork))
		for id := range m._HostToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependOnHostToHostDependency:
		ids := make([]ent.Value, 0, len(m._DependOnHostToHostDependency))
		for id := range m._DependOnHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependByHostToHostDependency:
		ids := make([]ent.Value, 0, len(m._DependByHostToHostDependency))
		for id := range m._DependByHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removed_HostToDisk != nil {
		edges = append(edges, host.EdgeHostToDisk)
	}
	if m.removed_HostToUser != nil {
		edges = append(edges, host.EdgeHostToUser)
	}
	if m.removed_HostToTag != nil {
		edges = append(edges, host.EdgeHostToTag)
	}
	if m.removed_HostToEnvironment != nil {
		edges = append(edges, host.EdgeHostToEnvironment)
	}
	if m.removed_HostToIncludedNetwork != nil {
		edges = append(edges, host.EdgeHostToIncludedNetwork)
	}
	if m.removed_DependOnHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependOnHostToHostDependency)
	}
	if m.removed_DependByHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependByHostToHostDependency)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostToDisk:
		ids := make([]ent.Value, 0, len(m.removed_HostToDisk))
		for id := range m.removed_HostToDisk {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToUser:
		ids := make([]ent.Value, 0, len(m.removed_HostToUser))
		for id := range m.removed_HostToUser {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToTag:
		ids := make([]ent.Value, 0, len(m.removed_HostToTag))
		for id := range m.removed_HostToTag {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_HostToEnvironment))
		for id := range m.removed_HostToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_HostToIncludedNetwork))
		for id := range m.removed_HostToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependOnHostToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_DependOnHostToHostDependency))
		for id := range m.removed_DependOnHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependByHostToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_DependByHostToHostDependency))
		for id := range m.removed_DependByHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleared_HostToDisk {
		edges = append(edges, host.EdgeHostToDisk)
	}
	if m.cleared_HostToUser {
		edges = append(edges, host.EdgeHostToUser)
	}
	if m.cleared_HostToTag {
		edges = append(edges, host.EdgeHostToTag)
	}
	if m.cleared_HostToEnvironment {
		edges = append(edges, host.EdgeHostToEnvironment)
	}
	if m.cleared_HostToIncludedNetwork {
		edges = append(edges, host.EdgeHostToIncludedNetwork)
	}
	if m.cleared_DependOnHostToHostDependency {
		edges = append(edges, host.EdgeDependOnHostToHostDependency)
	}
	if m.cleared_DependByHostToHostDependency {
		edges = append(edges, host.EdgeDependByHostToHostDependency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeHostToDisk:
		return m.cleared_HostToDisk
	case host.EdgeHostToUser:
		return m.cleared_HostToUser
	case host.EdgeHostToTag:
		return m.cleared_HostToTag
	case host.EdgeHostToEnvironment:
		return m.cleared_HostToEnvironment
	case host.EdgeHostToIncludedNetwork:
		return m.cleared_HostToIncludedNetwork
	case host.EdgeDependOnHostToHostDependency:
		return m.cleared_DependOnHostToHostDependency
	case host.EdgeDependByHostToHostDependency:
		return m.cleared_DependByHostToHostDependency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeHostToDisk:
		m.ResetHostToDisk()
		return nil
	case host.EdgeHostToUser:
		m.ResetHostToUser()
		return nil
	case host.EdgeHostToTag:
		m.ResetHostToTag()
		return nil
	case host.EdgeHostToEnvironment:
		m.ResetHostToEnvironment()
		return nil
	case host.EdgeHostToIncludedNetwork:
		m.ResetHostToIncludedNetwork()
		return nil
	case host.EdgeDependOnHostToHostDependency:
		m.ResetDependOnHostToHostDependency()
		return nil
	case host.EdgeDependByHostToHostDependency:
		m.ResetDependByHostToHostDependency()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostDependencyMutation represents an operation that mutates the HostDependency nodes in the graph.
type HostDependencyMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	host_id                              *string
	network_id                           *string
	clearedFields                        map[string]struct{}
	_HostDependencyToDependOnHost        map[int]struct{}
	removed_HostDependencyToDependOnHost map[int]struct{}
	cleared_HostDependencyToDependOnHost bool
	_HostDependencyToDependByHost        map[int]struct{}
	removed_HostDependencyToDependByHost map[int]struct{}
	cleared_HostDependencyToDependByHost bool
	_HostDependencyToNetwork             map[int]struct{}
	removed_HostDependencyToNetwork      map[int]struct{}
	cleared_HostDependencyToNetwork      bool
	_HostDependencyToEnvironment         map[int]struct{}
	removed_HostDependencyToEnvironment  map[int]struct{}
	cleared_HostDependencyToEnvironment  bool
	done                                 bool
	oldValue                             func(context.Context) (*HostDependency, error)
	predicates                           []predicate.HostDependency
}

var _ ent.Mutation = (*HostDependencyMutation)(nil)

// hostdependencyOption allows management of the mutation configuration using functional options.
type hostdependencyOption func(*HostDependencyMutation)

// newHostDependencyMutation creates new mutation for the HostDependency entity.
func newHostDependencyMutation(c config, op Op, opts ...hostdependencyOption) *HostDependencyMutation {
	m := &HostDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeHostDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostDependencyID sets the ID field of the mutation.
func withHostDependencyID(id int) hostdependencyOption {
	return func(m *HostDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *HostDependency
		)
		m.oldValue = func(ctx context.Context) (*HostDependency, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostDependency sets the old HostDependency of the mutation.
func withHostDependency(node *HostDependency) hostdependencyOption {
	return func(m *HostDependencyMutation) {
		m.oldValue = func(context.Context) (*HostDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HostDependencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHostID sets the "host_id" field.
func (m *HostDependencyMutation) SetHostID(s string) {
	m.host_id = &s
}

// HostID returns the value of the "host_id" field in the mutation.
func (m *HostDependencyMutation) HostID() (r string, exists bool) {
	v := m.host_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "host_id" field's value of the HostDependency entity.
// If the HostDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostDependencyMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "host_id" field.
func (m *HostDependencyMutation) ResetHostID() {
	m.host_id = nil
}

// SetNetworkID sets the "network_id" field.
func (m *HostDependencyMutation) SetNetworkID(s string) {
	m.network_id = &s
}

// NetworkID returns the value of the "network_id" field in the mutation.
func (m *HostDependencyMutation) NetworkID() (r string, exists bool) {
	v := m.network_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkID returns the old "network_id" field's value of the HostDependency entity.
// If the HostDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostDependencyMutation) OldNetworkID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetworkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkID: %w", err)
	}
	return oldValue.NetworkID, nil
}

// ResetNetworkID resets all changes to the "network_id" field.
func (m *HostDependencyMutation) ResetNetworkID() {
	m.network_id = nil
}

// AddHostDependencyToDependOnHostIDs adds the "HostDependencyToDependOnHost" edge to the Host entity by ids.
func (m *HostDependencyMutation) AddHostDependencyToDependOnHostIDs(ids ...int) {
	if m._HostDependencyToDependOnHost == nil {
		m._HostDependencyToDependOnHost = make(map[int]struct{})
	}
	for i := range ids {
		m._HostDependencyToDependOnHost[ids[i]] = struct{}{}
	}
}

// ClearHostDependencyToDependOnHost clears the "HostDependencyToDependOnHost" edge to the Host entity.
func (m *HostDependencyMutation) ClearHostDependencyToDependOnHost() {
	m.cleared_HostDependencyToDependOnHost = true
}

// HostDependencyToDependOnHostCleared returns if the "HostDependencyToDependOnHost" edge to the Host entity was cleared.
func (m *HostDependencyMutation) HostDependencyToDependOnHostCleared() bool {
	return m.cleared_HostDependencyToDependOnHost
}

// RemoveHostDependencyToDependOnHostIDs removes the "HostDependencyToDependOnHost" edge to the Host entity by IDs.
func (m *HostDependencyMutation) RemoveHostDependencyToDependOnHostIDs(ids ...int) {
	if m.removed_HostDependencyToDependOnHost == nil {
		m.removed_HostDependencyToDependOnHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostDependencyToDependOnHost[ids[i]] = struct{}{}
	}
}

// RemovedHostDependencyToDependOnHost returns the removed IDs of the "HostDependencyToDependOnHost" edge to the Host entity.
func (m *HostDependencyMutation) RemovedHostDependencyToDependOnHostIDs() (ids []int) {
	for id := range m.removed_HostDependencyToDependOnHost {
		ids = append(ids, id)
	}
	return
}

// HostDependencyToDependOnHostIDs returns the "HostDependencyToDependOnHost" edge IDs in the mutation.
func (m *HostDependencyMutation) HostDependencyToDependOnHostIDs() (ids []int) {
	for id := range m._HostDependencyToDependOnHost {
		ids = append(ids, id)
	}
	return
}

// ResetHostDependencyToDependOnHost resets all changes to the "HostDependencyToDependOnHost" edge.
func (m *HostDependencyMutation) ResetHostDependencyToDependOnHost() {
	m._HostDependencyToDependOnHost = nil
	m.cleared_HostDependencyToDependOnHost = false
	m.removed_HostDependencyToDependOnHost = nil
}

// AddHostDependencyToDependByHostIDs adds the "HostDependencyToDependByHost" edge to the Host entity by ids.
func (m *HostDependencyMutation) AddHostDependencyToDependByHostIDs(ids ...int) {
	if m._HostDependencyToDependByHost == nil {
		m._HostDependencyToDependByHost = make(map[int]struct{})
	}
	for i := range ids {
		m._HostDependencyToDependByHost[ids[i]] = struct{}{}
	}
}

// ClearHostDependencyToDependByHost clears the "HostDependencyToDependByHost" edge to the Host entity.
func (m *HostDependencyMutation) ClearHostDependencyToDependByHost() {
	m.cleared_HostDependencyToDependByHost = true
}

// HostDependencyToDependByHostCleared returns if the "HostDependencyToDependByHost" edge to the Host entity was cleared.
func (m *HostDependencyMutation) HostDependencyToDependByHostCleared() bool {
	return m.cleared_HostDependencyToDependByHost
}

// RemoveHostDependencyToDependByHostIDs removes the "HostDependencyToDependByHost" edge to the Host entity by IDs.
func (m *HostDependencyMutation) RemoveHostDependencyToDependByHostIDs(ids ...int) {
	if m.removed_HostDependencyToDependByHost == nil {
		m.removed_HostDependencyToDependByHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostDependencyToDependByHost[ids[i]] = struct{}{}
	}
}

// RemovedHostDependencyToDependByHost returns the removed IDs of the "HostDependencyToDependByHost" edge to the Host entity.
func (m *HostDependencyMutation) RemovedHostDependencyToDependByHostIDs() (ids []int) {
	for id := range m.removed_HostDependencyToDependByHost {
		ids = append(ids, id)
	}
	return
}

// HostDependencyToDependByHostIDs returns the "HostDependencyToDependByHost" edge IDs in the mutation.
func (m *HostDependencyMutation) HostDependencyToDependByHostIDs() (ids []int) {
	for id := range m._HostDependencyToDependByHost {
		ids = append(ids, id)
	}
	return
}

// ResetHostDependencyToDependByHost resets all changes to the "HostDependencyToDependByHost" edge.
func (m *HostDependencyMutation) ResetHostDependencyToDependByHost() {
	m._HostDependencyToDependByHost = nil
	m.cleared_HostDependencyToDependByHost = false
	m.removed_HostDependencyToDependByHost = nil
}

// AddHostDependencyToNetworkIDs adds the "HostDependencyToNetwork" edge to the Network entity by ids.
func (m *HostDependencyMutation) AddHostDependencyToNetworkIDs(ids ...int) {
	if m._HostDependencyToNetwork == nil {
		m._HostDependencyToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._HostDependencyToNetwork[ids[i]] = struct{}{}
	}
}

// ClearHostDependencyToNetwork clears the "HostDependencyToNetwork" edge to the Network entity.
func (m *HostDependencyMutation) ClearHostDependencyToNetwork() {
	m.cleared_HostDependencyToNetwork = true
}

// HostDependencyToNetworkCleared returns if the "HostDependencyToNetwork" edge to the Network entity was cleared.
func (m *HostDependencyMutation) HostDependencyToNetworkCleared() bool {
	return m.cleared_HostDependencyToNetwork
}

// RemoveHostDependencyToNetworkIDs removes the "HostDependencyToNetwork" edge to the Network entity by IDs.
func (m *HostDependencyMutation) RemoveHostDependencyToNetworkIDs(ids ...int) {
	if m.removed_HostDependencyToNetwork == nil {
		m.removed_HostDependencyToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostDependencyToNetwork[ids[i]] = struct{}{}
	}
}

// RemovedHostDependencyToNetwork returns the removed IDs of the "HostDependencyToNetwork" edge to the Network entity.
func (m *HostDependencyMutation) RemovedHostDependencyToNetworkIDs() (ids []int) {
	for id := range m.removed_HostDependencyToNetwork {
		ids = append(ids, id)
	}
	return
}

// HostDependencyToNetworkIDs returns the "HostDependencyToNetwork" edge IDs in the mutation.
func (m *HostDependencyMutation) HostDependencyToNetworkIDs() (ids []int) {
	for id := range m._HostDependencyToNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetHostDependencyToNetwork resets all changes to the "HostDependencyToNetwork" edge.
func (m *HostDependencyMutation) ResetHostDependencyToNetwork() {
	m._HostDependencyToNetwork = nil
	m.cleared_HostDependencyToNetwork = false
	m.removed_HostDependencyToNetwork = nil
}

// AddHostDependencyToEnvironmentIDs adds the "HostDependencyToEnvironment" edge to the Environment entity by ids.
func (m *HostDependencyMutation) AddHostDependencyToEnvironmentIDs(ids ...int) {
	if m._HostDependencyToEnvironment == nil {
		m._HostDependencyToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._HostDependencyToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearHostDependencyToEnvironment clears the "HostDependencyToEnvironment" edge to the Environment entity.
func (m *HostDependencyMutation) ClearHostDependencyToEnvironment() {
	m.cleared_HostDependencyToEnvironment = true
}

// HostDependencyToEnvironmentCleared returns if the "HostDependencyToEnvironment" edge to the Environment entity was cleared.
func (m *HostDependencyMutation) HostDependencyToEnvironmentCleared() bool {
	return m.cleared_HostDependencyToEnvironment
}

// RemoveHostDependencyToEnvironmentIDs removes the "HostDependencyToEnvironment" edge to the Environment entity by IDs.
func (m *HostDependencyMutation) RemoveHostDependencyToEnvironmentIDs(ids ...int) {
	if m.removed_HostDependencyToEnvironment == nil {
		m.removed_HostDependencyToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_HostDependencyToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedHostDependencyToEnvironment returns the removed IDs of the "HostDependencyToEnvironment" edge to the Environment entity.
func (m *HostDependencyMutation) RemovedHostDependencyToEnvironmentIDs() (ids []int) {
	for id := range m.removed_HostDependencyToEnvironment {
		ids = append(ids, id)
	}
	return
}

// HostDependencyToEnvironmentIDs returns the "HostDependencyToEnvironment" edge IDs in the mutation.
func (m *HostDependencyMutation) HostDependencyToEnvironmentIDs() (ids []int) {
	for id := range m._HostDependencyToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetHostDependencyToEnvironment resets all changes to the "HostDependencyToEnvironment" edge.
func (m *HostDependencyMutation) ResetHostDependencyToEnvironment() {
	m._HostDependencyToEnvironment = nil
	m.cleared_HostDependencyToEnvironment = false
	m.removed_HostDependencyToEnvironment = nil
}

// Op returns the operation name.
func (m *HostDependencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HostDependency).
func (m *HostDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostDependencyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.host_id != nil {
		fields = append(fields, hostdependency.FieldHostID)
	}
	if m.network_id != nil {
		fields = append(fields, hostdependency.FieldNetworkID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostdependency.FieldHostID:
		return m.HostID()
	case hostdependency.FieldNetworkID:
		return m.NetworkID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostdependency.FieldHostID:
		return m.OldHostID(ctx)
	case hostdependency.FieldNetworkID:
		return m.OldNetworkID(ctx)
	}
	return nil, fmt.Errorf("unknown HostDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostdependency.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case hostdependency.FieldNetworkID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkID(v)
		return nil
	}
	return fmt.Errorf("unknown HostDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HostDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HostDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostDependencyMutation) ResetField(name string) error {
	switch name {
	case hostdependency.FieldHostID:
		m.ResetHostID()
		return nil
	case hostdependency.FieldNetworkID:
		m.ResetNetworkID()
		return nil
	}
	return fmt.Errorf("unknown HostDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._HostDependencyToDependOnHost != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependOnHost)
	}
	if m._HostDependencyToDependByHost != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependByHost)
	}
	if m._HostDependencyToNetwork != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToNetwork)
	}
	if m._HostDependencyToEnvironment != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		ids := make([]ent.Value, 0, len(m._HostDependencyToDependOnHost))
		for id := range m._HostDependencyToDependOnHost {
			ids = append(ids, id)
		}
		return ids
	case hostdependency.EdgeHostDependencyToDependByHost:
		ids := make([]ent.Value, 0, len(m._HostDependencyToDependByHost))
		for id := range m._HostDependencyToDependByHost {
			ids = append(ids, id)
		}
		return ids
	case hostdependency.EdgeHostDependencyToNetwork:
		ids := make([]ent.Value, 0, len(m._HostDependencyToNetwork))
		for id := range m._HostDependencyToNetwork {
			ids = append(ids, id)
		}
		return ids
	case hostdependency.EdgeHostDependencyToEnvironment:
		ids := make([]ent.Value, 0, len(m._HostDependencyToEnvironment))
		for id := range m._HostDependencyToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_HostDependencyToDependOnHost != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependOnHost)
	}
	if m.removed_HostDependencyToDependByHost != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependByHost)
	}
	if m.removed_HostDependencyToNetwork != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToNetwork)
	}
	if m.removed_HostDependencyToEnvironment != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostDependencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		ids := make([]ent.Value, 0, len(m.removed_HostDependencyToDependOnHost))
		for id := range m.removed_HostDependencyToDependOnHost {
			ids = append(ids, id)
		}
		return ids
	case hostdependency.EdgeHostDependencyToDependByHost:
		ids := make([]ent.Value, 0, len(m.removed_HostDependencyToDependByHost))
		for id := range m.removed_HostDependencyToDependByHost {
			ids = append(ids, id)
		}
		return ids
	case hostdependency.EdgeHostDependencyToNetwork:
		ids := make([]ent.Value, 0, len(m.removed_HostDependencyToNetwork))
		for id := range m.removed_HostDependencyToNetwork {
			ids = append(ids, id)
		}
		return ids
	case hostdependency.EdgeHostDependencyToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_HostDependencyToEnvironment))
		for id := range m.removed_HostDependencyToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_HostDependencyToDependOnHost {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependOnHost)
	}
	if m.cleared_HostDependencyToDependByHost {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependByHost)
	}
	if m.cleared_HostDependencyToNetwork {
		edges = append(edges, hostdependency.EdgeHostDependencyToNetwork)
	}
	if m.cleared_HostDependencyToEnvironment {
		edges = append(edges, hostdependency.EdgeHostDependencyToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		return m.cleared_HostDependencyToDependOnHost
	case hostdependency.EdgeHostDependencyToDependByHost:
		return m.cleared_HostDependencyToDependByHost
	case hostdependency.EdgeHostDependencyToNetwork:
		return m.cleared_HostDependencyToNetwork
	case hostdependency.EdgeHostDependencyToEnvironment:
		return m.cleared_HostDependencyToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostDependencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HostDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostDependencyMutation) ResetEdge(name string) error {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		m.ResetHostDependencyToDependOnHost()
		return nil
	case hostdependency.EdgeHostDependencyToDependByHost:
		m.ResetHostDependencyToDependByHost()
		return nil
	case hostdependency.EdgeHostDependencyToNetwork:
		m.ResetHostDependencyToNetwork()
		return nil
	case hostdependency.EdgeHostDependencyToEnvironment:
		m.ResetHostDependencyToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown HostDependency edge %s", name)
}

// IdentityMutation represents an operation that mutates the Identity nodes in the graph.
type IdentityMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	hcl_id                        *string
	first_name                    *string
	last_name                     *string
	email                         *string
	password                      *string
	description                   *string
	avatar_file                   *string
	vars                          *map[string]string
	tags                          *map[string]string
	clearedFields                 map[string]struct{}
	_IdentityToEnvironment        map[int]struct{}
	removed_IdentityToEnvironment map[int]struct{}
	cleared_IdentityToEnvironment bool
	done                          bool
	oldValue                      func(context.Context) (*Identity, error)
	predicates                    []predicate.Identity
}

var _ ent.Mutation = (*IdentityMutation)(nil)

// identityOption allows management of the mutation configuration using functional options.
type identityOption func(*IdentityMutation)

// newIdentityMutation creates new mutation for the Identity entity.
func newIdentityMutation(c config, op Op, opts ...identityOption) *IdentityMutation {
	m := &IdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityID sets the ID field of the mutation.
func withIdentityID(id int) identityOption {
	return func(m *IdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *Identity
		)
		m.oldValue = func(ctx context.Context) (*Identity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Identity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentity sets the old Identity of the mutation.
func withIdentity(node *Identity) identityOption {
	return func(m *IdentityMutation) {
		m.oldValue = func(context.Context) (*Identity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *IdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *IdentityMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *IdentityMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *IdentityMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetFirstName sets the "first_name" field.
func (m *IdentityMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *IdentityMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *IdentityMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *IdentityMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *IdentityMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *IdentityMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *IdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *IdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *IdentityMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *IdentityMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *IdentityMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *IdentityMutation) ResetPassword() {
	m.password = nil
}

// SetDescription sets the "description" field.
func (m *IdentityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IdentityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IdentityMutation) ResetDescription() {
	m.description = nil
}

// SetAvatarFile sets the "avatar_file" field.
func (m *IdentityMutation) SetAvatarFile(s string) {
	m.avatar_file = &s
}

// AvatarFile returns the value of the "avatar_file" field in the mutation.
func (m *IdentityMutation) AvatarFile() (r string, exists bool) {
	v := m.avatar_file
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarFile returns the old "avatar_file" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldAvatarFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarFile: %w", err)
	}
	return oldValue.AvatarFile, nil
}

// ResetAvatarFile resets all changes to the "avatar_file" field.
func (m *IdentityMutation) ResetAvatarFile() {
	m.avatar_file = nil
}

// SetVars sets the "vars" field.
func (m *IdentityMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *IdentityMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *IdentityMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *IdentityMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IdentityMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *IdentityMutation) ResetTags() {
	m.tags = nil
}

// AddIdentityToEnvironmentIDs adds the "IdentityToEnvironment" edge to the Environment entity by ids.
func (m *IdentityMutation) AddIdentityToEnvironmentIDs(ids ...int) {
	if m._IdentityToEnvironment == nil {
		m._IdentityToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._IdentityToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearIdentityToEnvironment clears the "IdentityToEnvironment" edge to the Environment entity.
func (m *IdentityMutation) ClearIdentityToEnvironment() {
	m.cleared_IdentityToEnvironment = true
}

// IdentityToEnvironmentCleared returns if the "IdentityToEnvironment" edge to the Environment entity was cleared.
func (m *IdentityMutation) IdentityToEnvironmentCleared() bool {
	return m.cleared_IdentityToEnvironment
}

// RemoveIdentityToEnvironmentIDs removes the "IdentityToEnvironment" edge to the Environment entity by IDs.
func (m *IdentityMutation) RemoveIdentityToEnvironmentIDs(ids ...int) {
	if m.removed_IdentityToEnvironment == nil {
		m.removed_IdentityToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_IdentityToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedIdentityToEnvironment returns the removed IDs of the "IdentityToEnvironment" edge to the Environment entity.
func (m *IdentityMutation) RemovedIdentityToEnvironmentIDs() (ids []int) {
	for id := range m.removed_IdentityToEnvironment {
		ids = append(ids, id)
	}
	return
}

// IdentityToEnvironmentIDs returns the "IdentityToEnvironment" edge IDs in the mutation.
func (m *IdentityMutation) IdentityToEnvironmentIDs() (ids []int) {
	for id := range m._IdentityToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetIdentityToEnvironment resets all changes to the "IdentityToEnvironment" edge.
func (m *IdentityMutation) ResetIdentityToEnvironment() {
	m._IdentityToEnvironment = nil
	m.cleared_IdentityToEnvironment = false
	m.removed_IdentityToEnvironment = nil
}

// Op returns the operation name.
func (m *IdentityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Identity).
func (m *IdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hcl_id != nil {
		fields = append(fields, identity.FieldHclID)
	}
	if m.first_name != nil {
		fields = append(fields, identity.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, identity.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, identity.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, identity.FieldPassword)
	}
	if m.description != nil {
		fields = append(fields, identity.FieldDescription)
	}
	if m.avatar_file != nil {
		fields = append(fields, identity.FieldAvatarFile)
	}
	if m.vars != nil {
		fields = append(fields, identity.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, identity.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identity.FieldHclID:
		return m.HclID()
	case identity.FieldFirstName:
		return m.FirstName()
	case identity.FieldLastName:
		return m.LastName()
	case identity.FieldEmail:
		return m.Email()
	case identity.FieldPassword:
		return m.Password()
	case identity.FieldDescription:
		return m.Description()
	case identity.FieldAvatarFile:
		return m.AvatarFile()
	case identity.FieldVars:
		return m.Vars()
	case identity.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identity.FieldHclID:
		return m.OldHclID(ctx)
	case identity.FieldFirstName:
		return m.OldFirstName(ctx)
	case identity.FieldLastName:
		return m.OldLastName(ctx)
	case identity.FieldEmail:
		return m.OldEmail(ctx)
	case identity.FieldPassword:
		return m.OldPassword(ctx)
	case identity.FieldDescription:
		return m.OldDescription(ctx)
	case identity.FieldAvatarFile:
		return m.OldAvatarFile(ctx)
	case identity.FieldVars:
		return m.OldVars(ctx)
	case identity.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Identity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identity.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case identity.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case identity.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case identity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case identity.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case identity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case identity.FieldAvatarFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarFile(v)
		return nil
	case identity.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case identity.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Identity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Identity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityMutation) ResetField(name string) error {
	switch name {
	case identity.FieldHclID:
		m.ResetHclID()
		return nil
	case identity.FieldFirstName:
		m.ResetFirstName()
		return nil
	case identity.FieldLastName:
		m.ResetLastName()
		return nil
	case identity.FieldEmail:
		m.ResetEmail()
		return nil
	case identity.FieldPassword:
		m.ResetPassword()
		return nil
	case identity.FieldDescription:
		m.ResetDescription()
		return nil
	case identity.FieldAvatarFile:
		m.ResetAvatarFile()
		return nil
	case identity.FieldVars:
		m.ResetVars()
		return nil
	case identity.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._IdentityToEnvironment != nil {
		edges = append(edges, identity.EdgeIdentityToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		ids := make([]ent.Value, 0, len(m._IdentityToEnvironment))
		for id := range m._IdentityToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_IdentityToEnvironment != nil {
		edges = append(edges, identity.EdgeIdentityToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_IdentityToEnvironment))
		for id := range m.removed_IdentityToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_IdentityToEnvironment {
		edges = append(edges, identity.EdgeIdentityToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		return m.cleared_IdentityToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Identity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityMutation) ResetEdge(name string) error {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		m.ResetIdentityToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Identity edge %s", name)
}

// IncludedNetworkMutation represents an operation that mutates the IncludedNetwork nodes in the graph.
type IncludedNetworkMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	name                                 *string
	hosts                                *[]string
	clearedFields                        map[string]struct{}
	_IncludedNetworkToTag                map[int]struct{}
	removed_IncludedNetworkToTag         map[int]struct{}
	cleared_IncludedNetworkToTag         bool
	_IncludedNetworkToHost               map[int]struct{}
	removed_IncludedNetworkToHost        map[int]struct{}
	cleared_IncludedNetworkToHost        bool
	_IncludedNetworkToNetwork            map[int]struct{}
	removed_IncludedNetworkToNetwork     map[int]struct{}
	cleared_IncludedNetworkToNetwork     bool
	_IncludedNetworkToEnvironment        map[int]struct{}
	removed_IncludedNetworkToEnvironment map[int]struct{}
	cleared_IncludedNetworkToEnvironment bool
	done                                 bool
	oldValue                             func(context.Context) (*IncludedNetwork, error)
	predicates                           []predicate.IncludedNetwork
}

var _ ent.Mutation = (*IncludedNetworkMutation)(nil)

// includednetworkOption allows management of the mutation configuration using functional options.
type includednetworkOption func(*IncludedNetworkMutation)

// newIncludedNetworkMutation creates new mutation for the IncludedNetwork entity.
func newIncludedNetworkMutation(c config, op Op, opts ...includednetworkOption) *IncludedNetworkMutation {
	m := &IncludedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeIncludedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncludedNetworkID sets the ID field of the mutation.
func withIncludedNetworkID(id int) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *IncludedNetwork
		)
		m.oldValue = func(ctx context.Context) (*IncludedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncludedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncludedNetwork sets the old IncludedNetwork of the mutation.
func withIncludedNetwork(node *IncludedNetwork) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		m.oldValue = func(context.Context) (*IncludedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncludedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncludedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *IncludedNetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *IncludedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncludedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncludedNetwork entity.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncludedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncludedNetworkMutation) ResetName() {
	m.name = nil
}

// SetHosts sets the "hosts" field.
func (m *IncludedNetworkMutation) SetHosts(s []string) {
	m.hosts = &s
}

// Hosts returns the value of the "hosts" field in the mutation.
func (m *IncludedNetworkMutation) Hosts() (r []string, exists bool) {
	v := m.hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldHosts returns the old "hosts" field's value of the IncludedNetwork entity.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncludedNetworkMutation) OldHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHosts: %w", err)
	}
	return oldValue.Hosts, nil
}

// ResetHosts resets all changes to the "hosts" field.
func (m *IncludedNetworkMutation) ResetHosts() {
	m.hosts = nil
}

// AddIncludedNetworkToTagIDs adds the "IncludedNetworkToTag" edge to the Tag entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToTagIDs(ids ...int) {
	if m._IncludedNetworkToTag == nil {
		m._IncludedNetworkToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToTag[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToTag clears the "IncludedNetworkToTag" edge to the Tag entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToTag() {
	m.cleared_IncludedNetworkToTag = true
}

// IncludedNetworkToTagCleared returns if the "IncludedNetworkToTag" edge to the Tag entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToTagCleared() bool {
	return m.cleared_IncludedNetworkToTag
}

// RemoveIncludedNetworkToTagIDs removes the "IncludedNetworkToTag" edge to the Tag entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToTagIDs(ids ...int) {
	if m.removed_IncludedNetworkToTag == nil {
		m.removed_IncludedNetworkToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_IncludedNetworkToTag[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToTag returns the removed IDs of the "IncludedNetworkToTag" edge to the Tag entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToTagIDs() (ids []int) {
	for id := range m.removed_IncludedNetworkToTag {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToTagIDs returns the "IncludedNetworkToTag" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToTagIDs() (ids []int) {
	for id := range m._IncludedNetworkToTag {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToTag resets all changes to the "IncludedNetworkToTag" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToTag() {
	m._IncludedNetworkToTag = nil
	m.cleared_IncludedNetworkToTag = false
	m.removed_IncludedNetworkToTag = nil
}

// AddIncludedNetworkToHostIDs adds the "IncludedNetworkToHost" edge to the Host entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToHostIDs(ids ...int) {
	if m._IncludedNetworkToHost == nil {
		m._IncludedNetworkToHost = make(map[int]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToHost[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToHost clears the "IncludedNetworkToHost" edge to the Host entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToHost() {
	m.cleared_IncludedNetworkToHost = true
}

// IncludedNetworkToHostCleared returns if the "IncludedNetworkToHost" edge to the Host entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToHostCleared() bool {
	return m.cleared_IncludedNetworkToHost
}

// RemoveIncludedNetworkToHostIDs removes the "IncludedNetworkToHost" edge to the Host entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToHostIDs(ids ...int) {
	if m.removed_IncludedNetworkToHost == nil {
		m.removed_IncludedNetworkToHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_IncludedNetworkToHost[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToHost returns the removed IDs of the "IncludedNetworkToHost" edge to the Host entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToHostIDs() (ids []int) {
	for id := range m.removed_IncludedNetworkToHost {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToHostIDs returns the "IncludedNetworkToHost" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToHostIDs() (ids []int) {
	for id := range m._IncludedNetworkToHost {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToHost resets all changes to the "IncludedNetworkToHost" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToHost() {
	m._IncludedNetworkToHost = nil
	m.cleared_IncludedNetworkToHost = false
	m.removed_IncludedNetworkToHost = nil
}

// AddIncludedNetworkToNetworkIDs adds the "IncludedNetworkToNetwork" edge to the Network entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToNetworkIDs(ids ...int) {
	if m._IncludedNetworkToNetwork == nil {
		m._IncludedNetworkToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToNetwork[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToNetwork clears the "IncludedNetworkToNetwork" edge to the Network entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToNetwork() {
	m.cleared_IncludedNetworkToNetwork = true
}

// IncludedNetworkToNetworkCleared returns if the "IncludedNetworkToNetwork" edge to the Network entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToNetworkCleared() bool {
	return m.cleared_IncludedNetworkToNetwork
}

// RemoveIncludedNetworkToNetworkIDs removes the "IncludedNetworkToNetwork" edge to the Network entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToNetworkIDs(ids ...int) {
	if m.removed_IncludedNetworkToNetwork == nil {
		m.removed_IncludedNetworkToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_IncludedNetworkToNetwork[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToNetwork returns the removed IDs of the "IncludedNetworkToNetwork" edge to the Network entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToNetworkIDs() (ids []int) {
	for id := range m.removed_IncludedNetworkToNetwork {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToNetworkIDs returns the "IncludedNetworkToNetwork" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToNetworkIDs() (ids []int) {
	for id := range m._IncludedNetworkToNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToNetwork resets all changes to the "IncludedNetworkToNetwork" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToNetwork() {
	m._IncludedNetworkToNetwork = nil
	m.cleared_IncludedNetworkToNetwork = false
	m.removed_IncludedNetworkToNetwork = nil
}

// AddIncludedNetworkToEnvironmentIDs adds the "IncludedNetworkToEnvironment" edge to the Environment entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToEnvironmentIDs(ids ...int) {
	if m._IncludedNetworkToEnvironment == nil {
		m._IncludedNetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToEnvironment clears the "IncludedNetworkToEnvironment" edge to the Environment entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToEnvironment() {
	m.cleared_IncludedNetworkToEnvironment = true
}

// IncludedNetworkToEnvironmentCleared returns if the "IncludedNetworkToEnvironment" edge to the Environment entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToEnvironmentCleared() bool {
	return m.cleared_IncludedNetworkToEnvironment
}

// RemoveIncludedNetworkToEnvironmentIDs removes the "IncludedNetworkToEnvironment" edge to the Environment entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToEnvironmentIDs(ids ...int) {
	if m.removed_IncludedNetworkToEnvironment == nil {
		m.removed_IncludedNetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_IncludedNetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToEnvironment returns the removed IDs of the "IncludedNetworkToEnvironment" edge to the Environment entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToEnvironmentIDs() (ids []int) {
	for id := range m.removed_IncludedNetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToEnvironmentIDs returns the "IncludedNetworkToEnvironment" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToEnvironmentIDs() (ids []int) {
	for id := range m._IncludedNetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToEnvironment resets all changes to the "IncludedNetworkToEnvironment" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToEnvironment() {
	m._IncludedNetworkToEnvironment = nil
	m.cleared_IncludedNetworkToEnvironment = false
	m.removed_IncludedNetworkToEnvironment = nil
}

// Op returns the operation name.
func (m *IncludedNetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (IncludedNetwork).
func (m *IncludedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncludedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, includednetwork.FieldName)
	}
	if m.hosts != nil {
		fields = append(fields, includednetwork.FieldHosts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncludedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case includednetwork.FieldName:
		return m.Name()
	case includednetwork.FieldHosts:
		return m.Hosts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncludedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case includednetwork.FieldName:
		return m.OldName(ctx)
	case includednetwork.FieldHosts:
		return m.OldHosts(ctx)
	}
	return nil, fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncludedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case includednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case includednetwork.FieldHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHosts(v)
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncludedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncludedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncludedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncludedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncludedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncludedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncludedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ResetField(name string) error {
	switch name {
	case includednetwork.FieldName:
		m.ResetName()
		return nil
	case includednetwork.FieldHosts:
		m.ResetHosts()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncludedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._IncludedNetworkToTag != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToTag)
	}
	if m._IncludedNetworkToHost != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToHost)
	}
	if m._IncludedNetworkToNetwork != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToNetwork)
	}
	if m._IncludedNetworkToEnvironment != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncludedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToTag))
		for id := range m._IncludedNetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToHost:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToHost))
		for id := range m._IncludedNetworkToHost {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToNetwork:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToNetwork))
		for id := range m._IncludedNetworkToNetwork {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToEnvironment))
		for id := range m._IncludedNetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncludedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_IncludedNetworkToTag != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToTag)
	}
	if m.removed_IncludedNetworkToHost != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToHost)
	}
	if m.removed_IncludedNetworkToNetwork != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToNetwork)
	}
	if m.removed_IncludedNetworkToEnvironment != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncludedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToTag))
		for id := range m.removed_IncludedNetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToHost:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToHost))
		for id := range m.removed_IncludedNetworkToHost {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToNetwork:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToNetwork))
		for id := range m.removed_IncludedNetworkToNetwork {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToEnvironment))
		for id := range m.removed_IncludedNetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncludedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_IncludedNetworkToTag {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToTag)
	}
	if m.cleared_IncludedNetworkToHost {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToHost)
	}
	if m.cleared_IncludedNetworkToNetwork {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToNetwork)
	}
	if m.cleared_IncludedNetworkToEnvironment {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncludedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		return m.cleared_IncludedNetworkToTag
	case includednetwork.EdgeIncludedNetworkToHost:
		return m.cleared_IncludedNetworkToHost
	case includednetwork.EdgeIncludedNetworkToNetwork:
		return m.cleared_IncludedNetworkToNetwork
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		return m.cleared_IncludedNetworkToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncludedNetworkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IncludedNetwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncludedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		m.ResetIncludedNetworkToTag()
		return nil
	case includednetwork.EdgeIncludedNetworkToHost:
		m.ResetIncludedNetworkToHost()
		return nil
	case includednetwork.EdgeIncludedNetworkToNetwork:
		m.ResetIncludedNetworkToNetwork()
		return nil
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		m.ResetIncludedNetworkToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork edge %s", name)
}

// NetworkMutation represents an operation that mutates the Network nodes in the graph.
type NetworkMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	hcl_id                           *string
	name                             *string
	cidr                             *string
	vdi_visible                      *bool
	vars                             *map[string]string
	tags                             *map[string]string
	clearedFields                    map[string]struct{}
	_NetworkToTag                    map[int]struct{}
	removed_NetworkToTag             map[int]struct{}
	cleared_NetworkToTag             bool
	_NetworkToEnvironment            map[int]struct{}
	removed_NetworkToEnvironment     map[int]struct{}
	cleared_NetworkToEnvironment     bool
	_NetworkToHostDependency         map[int]struct{}
	removed_NetworkToHostDependency  map[int]struct{}
	cleared_NetworkToHostDependency  bool
	_NetworkToIncludedNetwork        map[int]struct{}
	removed_NetworkToIncludedNetwork map[int]struct{}
	cleared_NetworkToIncludedNetwork bool
	done                             bool
	oldValue                         func(context.Context) (*Network, error)
	predicates                       []predicate.Network
}

var _ ent.Mutation = (*NetworkMutation)(nil)

// networkOption allows management of the mutation configuration using functional options.
type networkOption func(*NetworkMutation)

// newNetworkMutation creates new mutation for the Network entity.
func newNetworkMutation(c config, op Op, opts ...networkOption) *NetworkMutation {
	m := &NetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkID sets the ID field of the mutation.
func withNetworkID(id int) networkOption {
	return func(m *NetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Network
		)
		m.oldValue = func(ctx context.Context) (*Network, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Network.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetwork sets the old Network of the mutation.
func withNetwork(node *Network) networkOption {
	return func(m *NetworkMutation) {
		m.oldValue = func(context.Context) (*Network, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *NetworkMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *NetworkMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *NetworkMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *NetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *NetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *NetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *NetworkMutation) ResetCidr() {
	m.cidr = nil
}

// SetVdiVisible sets the "vdi_visible" field.
func (m *NetworkMutation) SetVdiVisible(b bool) {
	m.vdi_visible = &b
}

// VdiVisible returns the value of the "vdi_visible" field in the mutation.
func (m *NetworkMutation) VdiVisible() (r bool, exists bool) {
	v := m.vdi_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVdiVisible returns the old "vdi_visible" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldVdiVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVdiVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVdiVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVdiVisible: %w", err)
	}
	return oldValue.VdiVisible, nil
}

// ResetVdiVisible resets all changes to the "vdi_visible" field.
func (m *NetworkMutation) ResetVdiVisible() {
	m.vdi_visible = nil
}

// SetVars sets the "vars" field.
func (m *NetworkMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *NetworkMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *NetworkMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *NetworkMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NetworkMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *NetworkMutation) ResetTags() {
	m.tags = nil
}

// AddNetworkToTagIDs adds the "NetworkToTag" edge to the Tag entity by ids.
func (m *NetworkMutation) AddNetworkToTagIDs(ids ...int) {
	if m._NetworkToTag == nil {
		m._NetworkToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._NetworkToTag[ids[i]] = struct{}{}
	}
}

// ClearNetworkToTag clears the "NetworkToTag" edge to the Tag entity.
func (m *NetworkMutation) ClearNetworkToTag() {
	m.cleared_NetworkToTag = true
}

// NetworkToTagCleared returns if the "NetworkToTag" edge to the Tag entity was cleared.
func (m *NetworkMutation) NetworkToTagCleared() bool {
	return m.cleared_NetworkToTag
}

// RemoveNetworkToTagIDs removes the "NetworkToTag" edge to the Tag entity by IDs.
func (m *NetworkMutation) RemoveNetworkToTagIDs(ids ...int) {
	if m.removed_NetworkToTag == nil {
		m.removed_NetworkToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NetworkToTag[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToTag returns the removed IDs of the "NetworkToTag" edge to the Tag entity.
func (m *NetworkMutation) RemovedNetworkToTagIDs() (ids []int) {
	for id := range m.removed_NetworkToTag {
		ids = append(ids, id)
	}
	return
}

// NetworkToTagIDs returns the "NetworkToTag" edge IDs in the mutation.
func (m *NetworkMutation) NetworkToTagIDs() (ids []int) {
	for id := range m._NetworkToTag {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToTag resets all changes to the "NetworkToTag" edge.
func (m *NetworkMutation) ResetNetworkToTag() {
	m._NetworkToTag = nil
	m.cleared_NetworkToTag = false
	m.removed_NetworkToTag = nil
}

// AddNetworkToEnvironmentIDs adds the "NetworkToEnvironment" edge to the Environment entity by ids.
func (m *NetworkMutation) AddNetworkToEnvironmentIDs(ids ...int) {
	if m._NetworkToEnvironment == nil {
		m._NetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._NetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearNetworkToEnvironment clears the "NetworkToEnvironment" edge to the Environment entity.
func (m *NetworkMutation) ClearNetworkToEnvironment() {
	m.cleared_NetworkToEnvironment = true
}

// NetworkToEnvironmentCleared returns if the "NetworkToEnvironment" edge to the Environment entity was cleared.
func (m *NetworkMutation) NetworkToEnvironmentCleared() bool {
	return m.cleared_NetworkToEnvironment
}

// RemoveNetworkToEnvironmentIDs removes the "NetworkToEnvironment" edge to the Environment entity by IDs.
func (m *NetworkMutation) RemoveNetworkToEnvironmentIDs(ids ...int) {
	if m.removed_NetworkToEnvironment == nil {
		m.removed_NetworkToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToEnvironment returns the removed IDs of the "NetworkToEnvironment" edge to the Environment entity.
func (m *NetworkMutation) RemovedNetworkToEnvironmentIDs() (ids []int) {
	for id := range m.removed_NetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// NetworkToEnvironmentIDs returns the "NetworkToEnvironment" edge IDs in the mutation.
func (m *NetworkMutation) NetworkToEnvironmentIDs() (ids []int) {
	for id := range m._NetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToEnvironment resets all changes to the "NetworkToEnvironment" edge.
func (m *NetworkMutation) ResetNetworkToEnvironment() {
	m._NetworkToEnvironment = nil
	m.cleared_NetworkToEnvironment = false
	m.removed_NetworkToEnvironment = nil
}

// AddNetworkToHostDependencyIDs adds the "NetworkToHostDependency" edge to the HostDependency entity by ids.
func (m *NetworkMutation) AddNetworkToHostDependencyIDs(ids ...int) {
	if m._NetworkToHostDependency == nil {
		m._NetworkToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m._NetworkToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearNetworkToHostDependency clears the "NetworkToHostDependency" edge to the HostDependency entity.
func (m *NetworkMutation) ClearNetworkToHostDependency() {
	m.cleared_NetworkToHostDependency = true
}

// NetworkToHostDependencyCleared returns if the "NetworkToHostDependency" edge to the HostDependency entity was cleared.
func (m *NetworkMutation) NetworkToHostDependencyCleared() bool {
	return m.cleared_NetworkToHostDependency
}

// RemoveNetworkToHostDependencyIDs removes the "NetworkToHostDependency" edge to the HostDependency entity by IDs.
func (m *NetworkMutation) RemoveNetworkToHostDependencyIDs(ids ...int) {
	if m.removed_NetworkToHostDependency == nil {
		m.removed_NetworkToHostDependency = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NetworkToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToHostDependency returns the removed IDs of the "NetworkToHostDependency" edge to the HostDependency entity.
func (m *NetworkMutation) RemovedNetworkToHostDependencyIDs() (ids []int) {
	for id := range m.removed_NetworkToHostDependency {
		ids = append(ids, id)
	}
	return
}

// NetworkToHostDependencyIDs returns the "NetworkToHostDependency" edge IDs in the mutation.
func (m *NetworkMutation) NetworkToHostDependencyIDs() (ids []int) {
	for id := range m._NetworkToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToHostDependency resets all changes to the "NetworkToHostDependency" edge.
func (m *NetworkMutation) ResetNetworkToHostDependency() {
	m._NetworkToHostDependency = nil
	m.cleared_NetworkToHostDependency = false
	m.removed_NetworkToHostDependency = nil
}

// AddNetworkToIncludedNetworkIDs adds the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity by ids.
func (m *NetworkMutation) AddNetworkToIncludedNetworkIDs(ids ...int) {
	if m._NetworkToIncludedNetwork == nil {
		m._NetworkToIncludedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._NetworkToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// ClearNetworkToIncludedNetwork clears the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *NetworkMutation) ClearNetworkToIncludedNetwork() {
	m.cleared_NetworkToIncludedNetwork = true
}

// NetworkToIncludedNetworkCleared returns if the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity was cleared.
func (m *NetworkMutation) NetworkToIncludedNetworkCleared() bool {
	return m.cleared_NetworkToIncludedNetwork
}

// RemoveNetworkToIncludedNetworkIDs removes the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity by IDs.
func (m *NetworkMutation) RemoveNetworkToIncludedNetworkIDs(ids ...int) {
	if m.removed_NetworkToIncludedNetwork == nil {
		m.removed_NetworkToIncludedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_NetworkToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToIncludedNetwork returns the removed IDs of the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *NetworkMutation) RemovedNetworkToIncludedNetworkIDs() (ids []int) {
	for id := range m.removed_NetworkToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// NetworkToIncludedNetworkIDs returns the "NetworkToIncludedNetwork" edge IDs in the mutation.
func (m *NetworkMutation) NetworkToIncludedNetworkIDs() (ids []int) {
	for id := range m._NetworkToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToIncludedNetwork resets all changes to the "NetworkToIncludedNetwork" edge.
func (m *NetworkMutation) ResetNetworkToIncludedNetwork() {
	m._NetworkToIncludedNetwork = nil
	m.cleared_NetworkToIncludedNetwork = false
	m.removed_NetworkToIncludedNetwork = nil
}

// Op returns the operation name.
func (m *NetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Network).
func (m *NetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, network.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, network.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, network.FieldCidr)
	}
	if m.vdi_visible != nil {
		fields = append(fields, network.FieldVdiVisible)
	}
	if m.vars != nil {
		fields = append(fields, network.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, network.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case network.FieldHclID:
		return m.HclID()
	case network.FieldName:
		return m.Name()
	case network.FieldCidr:
		return m.Cidr()
	case network.FieldVdiVisible:
		return m.VdiVisible()
	case network.FieldVars:
		return m.Vars()
	case network.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case network.FieldHclID:
		return m.OldHclID(ctx)
	case network.FieldName:
		return m.OldName(ctx)
	case network.FieldCidr:
		return m.OldCidr(ctx)
	case network.FieldVdiVisible:
		return m.OldVdiVisible(ctx)
	case network.FieldVars:
		return m.OldVars(ctx)
	case network.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Network field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case network.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case network.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case network.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case network.FieldVdiVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVdiVisible(v)
		return nil
	case network.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case network.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Network numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Network nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkMutation) ResetField(name string) error {
	switch name {
	case network.FieldHclID:
		m.ResetHclID()
		return nil
	case network.FieldName:
		m.ResetName()
		return nil
	case network.FieldCidr:
		m.ResetCidr()
		return nil
	case network.FieldVdiVisible:
		m.ResetVdiVisible()
		return nil
	case network.FieldVars:
		m.ResetVars()
		return nil
	case network.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._NetworkToTag != nil {
		edges = append(edges, network.EdgeNetworkToTag)
	}
	if m._NetworkToEnvironment != nil {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	if m._NetworkToHostDependency != nil {
		edges = append(edges, network.EdgeNetworkToHostDependency)
	}
	if m._NetworkToIncludedNetwork != nil {
		edges = append(edges, network.EdgeNetworkToIncludedNetwork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeNetworkToTag:
		ids := make([]ent.Value, 0, len(m._NetworkToTag))
		for id := range m._NetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m._NetworkToEnvironment))
		for id := range m._NetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToHostDependency:
		ids := make([]ent.Value, 0, len(m._NetworkToHostDependency))
		for id := range m._NetworkToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m._NetworkToIncludedNetwork))
		for id := range m._NetworkToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_NetworkToTag != nil {
		edges = append(edges, network.EdgeNetworkToTag)
	}
	if m.removed_NetworkToEnvironment != nil {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	if m.removed_NetworkToHostDependency != nil {
		edges = append(edges, network.EdgeNetworkToHostDependency)
	}
	if m.removed_NetworkToIncludedNetwork != nil {
		edges = append(edges, network.EdgeNetworkToIncludedNetwork)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeNetworkToTag:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToTag))
		for id := range m.removed_NetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToEnvironment))
		for id := range m.removed_NetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToHostDependency))
		for id := range m.removed_NetworkToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToIncludedNetwork))
		for id := range m.removed_NetworkToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_NetworkToTag {
		edges = append(edges, network.EdgeNetworkToTag)
	}
	if m.cleared_NetworkToEnvironment {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	if m.cleared_NetworkToHostDependency {
		edges = append(edges, network.EdgeNetworkToHostDependency)
	}
	if m.cleared_NetworkToIncludedNetwork {
		edges = append(edges, network.EdgeNetworkToIncludedNetwork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case network.EdgeNetworkToTag:
		return m.cleared_NetworkToTag
	case network.EdgeNetworkToEnvironment:
		return m.cleared_NetworkToEnvironment
	case network.EdgeNetworkToHostDependency:
		return m.cleared_NetworkToHostDependency
	case network.EdgeNetworkToIncludedNetwork:
		return m.cleared_NetworkToIncludedNetwork
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Network unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkMutation) ResetEdge(name string) error {
	switch name {
	case network.EdgeNetworkToTag:
		m.ResetNetworkToTag()
		return nil
	case network.EdgeNetworkToEnvironment:
		m.ResetNetworkToEnvironment()
		return nil
	case network.EdgeNetworkToHostDependency:
		m.ResetNetworkToHostDependency()
		return nil
	case network.EdgeNetworkToIncludedNetwork:
		m.ResetNetworkToIncludedNetwork()
		return nil
	}
	return fmt.Errorf("unknown Network edge %s", name)
}

// ProvisionedHostMutation represents an operation that mutates the ProvisionedHost nodes in the graph.
type ProvisionedHostMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	subnet_ip                                   *string
	clearedFields                               map[string]struct{}
	_ProvisionedHostToTag                       map[int]struct{}
	removed_ProvisionedHostToTag                map[int]struct{}
	cleared_ProvisionedHostToTag                bool
	_ProvisionedHostToStatus                    map[int]struct{}
	removed_ProvisionedHostToStatus             map[int]struct{}
	cleared_ProvisionedHostToStatus             bool
	_ProvisionedHostToProvisionedNetwork        map[int]struct{}
	removed_ProvisionedHostToProvisionedNetwork map[int]struct{}
	cleared_ProvisionedHostToProvisionedNetwork bool
	_ProvisionedHostToHost                      map[int]struct{}
	removed_ProvisionedHostToHost               map[int]struct{}
	cleared_ProvisionedHostToHost               bool
	_ProvisionedHostToProvisioningStep          map[int]struct{}
	removed_ProvisionedHostToProvisioningStep   map[int]struct{}
	cleared_ProvisionedHostToProvisioningStep   bool
	_ProvisionedHostToAgentStatus               map[int]struct{}
	removed_ProvisionedHostToAgentStatus        map[int]struct{}
	cleared_ProvisionedHostToAgentStatus        bool
	done                                        bool
	oldValue                                    func(context.Context) (*ProvisionedHost, error)
	predicates                                  []predicate.ProvisionedHost
}

var _ ent.Mutation = (*ProvisionedHostMutation)(nil)

// provisionedhostOption allows management of the mutation configuration using functional options.
type provisionedhostOption func(*ProvisionedHostMutation)

// newProvisionedHostMutation creates new mutation for the ProvisionedHost entity.
func newProvisionedHostMutation(c config, op Op, opts ...provisionedhostOption) *ProvisionedHostMutation {
	m := &ProvisionedHostMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedHostID sets the ID field of the mutation.
func withProvisionedHostID(id int) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedHost
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedHost, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedHost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedHost sets the old ProvisionedHost of the mutation.
func withProvisionedHost(node *ProvisionedHost) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		m.oldValue = func(context.Context) (*ProvisionedHost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedHostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedHostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProvisionedHostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubnetIP sets the "subnet_ip" field.
func (m *ProvisionedHostMutation) SetSubnetIP(s string) {
	m.subnet_ip = &s
}

// SubnetIP returns the value of the "subnet_ip" field in the mutation.
func (m *ProvisionedHostMutation) SubnetIP() (r string, exists bool) {
	v := m.subnet_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnetIP returns the old "subnet_ip" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldSubnetIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubnetIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubnetIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnetIP: %w", err)
	}
	return oldValue.SubnetIP, nil
}

// ResetSubnetIP resets all changes to the "subnet_ip" field.
func (m *ProvisionedHostMutation) ResetSubnetIP() {
	m.subnet_ip = nil
}

// AddProvisionedHostToTagIDs adds the "ProvisionedHostToTag" edge to the Tag entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToTagIDs(ids ...int) {
	if m._ProvisionedHostToTag == nil {
		m._ProvisionedHostToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToTag[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToTag clears the "ProvisionedHostToTag" edge to the Tag entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToTag() {
	m.cleared_ProvisionedHostToTag = true
}

// ProvisionedHostToTagCleared returns if the "ProvisionedHostToTag" edge to the Tag entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToTagCleared() bool {
	return m.cleared_ProvisionedHostToTag
}

// RemoveProvisionedHostToTagIDs removes the "ProvisionedHostToTag" edge to the Tag entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToTagIDs(ids ...int) {
	if m.removed_ProvisionedHostToTag == nil {
		m.removed_ProvisionedHostToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedHostToTag[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToTag returns the removed IDs of the "ProvisionedHostToTag" edge to the Tag entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToTagIDs() (ids []int) {
	for id := range m.removed_ProvisionedHostToTag {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToTagIDs returns the "ProvisionedHostToTag" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToTagIDs() (ids []int) {
	for id := range m._ProvisionedHostToTag {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToTag resets all changes to the "ProvisionedHostToTag" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToTag() {
	m._ProvisionedHostToTag = nil
	m.cleared_ProvisionedHostToTag = false
	m.removed_ProvisionedHostToTag = nil
}

// AddProvisionedHostToStatuIDs adds the "ProvisionedHostToStatus" edge to the Status entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToStatuIDs(ids ...int) {
	if m._ProvisionedHostToStatus == nil {
		m._ProvisionedHostToStatus = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToStatus[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToStatus clears the "ProvisionedHostToStatus" edge to the Status entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToStatus() {
	m.cleared_ProvisionedHostToStatus = true
}

// ProvisionedHostToStatusCleared returns if the "ProvisionedHostToStatus" edge to the Status entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToStatusCleared() bool {
	return m.cleared_ProvisionedHostToStatus
}

// RemoveProvisionedHostToStatuIDs removes the "ProvisionedHostToStatus" edge to the Status entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToStatuIDs(ids ...int) {
	if m.removed_ProvisionedHostToStatus == nil {
		m.removed_ProvisionedHostToStatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedHostToStatus[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToStatus returns the removed IDs of the "ProvisionedHostToStatus" edge to the Status entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToStatusIDs() (ids []int) {
	for id := range m.removed_ProvisionedHostToStatus {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToStatusIDs returns the "ProvisionedHostToStatus" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToStatusIDs() (ids []int) {
	for id := range m._ProvisionedHostToStatus {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToStatus resets all changes to the "ProvisionedHostToStatus" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToStatus() {
	m._ProvisionedHostToStatus = nil
	m.cleared_ProvisionedHostToStatus = false
	m.removed_ProvisionedHostToStatus = nil
}

// AddProvisionedHostToProvisionedNetworkIDs adds the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToProvisionedNetworkIDs(ids ...int) {
	if m._ProvisionedHostToProvisionedNetwork == nil {
		m._ProvisionedHostToProvisionedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToProvisionedNetwork clears the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToProvisionedNetwork() {
	m.cleared_ProvisionedHostToProvisionedNetwork = true
}

// ProvisionedHostToProvisionedNetworkCleared returns if the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisionedNetworkCleared() bool {
	return m.cleared_ProvisionedHostToProvisionedNetwork
}

// RemoveProvisionedHostToProvisionedNetworkIDs removes the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToProvisionedNetworkIDs(ids ...int) {
	if m.removed_ProvisionedHostToProvisionedNetwork == nil {
		m.removed_ProvisionedHostToProvisionedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedHostToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToProvisionedNetwork returns the removed IDs of the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToProvisionedNetworkIDs() (ids []int) {
	for id := range m.removed_ProvisionedHostToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToProvisionedNetworkIDs returns the "ProvisionedHostToProvisionedNetwork" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisionedNetworkIDs() (ids []int) {
	for id := range m._ProvisionedHostToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToProvisionedNetwork resets all changes to the "ProvisionedHostToProvisionedNetwork" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToProvisionedNetwork() {
	m._ProvisionedHostToProvisionedNetwork = nil
	m.cleared_ProvisionedHostToProvisionedNetwork = false
	m.removed_ProvisionedHostToProvisionedNetwork = nil
}

// AddProvisionedHostToHostIDs adds the "ProvisionedHostToHost" edge to the Host entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToHostIDs(ids ...int) {
	if m._ProvisionedHostToHost == nil {
		m._ProvisionedHostToHost = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToHost[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToHost clears the "ProvisionedHostToHost" edge to the Host entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToHost() {
	m.cleared_ProvisionedHostToHost = true
}

// ProvisionedHostToHostCleared returns if the "ProvisionedHostToHost" edge to the Host entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToHostCleared() bool {
	return m.cleared_ProvisionedHostToHost
}

// RemoveProvisionedHostToHostIDs removes the "ProvisionedHostToHost" edge to the Host entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToHostIDs(ids ...int) {
	if m.removed_ProvisionedHostToHost == nil {
		m.removed_ProvisionedHostToHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedHostToHost[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToHost returns the removed IDs of the "ProvisionedHostToHost" edge to the Host entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToHostIDs() (ids []int) {
	for id := range m.removed_ProvisionedHostToHost {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToHostIDs returns the "ProvisionedHostToHost" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToHostIDs() (ids []int) {
	for id := range m._ProvisionedHostToHost {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToHost resets all changes to the "ProvisionedHostToHost" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToHost() {
	m._ProvisionedHostToHost = nil
	m.cleared_ProvisionedHostToHost = false
	m.removed_ProvisionedHostToHost = nil
}

// AddProvisionedHostToProvisioningStepIDs adds the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToProvisioningStepIDs(ids ...int) {
	if m._ProvisionedHostToProvisioningStep == nil {
		m._ProvisionedHostToProvisioningStep = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToProvisioningStep[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToProvisioningStep clears the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToProvisioningStep() {
	m.cleared_ProvisionedHostToProvisioningStep = true
}

// ProvisionedHostToProvisioningStepCleared returns if the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisioningStepCleared() bool {
	return m.cleared_ProvisionedHostToProvisioningStep
}

// RemoveProvisionedHostToProvisioningStepIDs removes the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToProvisioningStepIDs(ids ...int) {
	if m.removed_ProvisionedHostToProvisioningStep == nil {
		m.removed_ProvisionedHostToProvisioningStep = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedHostToProvisioningStep[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToProvisioningStep returns the removed IDs of the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToProvisioningStepIDs() (ids []int) {
	for id := range m.removed_ProvisionedHostToProvisioningStep {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToProvisioningStepIDs returns the "ProvisionedHostToProvisioningStep" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisioningStepIDs() (ids []int) {
	for id := range m._ProvisionedHostToProvisioningStep {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToProvisioningStep resets all changes to the "ProvisionedHostToProvisioningStep" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToProvisioningStep() {
	m._ProvisionedHostToProvisioningStep = nil
	m.cleared_ProvisionedHostToProvisioningStep = false
	m.removed_ProvisionedHostToProvisioningStep = nil
}

// AddProvisionedHostToAgentStatuIDs adds the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToAgentStatuIDs(ids ...int) {
	if m._ProvisionedHostToAgentStatus == nil {
		m._ProvisionedHostToAgentStatus = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToAgentStatus[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToAgentStatus clears the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToAgentStatus() {
	m.cleared_ProvisionedHostToAgentStatus = true
}

// ProvisionedHostToAgentStatusCleared returns if the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToAgentStatusCleared() bool {
	return m.cleared_ProvisionedHostToAgentStatus
}

// RemoveProvisionedHostToAgentStatuIDs removes the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToAgentStatuIDs(ids ...int) {
	if m.removed_ProvisionedHostToAgentStatus == nil {
		m.removed_ProvisionedHostToAgentStatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedHostToAgentStatus[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToAgentStatus returns the removed IDs of the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToAgentStatusIDs() (ids []int) {
	for id := range m.removed_ProvisionedHostToAgentStatus {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToAgentStatusIDs returns the "ProvisionedHostToAgentStatus" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToAgentStatusIDs() (ids []int) {
	for id := range m._ProvisionedHostToAgentStatus {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToAgentStatus resets all changes to the "ProvisionedHostToAgentStatus" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToAgentStatus() {
	m._ProvisionedHostToAgentStatus = nil
	m.cleared_ProvisionedHostToAgentStatus = false
	m.removed_ProvisionedHostToAgentStatus = nil
}

// Op returns the operation name.
func (m *ProvisionedHostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisionedHost).
func (m *ProvisionedHostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisionedHostMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.subnet_ip != nil {
		fields = append(fields, provisionedhost.FieldSubnetIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisionedHostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.SubnetIP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisionedHostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.OldSubnetIP(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedHostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnetIP(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisionedHostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisionedHostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedHostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedHost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisionedHostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisionedHostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisionedHost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ResetField(name string) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		m.ResetSubnetIP()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisionedHostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._ProvisionedHostToTag != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToTag)
	}
	if m._ProvisionedHostToStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToStatus)
	}
	if m._ProvisionedHostToProvisionedNetwork != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisionedNetwork)
	}
	if m._ProvisionedHostToHost != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToHost)
	}
	if m._ProvisionedHostToProvisioningStep != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisioningStep)
	}
	if m._ProvisionedHostToAgentStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisionedHostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeProvisionedHostToTag:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToTag))
		for id := range m._ProvisionedHostToTag {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToStatus:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToStatus))
		for id := range m._ProvisionedHostToStatus {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToProvisionedNetwork))
		for id := range m._ProvisionedHostToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToHost:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToHost))
		for id := range m._ProvisionedHostToHost {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToProvisioningStep))
		for id := range m._ProvisionedHostToProvisioningStep {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToAgentStatus))
		for id := range m._ProvisionedHostToAgentStatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisionedHostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_ProvisionedHostToTag != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToTag)
	}
	if m.removed_ProvisionedHostToStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToStatus)
	}
	if m.removed_ProvisionedHostToProvisionedNetwork != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisionedNetwork)
	}
	if m.removed_ProvisionedHostToHost != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToHost)
	}
	if m.removed_ProvisionedHostToProvisioningStep != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisioningStep)
	}
	if m.removed_ProvisionedHostToAgentStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisionedHostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeProvisionedHostToTag:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToTag))
		for id := range m.removed_ProvisionedHostToTag {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToStatus:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToStatus))
		for id := range m.removed_ProvisionedHostToStatus {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToProvisionedNetwork))
		for id := range m.removed_ProvisionedHostToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToHost:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToHost))
		for id := range m.removed_ProvisionedHostToHost {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToProvisioningStep))
		for id := range m.removed_ProvisionedHostToProvisioningStep {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToAgentStatus))
		for id := range m.removed_ProvisionedHostToAgentStatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisionedHostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_ProvisionedHostToTag {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToTag)
	}
	if m.cleared_ProvisionedHostToStatus {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToStatus)
	}
	if m.cleared_ProvisionedHostToProvisionedNetwork {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisionedNetwork)
	}
	if m.cleared_ProvisionedHostToHost {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToHost)
	}
	if m.cleared_ProvisionedHostToProvisioningStep {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisioningStep)
	}
	if m.cleared_ProvisionedHostToAgentStatus {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisionedHostMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionedhost.EdgeProvisionedHostToTag:
		return m.cleared_ProvisionedHostToTag
	case provisionedhost.EdgeProvisionedHostToStatus:
		return m.cleared_ProvisionedHostToStatus
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		return m.cleared_ProvisionedHostToProvisionedNetwork
	case provisionedhost.EdgeProvisionedHostToHost:
		return m.cleared_ProvisionedHostToHost
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		return m.cleared_ProvisionedHostToProvisioningStep
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		return m.cleared_ProvisionedHostToAgentStatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisionedHostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedHost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisionedHostMutation) ResetEdge(name string) error {
	switch name {
	case provisionedhost.EdgeProvisionedHostToTag:
		m.ResetProvisionedHostToTag()
		return nil
	case provisionedhost.EdgeProvisionedHostToStatus:
		m.ResetProvisionedHostToStatus()
		return nil
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		m.ResetProvisionedHostToProvisionedNetwork()
		return nil
	case provisionedhost.EdgeProvisionedHostToHost:
		m.ResetProvisionedHostToHost()
		return nil
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		m.ResetProvisionedHostToProvisioningStep()
		return nil
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		m.ResetProvisionedHostToAgentStatus()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost edge %s", name)
}

// ProvisionedNetworkMutation represents an operation that mutates the ProvisionedNetwork nodes in the graph.
type ProvisionedNetworkMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	name                                        *string
	cidr                                        *string
	clearedFields                               map[string]struct{}
	_ProvisionedNetworkToTag                    map[int]struct{}
	removed_ProvisionedNetworkToTag             map[int]struct{}
	cleared_ProvisionedNetworkToTag             bool
	_ProvisionedNetworkToStatus                 map[int]struct{}
	removed_ProvisionedNetworkToStatus          map[int]struct{}
	cleared_ProvisionedNetworkToStatus          bool
	_ProvisionedNetworkToNetwork                map[int]struct{}
	removed_ProvisionedNetworkToNetwork         map[int]struct{}
	cleared_ProvisionedNetworkToNetwork         bool
	_ProvisionedNetworkToBuild                  map[int]struct{}
	removed_ProvisionedNetworkToBuild           map[int]struct{}
	cleared_ProvisionedNetworkToBuild           bool
	_ProvisionedNetworkToTeam                   map[int]struct{}
	removed_ProvisionedNetworkToTeam            map[int]struct{}
	cleared_ProvisionedNetworkToTeam            bool
	_ProvisionedNetworkToProvisionedHost        map[int]struct{}
	removed_ProvisionedNetworkToProvisionedHost map[int]struct{}
	cleared_ProvisionedNetworkToProvisionedHost bool
	done                                        bool
	oldValue                                    func(context.Context) (*ProvisionedNetwork, error)
	predicates                                  []predicate.ProvisionedNetwork
}

var _ ent.Mutation = (*ProvisionedNetworkMutation)(nil)

// provisionednetworkOption allows management of the mutation configuration using functional options.
type provisionednetworkOption func(*ProvisionedNetworkMutation)

// newProvisionedNetworkMutation creates new mutation for the ProvisionedNetwork entity.
func newProvisionedNetworkMutation(c config, op Op, opts ...provisionednetworkOption) *ProvisionedNetworkMutation {
	m := &ProvisionedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedNetworkID sets the ID field of the mutation.
func withProvisionedNetworkID(id int) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedNetwork
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedNetwork sets the old ProvisionedNetwork of the mutation.
func withProvisionedNetwork(node *ProvisionedNetwork) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		m.oldValue = func(context.Context) (*ProvisionedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProvisionedNetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProvisionedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvisionedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvisionedNetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *ProvisionedNetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *ProvisionedNetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *ProvisionedNetworkMutation) ResetCidr() {
	m.cidr = nil
}

// AddProvisionedNetworkToTagIDs adds the "ProvisionedNetworkToTag" edge to the Tag entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToTagIDs(ids ...int) {
	if m._ProvisionedNetworkToTag == nil {
		m._ProvisionedNetworkToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToTag[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToTag clears the "ProvisionedNetworkToTag" edge to the Tag entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToTag() {
	m.cleared_ProvisionedNetworkToTag = true
}

// ProvisionedNetworkToTagCleared returns if the "ProvisionedNetworkToTag" edge to the Tag entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTagCleared() bool {
	return m.cleared_ProvisionedNetworkToTag
}

// RemoveProvisionedNetworkToTagIDs removes the "ProvisionedNetworkToTag" edge to the Tag entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToTagIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToTag == nil {
		m.removed_ProvisionedNetworkToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToTag[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToTag returns the removed IDs of the "ProvisionedNetworkToTag" edge to the Tag entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToTagIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToTag {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToTagIDs returns the "ProvisionedNetworkToTag" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTagIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToTag {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToTag resets all changes to the "ProvisionedNetworkToTag" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToTag() {
	m._ProvisionedNetworkToTag = nil
	m.cleared_ProvisionedNetworkToTag = false
	m.removed_ProvisionedNetworkToTag = nil
}

// AddProvisionedNetworkToStatuIDs adds the "ProvisionedNetworkToStatus" edge to the Status entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToStatuIDs(ids ...int) {
	if m._ProvisionedNetworkToStatus == nil {
		m._ProvisionedNetworkToStatus = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToStatus[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToStatus clears the "ProvisionedNetworkToStatus" edge to the Status entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToStatus() {
	m.cleared_ProvisionedNetworkToStatus = true
}

// ProvisionedNetworkToStatusCleared returns if the "ProvisionedNetworkToStatus" edge to the Status entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToStatusCleared() bool {
	return m.cleared_ProvisionedNetworkToStatus
}

// RemoveProvisionedNetworkToStatuIDs removes the "ProvisionedNetworkToStatus" edge to the Status entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToStatuIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToStatus == nil {
		m.removed_ProvisionedNetworkToStatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToStatus[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToStatus returns the removed IDs of the "ProvisionedNetworkToStatus" edge to the Status entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToStatusIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToStatus {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToStatusIDs returns the "ProvisionedNetworkToStatus" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToStatusIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToStatus {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToStatus resets all changes to the "ProvisionedNetworkToStatus" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToStatus() {
	m._ProvisionedNetworkToStatus = nil
	m.cleared_ProvisionedNetworkToStatus = false
	m.removed_ProvisionedNetworkToStatus = nil
}

// AddProvisionedNetworkToNetworkIDs adds the "ProvisionedNetworkToNetwork" edge to the Network entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToNetworkIDs(ids ...int) {
	if m._ProvisionedNetworkToNetwork == nil {
		m._ProvisionedNetworkToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToNetwork[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToNetwork clears the "ProvisionedNetworkToNetwork" edge to the Network entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToNetwork() {
	m.cleared_ProvisionedNetworkToNetwork = true
}

// ProvisionedNetworkToNetworkCleared returns if the "ProvisionedNetworkToNetwork" edge to the Network entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToNetworkCleared() bool {
	return m.cleared_ProvisionedNetworkToNetwork
}

// RemoveProvisionedNetworkToNetworkIDs removes the "ProvisionedNetworkToNetwork" edge to the Network entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToNetworkIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToNetwork == nil {
		m.removed_ProvisionedNetworkToNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToNetwork[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToNetwork returns the removed IDs of the "ProvisionedNetworkToNetwork" edge to the Network entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToNetworkIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToNetwork {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToNetworkIDs returns the "ProvisionedNetworkToNetwork" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToNetworkIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToNetwork resets all changes to the "ProvisionedNetworkToNetwork" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToNetwork() {
	m._ProvisionedNetworkToNetwork = nil
	m.cleared_ProvisionedNetworkToNetwork = false
	m.removed_ProvisionedNetworkToNetwork = nil
}

// AddProvisionedNetworkToBuildIDs adds the "ProvisionedNetworkToBuild" edge to the Build entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToBuildIDs(ids ...int) {
	if m._ProvisionedNetworkToBuild == nil {
		m._ProvisionedNetworkToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToBuild[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToBuild clears the "ProvisionedNetworkToBuild" edge to the Build entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToBuild() {
	m.cleared_ProvisionedNetworkToBuild = true
}

// ProvisionedNetworkToBuildCleared returns if the "ProvisionedNetworkToBuild" edge to the Build entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToBuildCleared() bool {
	return m.cleared_ProvisionedNetworkToBuild
}

// RemoveProvisionedNetworkToBuildIDs removes the "ProvisionedNetworkToBuild" edge to the Build entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToBuildIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToBuild == nil {
		m.removed_ProvisionedNetworkToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToBuild[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToBuild returns the removed IDs of the "ProvisionedNetworkToBuild" edge to the Build entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToBuildIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToBuild {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToBuildIDs returns the "ProvisionedNetworkToBuild" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToBuildIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToBuild {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToBuild resets all changes to the "ProvisionedNetworkToBuild" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToBuild() {
	m._ProvisionedNetworkToBuild = nil
	m.cleared_ProvisionedNetworkToBuild = false
	m.removed_ProvisionedNetworkToBuild = nil
}

// AddProvisionedNetworkToTeamIDs adds the "ProvisionedNetworkToTeam" edge to the Team entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToTeamIDs(ids ...int) {
	if m._ProvisionedNetworkToTeam == nil {
		m._ProvisionedNetworkToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToTeam[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToTeam clears the "ProvisionedNetworkToTeam" edge to the Team entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToTeam() {
	m.cleared_ProvisionedNetworkToTeam = true
}

// ProvisionedNetworkToTeamCleared returns if the "ProvisionedNetworkToTeam" edge to the Team entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamCleared() bool {
	return m.cleared_ProvisionedNetworkToTeam
}

// RemoveProvisionedNetworkToTeamIDs removes the "ProvisionedNetworkToTeam" edge to the Team entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToTeamIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToTeam == nil {
		m.removed_ProvisionedNetworkToTeam = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToTeam[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToTeam returns the removed IDs of the "ProvisionedNetworkToTeam" edge to the Team entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToTeamIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToTeam {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToTeamIDs returns the "ProvisionedNetworkToTeam" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToTeam {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToTeam resets all changes to the "ProvisionedNetworkToTeam" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToTeam() {
	m._ProvisionedNetworkToTeam = nil
	m.cleared_ProvisionedNetworkToTeam = false
	m.removed_ProvisionedNetworkToTeam = nil
}

// AddProvisionedNetworkToProvisionedHostIDs adds the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToProvisionedHostIDs(ids ...int) {
	if m._ProvisionedNetworkToProvisionedHost == nil {
		m._ProvisionedNetworkToProvisionedHost = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToProvisionedHost[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToProvisionedHost clears the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToProvisionedHost() {
	m.cleared_ProvisionedNetworkToProvisionedHost = true
}

// ProvisionedNetworkToProvisionedHostCleared returns if the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToProvisionedHostCleared() bool {
	return m.cleared_ProvisionedNetworkToProvisionedHost
}

// RemoveProvisionedNetworkToProvisionedHostIDs removes the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToProvisionedHostIDs(ids ...int) {
	if m.removed_ProvisionedNetworkToProvisionedHost == nil {
		m.removed_ProvisionedNetworkToProvisionedHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisionedNetworkToProvisionedHost[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToProvisionedHost returns the removed IDs of the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToProvisionedHostIDs() (ids []int) {
	for id := range m.removed_ProvisionedNetworkToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToProvisionedHostIDs returns the "ProvisionedNetworkToProvisionedHost" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToProvisionedHostIDs() (ids []int) {
	for id := range m._ProvisionedNetworkToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToProvisionedHost resets all changes to the "ProvisionedNetworkToProvisionedHost" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToProvisionedHost() {
	m._ProvisionedNetworkToProvisionedHost = nil
	m.cleared_ProvisionedNetworkToProvisionedHost = false
	m.removed_ProvisionedNetworkToProvisionedHost = nil
}

// Op returns the operation name.
func (m *ProvisionedNetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisionedNetwork).
func (m *ProvisionedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisionedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, provisionednetwork.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, provisionednetwork.FieldCidr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisionedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionednetwork.FieldName:
		return m.Name()
	case provisionednetwork.FieldCidr:
		return m.Cidr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisionedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionednetwork.FieldName:
		return m.OldName(ctx)
	case provisionednetwork.FieldCidr:
		return m.OldCidr(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provisionednetwork.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisionedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisionedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisionedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisionedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisionedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ResetField(name string) error {
	switch name {
	case provisionednetwork.FieldName:
		m.ResetName()
		return nil
	case provisionednetwork.FieldCidr:
		m.ResetCidr()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisionedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._ProvisionedNetworkToTag != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTag)
	}
	if m._ProvisionedNetworkToStatus != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToStatus)
	}
	if m._ProvisionedNetworkToNetwork != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToNetwork)
	}
	if m._ProvisionedNetworkToBuild != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToBuild)
	}
	if m._ProvisionedNetworkToTeam != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m._ProvisionedNetworkToProvisionedHost != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToProvisionedHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisionedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToTag:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToTag))
		for id := range m._ProvisionedNetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToStatus))
		for id := range m._ProvisionedNetworkToStatus {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToNetwork))
		for id := range m._ProvisionedNetworkToNetwork {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToBuild))
		for id := range m._ProvisionedNetworkToBuild {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToTeam))
		for id := range m._ProvisionedNetworkToTeam {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToProvisionedHost))
		for id := range m._ProvisionedNetworkToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisionedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_ProvisionedNetworkToTag != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTag)
	}
	if m.removed_ProvisionedNetworkToStatus != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToStatus)
	}
	if m.removed_ProvisionedNetworkToNetwork != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToNetwork)
	}
	if m.removed_ProvisionedNetworkToBuild != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToBuild)
	}
	if m.removed_ProvisionedNetworkToTeam != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m.removed_ProvisionedNetworkToProvisionedHost != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToProvisionedHost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisionedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToTag:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToTag))
		for id := range m.removed_ProvisionedNetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToStatus))
		for id := range m.removed_ProvisionedNetworkToStatus {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToNetwork))
		for id := range m.removed_ProvisionedNetworkToNetwork {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToBuild))
		for id := range m.removed_ProvisionedNetworkToBuild {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToTeam))
		for id := range m.removed_ProvisionedNetworkToTeam {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToProvisionedHost))
		for id := range m.removed_ProvisionedNetworkToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisionedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_ProvisionedNetworkToTag {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTag)
	}
	if m.cleared_ProvisionedNetworkToStatus {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToStatus)
	}
	if m.cleared_ProvisionedNetworkToNetwork {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToNetwork)
	}
	if m.cleared_ProvisionedNetworkToBuild {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToBuild)
	}
	if m.cleared_ProvisionedNetworkToTeam {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m.cleared_ProvisionedNetworkToProvisionedHost {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToProvisionedHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisionedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToTag:
		return m.cleared_ProvisionedNetworkToTag
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		return m.cleared_ProvisionedNetworkToStatus
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		return m.cleared_ProvisionedNetworkToNetwork
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		return m.cleared_ProvisionedNetworkToBuild
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		return m.cleared_ProvisionedNetworkToTeam
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		return m.cleared_ProvisionedNetworkToProvisionedHost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedNetwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisionedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToTag:
		m.ResetProvisionedNetworkToTag()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		m.ResetProvisionedNetworkToStatus()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		m.ResetProvisionedNetworkToNetwork()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		m.ResetProvisionedNetworkToBuild()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		m.ResetProvisionedNetworkToTeam()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		m.ResetProvisionedNetworkToProvisionedHost()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork edge %s", name)
}

// ProvisioningStepMutation represents an operation that mutates the ProvisioningStep nodes in the graph.
type ProvisioningStepMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *int
	provisioner_type                          *string
	step_number                               *int
	addstep_number                            *int
	clearedFields                             map[string]struct{}
	_ProvisioningStepToTag                    map[int]struct{}
	removed_ProvisioningStepToTag             map[int]struct{}
	cleared_ProvisioningStepToTag             bool
	_ProvisioningStepToStatus                 map[int]struct{}
	removed_ProvisioningStepToStatus          map[int]struct{}
	cleared_ProvisioningStepToStatus          bool
	_ProvisioningStepToProvisionedHost        map[int]struct{}
	removed_ProvisioningStepToProvisionedHost map[int]struct{}
	cleared_ProvisioningStepToProvisionedHost bool
	_ProvisioningStepToScript                 map[int]struct{}
	removed_ProvisioningStepToScript          map[int]struct{}
	cleared_ProvisioningStepToScript          bool
	_ProvisioningStepToCommand                map[int]struct{}
	removed_ProvisioningStepToCommand         map[int]struct{}
	cleared_ProvisioningStepToCommand         bool
	_ProvisioningStepToDNSRecord              map[int]struct{}
	removed_ProvisioningStepToDNSRecord       map[int]struct{}
	cleared_ProvisioningStepToDNSRecord       bool
	_ProvisioningStepToFileDelete             map[int]struct{}
	removed_ProvisioningStepToFileDelete      map[int]struct{}
	cleared_ProvisioningStepToFileDelete      bool
	_ProvisioningStepToFileDownload           map[int]struct{}
	removed_ProvisioningStepToFileDownload    map[int]struct{}
	cleared_ProvisioningStepToFileDownload    bool
	_ProvisioningStepToFileExtract            map[int]struct{}
	removed_ProvisioningStepToFileExtract     map[int]struct{}
	cleared_ProvisioningStepToFileExtract     bool
	done                                      bool
	oldValue                                  func(context.Context) (*ProvisioningStep, error)
	predicates                                []predicate.ProvisioningStep
}

var _ ent.Mutation = (*ProvisioningStepMutation)(nil)

// provisioningstepOption allows management of the mutation configuration using functional options.
type provisioningstepOption func(*ProvisioningStepMutation)

// newProvisioningStepMutation creates new mutation for the ProvisioningStep entity.
func newProvisioningStepMutation(c config, op Op, opts ...provisioningstepOption) *ProvisioningStepMutation {
	m := &ProvisioningStepMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisioningStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisioningStepID sets the ID field of the mutation.
func withProvisioningStepID(id int) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisioningStep
		)
		m.oldValue = func(ctx context.Context) (*ProvisioningStep, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisioningStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisioningStep sets the old ProvisioningStep of the mutation.
func withProvisioningStep(node *ProvisioningStep) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		m.oldValue = func(context.Context) (*ProvisioningStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisioningStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisioningStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProvisioningStepMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvisionerType sets the "provisioner_type" field.
func (m *ProvisioningStepMutation) SetProvisionerType(s string) {
	m.provisioner_type = &s
}

// ProvisionerType returns the value of the "provisioner_type" field in the mutation.
func (m *ProvisioningStepMutation) ProvisionerType() (r string, exists bool) {
	v := m.provisioner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProvisionerType returns the old "provisioner_type" field's value of the ProvisioningStep entity.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningStepMutation) OldProvisionerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvisionerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvisionerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvisionerType: %w", err)
	}
	return oldValue.ProvisionerType, nil
}

// ResetProvisionerType resets all changes to the "provisioner_type" field.
func (m *ProvisioningStepMutation) ResetProvisionerType() {
	m.provisioner_type = nil
}

// SetStepNumber sets the "step_number" field.
func (m *ProvisioningStepMutation) SetStepNumber(i int) {
	m.step_number = &i
	m.addstep_number = nil
}

// StepNumber returns the value of the "step_number" field in the mutation.
func (m *ProvisioningStepMutation) StepNumber() (r int, exists bool) {
	v := m.step_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStepNumber returns the old "step_number" field's value of the ProvisioningStep entity.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningStepMutation) OldStepNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStepNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStepNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepNumber: %w", err)
	}
	return oldValue.StepNumber, nil
}

// AddStepNumber adds i to the "step_number" field.
func (m *ProvisioningStepMutation) AddStepNumber(i int) {
	if m.addstep_number != nil {
		*m.addstep_number += i
	} else {
		m.addstep_number = &i
	}
}

// AddedStepNumber returns the value that was added to the "step_number" field in this mutation.
func (m *ProvisioningStepMutation) AddedStepNumber() (r int, exists bool) {
	v := m.addstep_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepNumber resets all changes to the "step_number" field.
func (m *ProvisioningStepMutation) ResetStepNumber() {
	m.step_number = nil
	m.addstep_number = nil
}

// AddProvisioningStepToTagIDs adds the "ProvisioningStepToTag" edge to the Tag entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToTagIDs(ids ...int) {
	if m._ProvisioningStepToTag == nil {
		m._ProvisioningStepToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToTag[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToTag clears the "ProvisioningStepToTag" edge to the Tag entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToTag() {
	m.cleared_ProvisioningStepToTag = true
}

// ProvisioningStepToTagCleared returns if the "ProvisioningStepToTag" edge to the Tag entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToTagCleared() bool {
	return m.cleared_ProvisioningStepToTag
}

// RemoveProvisioningStepToTagIDs removes the "ProvisioningStepToTag" edge to the Tag entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToTagIDs(ids ...int) {
	if m.removed_ProvisioningStepToTag == nil {
		m.removed_ProvisioningStepToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToTag[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToTag returns the removed IDs of the "ProvisioningStepToTag" edge to the Tag entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToTagIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToTag {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToTagIDs returns the "ProvisioningStepToTag" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToTagIDs() (ids []int) {
	for id := range m._ProvisioningStepToTag {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToTag resets all changes to the "ProvisioningStepToTag" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToTag() {
	m._ProvisioningStepToTag = nil
	m.cleared_ProvisioningStepToTag = false
	m.removed_ProvisioningStepToTag = nil
}

// AddProvisioningStepToStatuIDs adds the "ProvisioningStepToStatus" edge to the Status entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToStatuIDs(ids ...int) {
	if m._ProvisioningStepToStatus == nil {
		m._ProvisioningStepToStatus = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToStatus[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToStatus clears the "ProvisioningStepToStatus" edge to the Status entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToStatus() {
	m.cleared_ProvisioningStepToStatus = true
}

// ProvisioningStepToStatusCleared returns if the "ProvisioningStepToStatus" edge to the Status entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToStatusCleared() bool {
	return m.cleared_ProvisioningStepToStatus
}

// RemoveProvisioningStepToStatuIDs removes the "ProvisioningStepToStatus" edge to the Status entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToStatuIDs(ids ...int) {
	if m.removed_ProvisioningStepToStatus == nil {
		m.removed_ProvisioningStepToStatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToStatus[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToStatus returns the removed IDs of the "ProvisioningStepToStatus" edge to the Status entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToStatusIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToStatus {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToStatusIDs returns the "ProvisioningStepToStatus" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToStatusIDs() (ids []int) {
	for id := range m._ProvisioningStepToStatus {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToStatus resets all changes to the "ProvisioningStepToStatus" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToStatus() {
	m._ProvisioningStepToStatus = nil
	m.cleared_ProvisioningStepToStatus = false
	m.removed_ProvisioningStepToStatus = nil
}

// AddProvisioningStepToProvisionedHostIDs adds the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToProvisionedHostIDs(ids ...int) {
	if m._ProvisioningStepToProvisionedHost == nil {
		m._ProvisioningStepToProvisionedHost = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToProvisionedHost[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToProvisionedHost clears the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToProvisionedHost() {
	m.cleared_ProvisioningStepToProvisionedHost = true
}

// ProvisioningStepToProvisionedHostCleared returns if the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToProvisionedHostCleared() bool {
	return m.cleared_ProvisioningStepToProvisionedHost
}

// RemoveProvisioningStepToProvisionedHostIDs removes the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToProvisionedHostIDs(ids ...int) {
	if m.removed_ProvisioningStepToProvisionedHost == nil {
		m.removed_ProvisioningStepToProvisionedHost = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToProvisionedHost[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToProvisionedHost returns the removed IDs of the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToProvisionedHostIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToProvisionedHostIDs returns the "ProvisioningStepToProvisionedHost" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToProvisionedHostIDs() (ids []int) {
	for id := range m._ProvisioningStepToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToProvisionedHost resets all changes to the "ProvisioningStepToProvisionedHost" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToProvisionedHost() {
	m._ProvisioningStepToProvisionedHost = nil
	m.cleared_ProvisioningStepToProvisionedHost = false
	m.removed_ProvisioningStepToProvisionedHost = nil
}

// AddProvisioningStepToScriptIDs adds the "ProvisioningStepToScript" edge to the Script entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToScriptIDs(ids ...int) {
	if m._ProvisioningStepToScript == nil {
		m._ProvisioningStepToScript = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToScript[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToScript clears the "ProvisioningStepToScript" edge to the Script entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToScript() {
	m.cleared_ProvisioningStepToScript = true
}

// ProvisioningStepToScriptCleared returns if the "ProvisioningStepToScript" edge to the Script entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToScriptCleared() bool {
	return m.cleared_ProvisioningStepToScript
}

// RemoveProvisioningStepToScriptIDs removes the "ProvisioningStepToScript" edge to the Script entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToScriptIDs(ids ...int) {
	if m.removed_ProvisioningStepToScript == nil {
		m.removed_ProvisioningStepToScript = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToScript[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToScript returns the removed IDs of the "ProvisioningStepToScript" edge to the Script entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToScriptIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToScript {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToScriptIDs returns the "ProvisioningStepToScript" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToScriptIDs() (ids []int) {
	for id := range m._ProvisioningStepToScript {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToScript resets all changes to the "ProvisioningStepToScript" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToScript() {
	m._ProvisioningStepToScript = nil
	m.cleared_ProvisioningStepToScript = false
	m.removed_ProvisioningStepToScript = nil
}

// AddProvisioningStepToCommandIDs adds the "ProvisioningStepToCommand" edge to the Command entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToCommandIDs(ids ...int) {
	if m._ProvisioningStepToCommand == nil {
		m._ProvisioningStepToCommand = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToCommand[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToCommand clears the "ProvisioningStepToCommand" edge to the Command entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToCommand() {
	m.cleared_ProvisioningStepToCommand = true
}

// ProvisioningStepToCommandCleared returns if the "ProvisioningStepToCommand" edge to the Command entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToCommandCleared() bool {
	return m.cleared_ProvisioningStepToCommand
}

// RemoveProvisioningStepToCommandIDs removes the "ProvisioningStepToCommand" edge to the Command entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToCommandIDs(ids ...int) {
	if m.removed_ProvisioningStepToCommand == nil {
		m.removed_ProvisioningStepToCommand = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToCommand[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToCommand returns the removed IDs of the "ProvisioningStepToCommand" edge to the Command entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToCommandIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToCommand {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToCommandIDs returns the "ProvisioningStepToCommand" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToCommandIDs() (ids []int) {
	for id := range m._ProvisioningStepToCommand {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToCommand resets all changes to the "ProvisioningStepToCommand" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToCommand() {
	m._ProvisioningStepToCommand = nil
	m.cleared_ProvisioningStepToCommand = false
	m.removed_ProvisioningStepToCommand = nil
}

// AddProvisioningStepToDNSRecordIDs adds the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToDNSRecordIDs(ids ...int) {
	if m._ProvisioningStepToDNSRecord == nil {
		m._ProvisioningStepToDNSRecord = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToDNSRecord[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToDNSRecord clears the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToDNSRecord() {
	m.cleared_ProvisioningStepToDNSRecord = true
}

// ProvisioningStepToDNSRecordCleared returns if the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToDNSRecordCleared() bool {
	return m.cleared_ProvisioningStepToDNSRecord
}

// RemoveProvisioningStepToDNSRecordIDs removes the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToDNSRecordIDs(ids ...int) {
	if m.removed_ProvisioningStepToDNSRecord == nil {
		m.removed_ProvisioningStepToDNSRecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToDNSRecord[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToDNSRecord returns the removed IDs of the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToDNSRecordIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToDNSRecord {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToDNSRecordIDs returns the "ProvisioningStepToDNSRecord" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToDNSRecordIDs() (ids []int) {
	for id := range m._ProvisioningStepToDNSRecord {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToDNSRecord resets all changes to the "ProvisioningStepToDNSRecord" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToDNSRecord() {
	m._ProvisioningStepToDNSRecord = nil
	m.cleared_ProvisioningStepToDNSRecord = false
	m.removed_ProvisioningStepToDNSRecord = nil
}

// AddProvisioningStepToFileDeleteIDs adds the "ProvisioningStepToFileDelete" edge to the FileDelete entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToFileDeleteIDs(ids ...int) {
	if m._ProvisioningStepToFileDelete == nil {
		m._ProvisioningStepToFileDelete = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToFileDelete[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToFileDelete clears the "ProvisioningStepToFileDelete" edge to the FileDelete entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToFileDelete() {
	m.cleared_ProvisioningStepToFileDelete = true
}

// ProvisioningStepToFileDeleteCleared returns if the "ProvisioningStepToFileDelete" edge to the FileDelete entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDeleteCleared() bool {
	return m.cleared_ProvisioningStepToFileDelete
}

// RemoveProvisioningStepToFileDeleteIDs removes the "ProvisioningStepToFileDelete" edge to the FileDelete entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToFileDeleteIDs(ids ...int) {
	if m.removed_ProvisioningStepToFileDelete == nil {
		m.removed_ProvisioningStepToFileDelete = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToFileDelete[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToFileDelete returns the removed IDs of the "ProvisioningStepToFileDelete" edge to the FileDelete entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToFileDeleteIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToFileDelete {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToFileDeleteIDs returns the "ProvisioningStepToFileDelete" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDeleteIDs() (ids []int) {
	for id := range m._ProvisioningStepToFileDelete {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToFileDelete resets all changes to the "ProvisioningStepToFileDelete" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToFileDelete() {
	m._ProvisioningStepToFileDelete = nil
	m.cleared_ProvisioningStepToFileDelete = false
	m.removed_ProvisioningStepToFileDelete = nil
}

// AddProvisioningStepToFileDownloadIDs adds the "ProvisioningStepToFileDownload" edge to the FileDownload entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToFileDownloadIDs(ids ...int) {
	if m._ProvisioningStepToFileDownload == nil {
		m._ProvisioningStepToFileDownload = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToFileDownload[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToFileDownload clears the "ProvisioningStepToFileDownload" edge to the FileDownload entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToFileDownload() {
	m.cleared_ProvisioningStepToFileDownload = true
}

// ProvisioningStepToFileDownloadCleared returns if the "ProvisioningStepToFileDownload" edge to the FileDownload entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDownloadCleared() bool {
	return m.cleared_ProvisioningStepToFileDownload
}

// RemoveProvisioningStepToFileDownloadIDs removes the "ProvisioningStepToFileDownload" edge to the FileDownload entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToFileDownloadIDs(ids ...int) {
	if m.removed_ProvisioningStepToFileDownload == nil {
		m.removed_ProvisioningStepToFileDownload = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToFileDownload[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToFileDownload returns the removed IDs of the "ProvisioningStepToFileDownload" edge to the FileDownload entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToFileDownloadIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToFileDownload {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToFileDownloadIDs returns the "ProvisioningStepToFileDownload" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDownloadIDs() (ids []int) {
	for id := range m._ProvisioningStepToFileDownload {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToFileDownload resets all changes to the "ProvisioningStepToFileDownload" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToFileDownload() {
	m._ProvisioningStepToFileDownload = nil
	m.cleared_ProvisioningStepToFileDownload = false
	m.removed_ProvisioningStepToFileDownload = nil
}

// AddProvisioningStepToFileExtractIDs adds the "ProvisioningStepToFileExtract" edge to the FileExtract entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToFileExtractIDs(ids ...int) {
	if m._ProvisioningStepToFileExtract == nil {
		m._ProvisioningStepToFileExtract = make(map[int]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToFileExtract[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToFileExtract clears the "ProvisioningStepToFileExtract" edge to the FileExtract entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToFileExtract() {
	m.cleared_ProvisioningStepToFileExtract = true
}

// ProvisioningStepToFileExtractCleared returns if the "ProvisioningStepToFileExtract" edge to the FileExtract entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToFileExtractCleared() bool {
	return m.cleared_ProvisioningStepToFileExtract
}

// RemoveProvisioningStepToFileExtractIDs removes the "ProvisioningStepToFileExtract" edge to the FileExtract entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToFileExtractIDs(ids ...int) {
	if m.removed_ProvisioningStepToFileExtract == nil {
		m.removed_ProvisioningStepToFileExtract = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ProvisioningStepToFileExtract[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToFileExtract returns the removed IDs of the "ProvisioningStepToFileExtract" edge to the FileExtract entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToFileExtractIDs() (ids []int) {
	for id := range m.removed_ProvisioningStepToFileExtract {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToFileExtractIDs returns the "ProvisioningStepToFileExtract" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToFileExtractIDs() (ids []int) {
	for id := range m._ProvisioningStepToFileExtract {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToFileExtract resets all changes to the "ProvisioningStepToFileExtract" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToFileExtract() {
	m._ProvisioningStepToFileExtract = nil
	m.cleared_ProvisioningStepToFileExtract = false
	m.removed_ProvisioningStepToFileExtract = nil
}

// Op returns the operation name.
func (m *ProvisioningStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisioningStep).
func (m *ProvisioningStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisioningStepMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.provisioner_type != nil {
		fields = append(fields, provisioningstep.FieldProvisionerType)
	}
	if m.step_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisioningStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldProvisionerType:
		return m.ProvisionerType()
	case provisioningstep.FieldStepNumber:
		return m.StepNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisioningStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisioningstep.FieldProvisionerType:
		return m.OldProvisionerType(ctx)
	case provisioningstep.FieldStepNumber:
		return m.OldStepNumber(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldProvisionerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvisionerType(v)
		return nil
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisioningStepMutation) AddedFields() []string {
	var fields []string
	if m.addstep_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisioningStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldStepNumber:
		return m.AddedStepNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisioningStepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisioningStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisioningStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ResetField(name string) error {
	switch name {
	case provisioningstep.FieldProvisionerType:
		m.ResetProvisionerType()
		return nil
	case provisioningstep.FieldStepNumber:
		m.ResetStepNumber()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisioningStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m._ProvisioningStepToTag != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToTag)
	}
	if m._ProvisioningStepToStatus != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToStatus)
	}
	if m._ProvisioningStepToProvisionedHost != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToProvisionedHost)
	}
	if m._ProvisioningStepToScript != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToScript)
	}
	if m._ProvisioningStepToCommand != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToCommand)
	}
	if m._ProvisioningStepToDNSRecord != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToDNSRecord)
	}
	if m._ProvisioningStepToFileDelete != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDelete)
	}
	if m._ProvisioningStepToFileDownload != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDownload)
	}
	if m._ProvisioningStepToFileExtract != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileExtract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisioningStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeProvisioningStepToTag:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToTag))
		for id := range m._ProvisioningStepToTag {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToStatus:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToStatus))
		for id := range m._ProvisioningStepToStatus {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToProvisionedHost))
		for id := range m._ProvisioningStepToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToScript:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToScript))
		for id := range m._ProvisioningStepToScript {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToCommand:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToCommand))
		for id := range m._ProvisioningStepToCommand {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToDNSRecord))
		for id := range m._ProvisioningStepToDNSRecord {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToFileDelete))
		for id := range m._ProvisioningStepToFileDelete {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToFileDownload))
		for id := range m._ProvisioningStepToFileDownload {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToFileExtract))
		for id := range m._ProvisioningStepToFileExtract {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisioningStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removed_ProvisioningStepToTag != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToTag)
	}
	if m.removed_ProvisioningStepToStatus != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToStatus)
	}
	if m.removed_ProvisioningStepToProvisionedHost != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToProvisionedHost)
	}
	if m.removed_ProvisioningStepToScript != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToScript)
	}
	if m.removed_ProvisioningStepToCommand != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToCommand)
	}
	if m.removed_ProvisioningStepToDNSRecord != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToDNSRecord)
	}
	if m.removed_ProvisioningStepToFileDelete != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDelete)
	}
	if m.removed_ProvisioningStepToFileDownload != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDownload)
	}
	if m.removed_ProvisioningStepToFileExtract != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileExtract)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisioningStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeProvisioningStepToTag:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToTag))
		for id := range m.removed_ProvisioningStepToTag {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToStatus:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToStatus))
		for id := range m.removed_ProvisioningStepToStatus {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToProvisionedHost))
		for id := range m.removed_ProvisioningStepToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToScript:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToScript))
		for id := range m.removed_ProvisioningStepToScript {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToCommand:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToCommand))
		for id := range m.removed_ProvisioningStepToCommand {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToDNSRecord))
		for id := range m.removed_ProvisioningStepToDNSRecord {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToFileDelete))
		for id := range m.removed_ProvisioningStepToFileDelete {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToFileDownload))
		for id := range m.removed_ProvisioningStepToFileDownload {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToFileExtract))
		for id := range m.removed_ProvisioningStepToFileExtract {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisioningStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cleared_ProvisioningStepToTag {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToTag)
	}
	if m.cleared_ProvisioningStepToStatus {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToStatus)
	}
	if m.cleared_ProvisioningStepToProvisionedHost {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToProvisionedHost)
	}
	if m.cleared_ProvisioningStepToScript {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToScript)
	}
	if m.cleared_ProvisioningStepToCommand {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToCommand)
	}
	if m.cleared_ProvisioningStepToDNSRecord {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToDNSRecord)
	}
	if m.cleared_ProvisioningStepToFileDelete {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDelete)
	}
	if m.cleared_ProvisioningStepToFileDownload {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDownload)
	}
	if m.cleared_ProvisioningStepToFileExtract {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileExtract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisioningStepMutation) EdgeCleared(name string) bool {
	switch name {
	case provisioningstep.EdgeProvisioningStepToTag:
		return m.cleared_ProvisioningStepToTag
	case provisioningstep.EdgeProvisioningStepToStatus:
		return m.cleared_ProvisioningStepToStatus
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		return m.cleared_ProvisioningStepToProvisionedHost
	case provisioningstep.EdgeProvisioningStepToScript:
		return m.cleared_ProvisioningStepToScript
	case provisioningstep.EdgeProvisioningStepToCommand:
		return m.cleared_ProvisioningStepToCommand
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		return m.cleared_ProvisioningStepToDNSRecord
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		return m.cleared_ProvisioningStepToFileDelete
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		return m.cleared_ProvisioningStepToFileDownload
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		return m.cleared_ProvisioningStepToFileExtract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisioningStepMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisioningStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisioningStepMutation) ResetEdge(name string) error {
	switch name {
	case provisioningstep.EdgeProvisioningStepToTag:
		m.ResetProvisioningStepToTag()
		return nil
	case provisioningstep.EdgeProvisioningStepToStatus:
		m.ResetProvisioningStepToStatus()
		return nil
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		m.ResetProvisioningStepToProvisionedHost()
		return nil
	case provisioningstep.EdgeProvisioningStepToScript:
		m.ResetProvisioningStepToScript()
		return nil
	case provisioningstep.EdgeProvisioningStepToCommand:
		m.ResetProvisioningStepToCommand()
		return nil
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		m.ResetProvisioningStepToDNSRecord()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		m.ResetProvisioningStepToFileDelete()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		m.ResetProvisioningStepToFileDownload()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		m.ResetProvisioningStepToFileExtract()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep edge %s", name)
}

// ScriptMutation represents an operation that mutates the Script nodes in the graph.
type ScriptMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	hcl_id                      *string
	name                        *string
	language                    *string
	description                 *string
	source                      *string
	source_type                 *string
	cooldown                    *int
	addcooldown                 *int
	timeout                     *int
	addtimeout                  *int
	ignore_errors               *bool
	args                        *[]string
	disabled                    *bool
	vars                        *map[string]string
	abs_path                    *string
	tags                        *map[string]string
	clearedFields               map[string]struct{}
	_ScriptToTag                map[int]struct{}
	removed_ScriptToTag         map[int]struct{}
	cleared_ScriptToTag         bool
	_ScriptToUser               map[int]struct{}
	removed_ScriptToUser        map[int]struct{}
	cleared_ScriptToUser        bool
	_ScriptToFinding            map[int]struct{}
	removed_ScriptToFinding     map[int]struct{}
	cleared_ScriptToFinding     bool
	_ScriptToEnvironment        map[int]struct{}
	removed_ScriptToEnvironment map[int]struct{}
	cleared_ScriptToEnvironment bool
	done                        bool
	oldValue                    func(context.Context) (*Script, error)
	predicates                  []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows management of the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for the Script entity.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the ID field of the mutation.
func withScriptID(id int) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ScriptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHclID sets the "hcl_id" field.
func (m *ScriptMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *ScriptMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *ScriptMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *ScriptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScriptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScriptMutation) ResetName() {
	m.name = nil
}

// SetLanguage sets the "language" field.
func (m *ScriptMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *ScriptMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *ScriptMutation) ResetLanguage() {
	m.language = nil
}

// SetDescription sets the "description" field.
func (m *ScriptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScriptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ScriptMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *ScriptMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ScriptMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ScriptMutation) ResetSource() {
	m.source = nil
}

// SetSourceType sets the "source_type" field.
func (m *ScriptMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *ScriptMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *ScriptMutation) ResetSourceType() {
	m.source_type = nil
}

// SetCooldown sets the "cooldown" field.
func (m *ScriptMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the value of the "cooldown" field in the mutation.
func (m *ScriptMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old "cooldown" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCooldown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to the "cooldown" field.
func (m *ScriptMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the "cooldown" field in this mutation.
func (m *ScriptMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown resets all changes to the "cooldown" field.
func (m *ScriptMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the "timeout" field.
func (m *ScriptMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ScriptMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ScriptMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ScriptMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ScriptMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetIgnoreErrors sets the "ignore_errors" field.
func (m *ScriptMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the value of the "ignore_errors" field in the mutation.
func (m *ScriptMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old "ignore_errors" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIgnoreErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors resets all changes to the "ignore_errors" field.
func (m *ScriptMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetArgs sets the "args" field.
func (m *ScriptMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *ScriptMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *ScriptMutation) ResetArgs() {
	m.args = nil
}

// SetDisabled sets the "disabled" field.
func (m *ScriptMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ScriptMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ScriptMutation) ResetDisabled() {
	m.disabled = nil
}

// SetVars sets the "vars" field.
func (m *ScriptMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ScriptMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ScriptMutation) ResetVars() {
	m.vars = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *ScriptMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *ScriptMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *ScriptMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetTags sets the "tags" field.
func (m *ScriptMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ScriptMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *ScriptMutation) ResetTags() {
	m.tags = nil
}

// AddScriptToTagIDs adds the "ScriptToTag" edge to the Tag entity by ids.
func (m *ScriptMutation) AddScriptToTagIDs(ids ...int) {
	if m._ScriptToTag == nil {
		m._ScriptToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._ScriptToTag[ids[i]] = struct{}{}
	}
}

// ClearScriptToTag clears the "ScriptToTag" edge to the Tag entity.
func (m *ScriptMutation) ClearScriptToTag() {
	m.cleared_ScriptToTag = true
}

// ScriptToTagCleared returns if the "ScriptToTag" edge to the Tag entity was cleared.
func (m *ScriptMutation) ScriptToTagCleared() bool {
	return m.cleared_ScriptToTag
}

// RemoveScriptToTagIDs removes the "ScriptToTag" edge to the Tag entity by IDs.
func (m *ScriptMutation) RemoveScriptToTagIDs(ids ...int) {
	if m.removed_ScriptToTag == nil {
		m.removed_ScriptToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ScriptToTag[ids[i]] = struct{}{}
	}
}

// RemovedScriptToTag returns the removed IDs of the "ScriptToTag" edge to the Tag entity.
func (m *ScriptMutation) RemovedScriptToTagIDs() (ids []int) {
	for id := range m.removed_ScriptToTag {
		ids = append(ids, id)
	}
	return
}

// ScriptToTagIDs returns the "ScriptToTag" edge IDs in the mutation.
func (m *ScriptMutation) ScriptToTagIDs() (ids []int) {
	for id := range m._ScriptToTag {
		ids = append(ids, id)
	}
	return
}

// ResetScriptToTag resets all changes to the "ScriptToTag" edge.
func (m *ScriptMutation) ResetScriptToTag() {
	m._ScriptToTag = nil
	m.cleared_ScriptToTag = false
	m.removed_ScriptToTag = nil
}

// AddScriptToUserIDs adds the "ScriptToUser" edge to the User entity by ids.
func (m *ScriptMutation) AddScriptToUserIDs(ids ...int) {
	if m._ScriptToUser == nil {
		m._ScriptToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._ScriptToUser[ids[i]] = struct{}{}
	}
}

// ClearScriptToUser clears the "ScriptToUser" edge to the User entity.
func (m *ScriptMutation) ClearScriptToUser() {
	m.cleared_ScriptToUser = true
}

// ScriptToUserCleared returns if the "ScriptToUser" edge to the User entity was cleared.
func (m *ScriptMutation) ScriptToUserCleared() bool {
	return m.cleared_ScriptToUser
}

// RemoveScriptToUserIDs removes the "ScriptToUser" edge to the User entity by IDs.
func (m *ScriptMutation) RemoveScriptToUserIDs(ids ...int) {
	if m.removed_ScriptToUser == nil {
		m.removed_ScriptToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ScriptToUser[ids[i]] = struct{}{}
	}
}

// RemovedScriptToUser returns the removed IDs of the "ScriptToUser" edge to the User entity.
func (m *ScriptMutation) RemovedScriptToUserIDs() (ids []int) {
	for id := range m.removed_ScriptToUser {
		ids = append(ids, id)
	}
	return
}

// ScriptToUserIDs returns the "ScriptToUser" edge IDs in the mutation.
func (m *ScriptMutation) ScriptToUserIDs() (ids []int) {
	for id := range m._ScriptToUser {
		ids = append(ids, id)
	}
	return
}

// ResetScriptToUser resets all changes to the "ScriptToUser" edge.
func (m *ScriptMutation) ResetScriptToUser() {
	m._ScriptToUser = nil
	m.cleared_ScriptToUser = false
	m.removed_ScriptToUser = nil
}

// AddScriptToFindingIDs adds the "ScriptToFinding" edge to the Finding entity by ids.
func (m *ScriptMutation) AddScriptToFindingIDs(ids ...int) {
	if m._ScriptToFinding == nil {
		m._ScriptToFinding = make(map[int]struct{})
	}
	for i := range ids {
		m._ScriptToFinding[ids[i]] = struct{}{}
	}
}

// ClearScriptToFinding clears the "ScriptToFinding" edge to the Finding entity.
func (m *ScriptMutation) ClearScriptToFinding() {
	m.cleared_ScriptToFinding = true
}

// ScriptToFindingCleared returns if the "ScriptToFinding" edge to the Finding entity was cleared.
func (m *ScriptMutation) ScriptToFindingCleared() bool {
	return m.cleared_ScriptToFinding
}

// RemoveScriptToFindingIDs removes the "ScriptToFinding" edge to the Finding entity by IDs.
func (m *ScriptMutation) RemoveScriptToFindingIDs(ids ...int) {
	if m.removed_ScriptToFinding == nil {
		m.removed_ScriptToFinding = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ScriptToFinding[ids[i]] = struct{}{}
	}
}

// RemovedScriptToFinding returns the removed IDs of the "ScriptToFinding" edge to the Finding entity.
func (m *ScriptMutation) RemovedScriptToFindingIDs() (ids []int) {
	for id := range m.removed_ScriptToFinding {
		ids = append(ids, id)
	}
	return
}

// ScriptToFindingIDs returns the "ScriptToFinding" edge IDs in the mutation.
func (m *ScriptMutation) ScriptToFindingIDs() (ids []int) {
	for id := range m._ScriptToFinding {
		ids = append(ids, id)
	}
	return
}

// ResetScriptToFinding resets all changes to the "ScriptToFinding" edge.
func (m *ScriptMutation) ResetScriptToFinding() {
	m._ScriptToFinding = nil
	m.cleared_ScriptToFinding = false
	m.removed_ScriptToFinding = nil
}

// AddScriptToEnvironmentIDs adds the "ScriptToEnvironment" edge to the Environment entity by ids.
func (m *ScriptMutation) AddScriptToEnvironmentIDs(ids ...int) {
	if m._ScriptToEnvironment == nil {
		m._ScriptToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._ScriptToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearScriptToEnvironment clears the "ScriptToEnvironment" edge to the Environment entity.
func (m *ScriptMutation) ClearScriptToEnvironment() {
	m.cleared_ScriptToEnvironment = true
}

// ScriptToEnvironmentCleared returns if the "ScriptToEnvironment" edge to the Environment entity was cleared.
func (m *ScriptMutation) ScriptToEnvironmentCleared() bool {
	return m.cleared_ScriptToEnvironment
}

// RemoveScriptToEnvironmentIDs removes the "ScriptToEnvironment" edge to the Environment entity by IDs.
func (m *ScriptMutation) RemoveScriptToEnvironmentIDs(ids ...int) {
	if m.removed_ScriptToEnvironment == nil {
		m.removed_ScriptToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ScriptToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedScriptToEnvironment returns the removed IDs of the "ScriptToEnvironment" edge to the Environment entity.
func (m *ScriptMutation) RemovedScriptToEnvironmentIDs() (ids []int) {
	for id := range m.removed_ScriptToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ScriptToEnvironmentIDs returns the "ScriptToEnvironment" edge IDs in the mutation.
func (m *ScriptMutation) ScriptToEnvironmentIDs() (ids []int) {
	for id := range m._ScriptToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetScriptToEnvironment resets all changes to the "ScriptToEnvironment" edge.
func (m *ScriptMutation) ResetScriptToEnvironment() {
	m._ScriptToEnvironment = nil
	m.cleared_ScriptToEnvironment = false
	m.removed_ScriptToEnvironment = nil
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hcl_id != nil {
		fields = append(fields, script.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, script.FieldName)
	}
	if m.language != nil {
		fields = append(fields, script.FieldLanguage)
	}
	if m.description != nil {
		fields = append(fields, script.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, script.FieldSource)
	}
	if m.source_type != nil {
		fields = append(fields, script.FieldSourceType)
	}
	if m.cooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	if m.ignore_errors != nil {
		fields = append(fields, script.FieldIgnoreErrors)
	}
	if m.args != nil {
		fields = append(fields, script.FieldArgs)
	}
	if m.disabled != nil {
		fields = append(fields, script.FieldDisabled)
	}
	if m.vars != nil {
		fields = append(fields, script.FieldVars)
	}
	if m.abs_path != nil {
		fields = append(fields, script.FieldAbsPath)
	}
	if m.tags != nil {
		fields = append(fields, script.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldHclID:
		return m.HclID()
	case script.FieldName:
		return m.Name()
	case script.FieldLanguage:
		return m.Language()
	case script.FieldDescription:
		return m.Description()
	case script.FieldSource:
		return m.Source()
	case script.FieldSourceType:
		return m.SourceType()
	case script.FieldCooldown:
		return m.Cooldown()
	case script.FieldTimeout:
		return m.Timeout()
	case script.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case script.FieldArgs:
		return m.Args()
	case script.FieldDisabled:
		return m.Disabled()
	case script.FieldVars:
		return m.Vars()
	case script.FieldAbsPath:
		return m.AbsPath()
	case script.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldHclID:
		return m.OldHclID(ctx)
	case script.FieldName:
		return m.OldName(ctx)
	case script.FieldLanguage:
		return m.OldLanguage(ctx)
	case script.FieldDescription:
		return m.OldDescription(ctx)
	case script.FieldSource:
		return m.OldSource(ctx)
	case script.FieldSourceType:
		return m.OldSourceType(ctx)
	case script.FieldCooldown:
		return m.OldCooldown(ctx)
	case script.FieldTimeout:
		return m.OldTimeout(ctx)
	case script.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case script.FieldArgs:
		return m.OldArgs(ctx)
	case script.FieldDisabled:
		return m.OldDisabled(ctx)
	case script.FieldVars:
		return m.OldVars(ctx)
	case script.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case script.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case script.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case script.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case script.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case script.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case script.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case script.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case script.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case script.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case script.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case script.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case script.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case script.FieldCooldown:
		return m.AddedCooldown()
	case script.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldHclID:
		m.ResetHclID()
		return nil
	case script.FieldName:
		m.ResetName()
		return nil
	case script.FieldLanguage:
		m.ResetLanguage()
		return nil
	case script.FieldDescription:
		m.ResetDescription()
		return nil
	case script.FieldSource:
		m.ResetSource()
		return nil
	case script.FieldSourceType:
		m.ResetSourceType()
		return nil
	case script.FieldCooldown:
		m.ResetCooldown()
		return nil
	case script.FieldTimeout:
		m.ResetTimeout()
		return nil
	case script.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case script.FieldArgs:
		m.ResetArgs()
		return nil
	case script.FieldDisabled:
		m.ResetDisabled()
		return nil
	case script.FieldVars:
		m.ResetVars()
		return nil
	case script.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case script.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._ScriptToTag != nil {
		edges = append(edges, script.EdgeScriptToTag)
	}
	if m._ScriptToUser != nil {
		edges = append(edges, script.EdgeScriptToUser)
	}
	if m._ScriptToFinding != nil {
		edges = append(edges, script.EdgeScriptToFinding)
	}
	if m._ScriptToEnvironment != nil {
		edges = append(edges, script.EdgeScriptToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeScriptToTag:
		ids := make([]ent.Value, 0, len(m._ScriptToTag))
		for id := range m._ScriptToTag {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToUser:
		ids := make([]ent.Value, 0, len(m._ScriptToUser))
		for id := range m._ScriptToUser {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToFinding:
		ids := make([]ent.Value, 0, len(m._ScriptToFinding))
		for id := range m._ScriptToFinding {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToEnvironment:
		ids := make([]ent.Value, 0, len(m._ScriptToEnvironment))
		for id := range m._ScriptToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_ScriptToTag != nil {
		edges = append(edges, script.EdgeScriptToTag)
	}
	if m.removed_ScriptToUser != nil {
		edges = append(edges, script.EdgeScriptToUser)
	}
	if m.removed_ScriptToFinding != nil {
		edges = append(edges, script.EdgeScriptToFinding)
	}
	if m.removed_ScriptToEnvironment != nil {
		edges = append(edges, script.EdgeScriptToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeScriptToTag:
		ids := make([]ent.Value, 0, len(m.removed_ScriptToTag))
		for id := range m.removed_ScriptToTag {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToUser:
		ids := make([]ent.Value, 0, len(m.removed_ScriptToUser))
		for id := range m.removed_ScriptToUser {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToFinding:
		ids := make([]ent.Value, 0, len(m.removed_ScriptToFinding))
		for id := range m.removed_ScriptToFinding {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_ScriptToEnvironment))
		for id := range m.removed_ScriptToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_ScriptToTag {
		edges = append(edges, script.EdgeScriptToTag)
	}
	if m.cleared_ScriptToUser {
		edges = append(edges, script.EdgeScriptToUser)
	}
	if m.cleared_ScriptToFinding {
		edges = append(edges, script.EdgeScriptToFinding)
	}
	if m.cleared_ScriptToEnvironment {
		edges = append(edges, script.EdgeScriptToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	switch name {
	case script.EdgeScriptToTag:
		return m.cleared_ScriptToTag
	case script.EdgeScriptToUser:
		return m.cleared_ScriptToUser
	case script.EdgeScriptToFinding:
		return m.cleared_ScriptToFinding
	case script.EdgeScriptToEnvironment:
		return m.cleared_ScriptToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	switch name {
	case script.EdgeScriptToTag:
		m.ResetScriptToTag()
		return nil
	case script.EdgeScriptToUser:
		m.ResetScriptToUser()
		return nil
	case script.EdgeScriptToFinding:
		m.ResetScriptToFinding()
		return nil
	case script.EdgeScriptToEnvironment:
		m.ResetScriptToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Script edge %s", name)
}

// StatusMutation represents an operation that mutates the Status nodes in the graph.
type StatusMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	state               *status.State
	started_at          *time.Time
	ended_at            *time.Time
	failed              *bool
	completed           *bool
	error               *string
	clearedFields       map[string]struct{}
	_StatusToTag        map[int]struct{}
	removed_StatusToTag map[int]struct{}
	cleared_StatusToTag bool
	done                bool
	oldValue            func(context.Context) (*Status, error)
	predicates          []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows management of the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for the Status entity.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the ID field of the mutation.
func withStatusID(id int) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *StatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetState sets the "state" field.
func (m *StatusMutation) SetState(s status.State) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *StatusMutation) State() (r status.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldState(ctx context.Context) (v status.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *StatusMutation) ResetState() {
	m.state = nil
}

// SetStartedAt sets the "started_at" field.
func (m *StatusMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *StatusMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *StatusMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *StatusMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *StatusMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *StatusMutation) ResetEndedAt() {
	m.ended_at = nil
}

// SetFailed sets the "failed" field.
func (m *StatusMutation) SetFailed(b bool) {
	m.failed = &b
}

// Failed returns the value of the "failed" field in the mutation.
func (m *StatusMutation) Failed() (r bool, exists bool) {
	v := m.failed
	if v == nil {
		return
	}
	return *v, true
}

// OldFailed returns the old "failed" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldFailed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailed: %w", err)
	}
	return oldValue.Failed, nil
}

// ResetFailed resets all changes to the "failed" field.
func (m *StatusMutation) ResetFailed() {
	m.failed = nil
}

// SetCompleted sets the "completed" field.
func (m *StatusMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *StatusMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *StatusMutation) ResetCompleted() {
	m.completed = nil
}

// SetError sets the "error" field.
func (m *StatusMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *StatusMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "error" field.
func (m *StatusMutation) ResetError() {
	m.error = nil
}

// AddStatusToTagIDs adds the "StatusToTag" edge to the Tag entity by ids.
func (m *StatusMutation) AddStatusToTagIDs(ids ...int) {
	if m._StatusToTag == nil {
		m._StatusToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._StatusToTag[ids[i]] = struct{}{}
	}
}

// ClearStatusToTag clears the "StatusToTag" edge to the Tag entity.
func (m *StatusMutation) ClearStatusToTag() {
	m.cleared_StatusToTag = true
}

// StatusToTagCleared returns if the "StatusToTag" edge to the Tag entity was cleared.
func (m *StatusMutation) StatusToTagCleared() bool {
	return m.cleared_StatusToTag
}

// RemoveStatusToTagIDs removes the "StatusToTag" edge to the Tag entity by IDs.
func (m *StatusMutation) RemoveStatusToTagIDs(ids ...int) {
	if m.removed_StatusToTag == nil {
		m.removed_StatusToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_StatusToTag[ids[i]] = struct{}{}
	}
}

// RemovedStatusToTag returns the removed IDs of the "StatusToTag" edge to the Tag entity.
func (m *StatusMutation) RemovedStatusToTagIDs() (ids []int) {
	for id := range m.removed_StatusToTag {
		ids = append(ids, id)
	}
	return
}

// StatusToTagIDs returns the "StatusToTag" edge IDs in the mutation.
func (m *StatusMutation) StatusToTagIDs() (ids []int) {
	for id := range m._StatusToTag {
		ids = append(ids, id)
	}
	return
}

// ResetStatusToTag resets all changes to the "StatusToTag" edge.
func (m *StatusMutation) ResetStatusToTag() {
	m._StatusToTag = nil
	m.cleared_StatusToTag = false
	m.removed_StatusToTag = nil
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.state != nil {
		fields = append(fields, status.FieldState)
	}
	if m.started_at != nil {
		fields = append(fields, status.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, status.FieldEndedAt)
	}
	if m.failed != nil {
		fields = append(fields, status.FieldFailed)
	}
	if m.completed != nil {
		fields = append(fields, status.FieldCompleted)
	}
	if m.error != nil {
		fields = append(fields, status.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldState:
		return m.State()
	case status.FieldStartedAt:
		return m.StartedAt()
	case status.FieldEndedAt:
		return m.EndedAt()
	case status.FieldFailed:
		return m.Failed()
	case status.FieldCompleted:
		return m.Completed()
	case status.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldState:
		return m.OldState(ctx)
	case status.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case status.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case status.FieldFailed:
		return m.OldFailed(ctx)
	case status.FieldCompleted:
		return m.OldCompleted(ctx)
	case status.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldState:
		v, ok := value.(status.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case status.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case status.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case status.FieldFailed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailed(v)
		return nil
	case status.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case status.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldState:
		m.ResetState()
		return nil
	case status.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case status.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case status.FieldFailed:
		m.ResetFailed()
		return nil
	case status.FieldCompleted:
		m.ResetCompleted()
		return nil
	case status.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._StatusToTag != nil {
		edges = append(edges, status.EdgeStatusToTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeStatusToTag:
		ids := make([]ent.Value, 0, len(m._StatusToTag))
		for id := range m._StatusToTag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_StatusToTag != nil {
		edges = append(edges, status.EdgeStatusToTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeStatusToTag:
		ids := make([]ent.Value, 0, len(m.removed_StatusToTag))
		for id := range m.removed_StatusToTag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_StatusToTag {
		edges = append(edges, status.EdgeStatusToTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	case status.EdgeStatusToTag:
		return m.cleared_StatusToTag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeStatusToTag:
		m.ResetStatusToTag()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *uuid.UUID
	name          *string
	description   *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TagMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TagMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TagMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, tag.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUUID:
		return m.UUID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUUID:
		return m.OldUUID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUUID:
		m.ResetUUID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	team_number                      *int
	addteam_number                   *int
	_config                          *map[string]string
	revision                         *int64
	addrevision                      *int64
	clearedFields                    map[string]struct{}
	_TeamToUser                      map[int]struct{}
	removed_TeamToUser               map[int]struct{}
	cleared_TeamToUser               bool
	_TeamToBuild                     map[int]struct{}
	removed_TeamToBuild              map[int]struct{}
	cleared_TeamToBuild              bool
	_TeamToEnvironment               map[int]struct{}
	removed_TeamToEnvironment        map[int]struct{}
	cleared_TeamToEnvironment        bool
	_TeamToTag                       map[int]struct{}
	removed_TeamToTag                map[int]struct{}
	cleared_TeamToTag                bool
	_TeamToProvisionedNetwork        map[int]struct{}
	removed_TeamToProvisionedNetwork map[int]struct{}
	cleared_TeamToProvisionedNetwork bool
	done                             bool
	oldValue                         func(context.Context) (*Team, error)
	predicates                       []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTeamNumber sets the "team_number" field.
func (m *TeamMutation) SetTeamNumber(i int) {
	m.team_number = &i
	m.addteam_number = nil
}

// TeamNumber returns the value of the "team_number" field in the mutation.
func (m *TeamMutation) TeamNumber() (r int, exists bool) {
	v := m.team_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamNumber returns the old "team_number" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTeamNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeamNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeamNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamNumber: %w", err)
	}
	return oldValue.TeamNumber, nil
}

// AddTeamNumber adds i to the "team_number" field.
func (m *TeamMutation) AddTeamNumber(i int) {
	if m.addteam_number != nil {
		*m.addteam_number += i
	} else {
		m.addteam_number = &i
	}
}

// AddedTeamNumber returns the value that was added to the "team_number" field in this mutation.
func (m *TeamMutation) AddedTeamNumber() (r int, exists bool) {
	v := m.addteam_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamNumber resets all changes to the "team_number" field.
func (m *TeamMutation) ResetTeamNumber() {
	m.team_number = nil
	m.addteam_number = nil
}

// SetConfig sets the "config" field.
func (m *TeamMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *TeamMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *TeamMutation) ResetConfig() {
	m._config = nil
}

// SetRevision sets the "revision" field.
func (m *TeamMutation) SetRevision(i int64) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *TeamMutation) Revision() (r int64, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldRevision(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *TeamMutation) AddRevision(i int64) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *TeamMutation) AddedRevision() (r int64, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *TeamMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// AddTeamToUserIDs adds the "TeamToUser" edge to the User entity by ids.
func (m *TeamMutation) AddTeamToUserIDs(ids ...int) {
	if m._TeamToUser == nil {
		m._TeamToUser = make(map[int]struct{})
	}
	for i := range ids {
		m._TeamToUser[ids[i]] = struct{}{}
	}
}

// ClearTeamToUser clears the "TeamToUser" edge to the User entity.
func (m *TeamMutation) ClearTeamToUser() {
	m.cleared_TeamToUser = true
}

// TeamToUserCleared returns if the "TeamToUser" edge to the User entity was cleared.
func (m *TeamMutation) TeamToUserCleared() bool {
	return m.cleared_TeamToUser
}

// RemoveTeamToUserIDs removes the "TeamToUser" edge to the User entity by IDs.
func (m *TeamMutation) RemoveTeamToUserIDs(ids ...int) {
	if m.removed_TeamToUser == nil {
		m.removed_TeamToUser = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TeamToUser[ids[i]] = struct{}{}
	}
}

// RemovedTeamToUser returns the removed IDs of the "TeamToUser" edge to the User entity.
func (m *TeamMutation) RemovedTeamToUserIDs() (ids []int) {
	for id := range m.removed_TeamToUser {
		ids = append(ids, id)
	}
	return
}

// TeamToUserIDs returns the "TeamToUser" edge IDs in the mutation.
func (m *TeamMutation) TeamToUserIDs() (ids []int) {
	for id := range m._TeamToUser {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToUser resets all changes to the "TeamToUser" edge.
func (m *TeamMutation) ResetTeamToUser() {
	m._TeamToUser = nil
	m.cleared_TeamToUser = false
	m.removed_TeamToUser = nil
}

// AddTeamToBuildIDs adds the "TeamToBuild" edge to the Build entity by ids.
func (m *TeamMutation) AddTeamToBuildIDs(ids ...int) {
	if m._TeamToBuild == nil {
		m._TeamToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m._TeamToBuild[ids[i]] = struct{}{}
	}
}

// ClearTeamToBuild clears the "TeamToBuild" edge to the Build entity.
func (m *TeamMutation) ClearTeamToBuild() {
	m.cleared_TeamToBuild = true
}

// TeamToBuildCleared returns if the "TeamToBuild" edge to the Build entity was cleared.
func (m *TeamMutation) TeamToBuildCleared() bool {
	return m.cleared_TeamToBuild
}

// RemoveTeamToBuildIDs removes the "TeamToBuild" edge to the Build entity by IDs.
func (m *TeamMutation) RemoveTeamToBuildIDs(ids ...int) {
	if m.removed_TeamToBuild == nil {
		m.removed_TeamToBuild = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TeamToBuild[ids[i]] = struct{}{}
	}
}

// RemovedTeamToBuild returns the removed IDs of the "TeamToBuild" edge to the Build entity.
func (m *TeamMutation) RemovedTeamToBuildIDs() (ids []int) {
	for id := range m.removed_TeamToBuild {
		ids = append(ids, id)
	}
	return
}

// TeamToBuildIDs returns the "TeamToBuild" edge IDs in the mutation.
func (m *TeamMutation) TeamToBuildIDs() (ids []int) {
	for id := range m._TeamToBuild {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToBuild resets all changes to the "TeamToBuild" edge.
func (m *TeamMutation) ResetTeamToBuild() {
	m._TeamToBuild = nil
	m.cleared_TeamToBuild = false
	m.removed_TeamToBuild = nil
}

// AddTeamToEnvironmentIDs adds the "TeamToEnvironment" edge to the Environment entity by ids.
func (m *TeamMutation) AddTeamToEnvironmentIDs(ids ...int) {
	if m._TeamToEnvironment == nil {
		m._TeamToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._TeamToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearTeamToEnvironment clears the "TeamToEnvironment" edge to the Environment entity.
func (m *TeamMutation) ClearTeamToEnvironment() {
	m.cleared_TeamToEnvironment = true
}

// TeamToEnvironmentCleared returns if the "TeamToEnvironment" edge to the Environment entity was cleared.
func (m *TeamMutation) TeamToEnvironmentCleared() bool {
	return m.cleared_TeamToEnvironment
}

// RemoveTeamToEnvironmentIDs removes the "TeamToEnvironment" edge to the Environment entity by IDs.
func (m *TeamMutation) RemoveTeamToEnvironmentIDs(ids ...int) {
	if m.removed_TeamToEnvironment == nil {
		m.removed_TeamToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TeamToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedTeamToEnvironment returns the removed IDs of the "TeamToEnvironment" edge to the Environment entity.
func (m *TeamMutation) RemovedTeamToEnvironmentIDs() (ids []int) {
	for id := range m.removed_TeamToEnvironment {
		ids = append(ids, id)
	}
	return
}

// TeamToEnvironmentIDs returns the "TeamToEnvironment" edge IDs in the mutation.
func (m *TeamMutation) TeamToEnvironmentIDs() (ids []int) {
	for id := range m._TeamToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToEnvironment resets all changes to the "TeamToEnvironment" edge.
func (m *TeamMutation) ResetTeamToEnvironment() {
	m._TeamToEnvironment = nil
	m.cleared_TeamToEnvironment = false
	m.removed_TeamToEnvironment = nil
}

// AddTeamToTagIDs adds the "TeamToTag" edge to the Tag entity by ids.
func (m *TeamMutation) AddTeamToTagIDs(ids ...int) {
	if m._TeamToTag == nil {
		m._TeamToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._TeamToTag[ids[i]] = struct{}{}
	}
}

// ClearTeamToTag clears the "TeamToTag" edge to the Tag entity.
func (m *TeamMutation) ClearTeamToTag() {
	m.cleared_TeamToTag = true
}

// TeamToTagCleared returns if the "TeamToTag" edge to the Tag entity was cleared.
func (m *TeamMutation) TeamToTagCleared() bool {
	return m.cleared_TeamToTag
}

// RemoveTeamToTagIDs removes the "TeamToTag" edge to the Tag entity by IDs.
func (m *TeamMutation) RemoveTeamToTagIDs(ids ...int) {
	if m.removed_TeamToTag == nil {
		m.removed_TeamToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TeamToTag[ids[i]] = struct{}{}
	}
}

// RemovedTeamToTag returns the removed IDs of the "TeamToTag" edge to the Tag entity.
func (m *TeamMutation) RemovedTeamToTagIDs() (ids []int) {
	for id := range m.removed_TeamToTag {
		ids = append(ids, id)
	}
	return
}

// TeamToTagIDs returns the "TeamToTag" edge IDs in the mutation.
func (m *TeamMutation) TeamToTagIDs() (ids []int) {
	for id := range m._TeamToTag {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToTag resets all changes to the "TeamToTag" edge.
func (m *TeamMutation) ResetTeamToTag() {
	m._TeamToTag = nil
	m.cleared_TeamToTag = false
	m.removed_TeamToTag = nil
}

// AddTeamToProvisionedNetworkIDs adds the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity by ids.
func (m *TeamMutation) AddTeamToProvisionedNetworkIDs(ids ...int) {
	if m._TeamToProvisionedNetwork == nil {
		m._TeamToProvisionedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m._TeamToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// ClearTeamToProvisionedNetwork clears the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *TeamMutation) ClearTeamToProvisionedNetwork() {
	m.cleared_TeamToProvisionedNetwork = true
}

// TeamToProvisionedNetworkCleared returns if the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *TeamMutation) TeamToProvisionedNetworkCleared() bool {
	return m.cleared_TeamToProvisionedNetwork
}

// RemoveTeamToProvisionedNetworkIDs removes the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity by IDs.
func (m *TeamMutation) RemoveTeamToProvisionedNetworkIDs(ids ...int) {
	if m.removed_TeamToProvisionedNetwork == nil {
		m.removed_TeamToProvisionedNetwork = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_TeamToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedTeamToProvisionedNetwork returns the removed IDs of the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *TeamMutation) RemovedTeamToProvisionedNetworkIDs() (ids []int) {
	for id := range m.removed_TeamToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// TeamToProvisionedNetworkIDs returns the "TeamToProvisionedNetwork" edge IDs in the mutation.
func (m *TeamMutation) TeamToProvisionedNetworkIDs() (ids []int) {
	for id := range m._TeamToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToProvisionedNetwork resets all changes to the "TeamToProvisionedNetwork" edge.
func (m *TeamMutation) ResetTeamToProvisionedNetwork() {
	m._TeamToProvisionedNetwork = nil
	m.cleared_TeamToProvisionedNetwork = false
	m.removed_TeamToProvisionedNetwork = nil
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.team_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	if m._config != nil {
		fields = append(fields, team.FieldConfig)
	}
	if m.revision != nil {
		fields = append(fields, team.FieldRevision)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.TeamNumber()
	case team.FieldConfig:
		return m.Config()
	case team.FieldRevision:
		return m.Revision()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldTeamNumber:
		return m.OldTeamNumber(ctx)
	case team.FieldConfig:
		return m.OldConfig(ctx)
	case team.FieldRevision:
		return m.OldRevision(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamNumber(v)
		return nil
	case team.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case team.FieldRevision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addteam_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	if m.addrevision != nil {
		fields = append(fields, team.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.AddedTeamNumber()
	case team.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamNumber(v)
		return nil
	case team.FieldRevision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldTeamNumber:
		m.ResetTeamNumber()
		return nil
	case team.FieldConfig:
		m.ResetConfig()
		return nil
	case team.FieldRevision:
		m.ResetRevision()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._TeamToUser != nil {
		edges = append(edges, team.EdgeTeamToUser)
	}
	if m._TeamToBuild != nil {
		edges = append(edges, team.EdgeTeamToBuild)
	}
	if m._TeamToEnvironment != nil {
		edges = append(edges, team.EdgeTeamToEnvironment)
	}
	if m._TeamToTag != nil {
		edges = append(edges, team.EdgeTeamToTag)
	}
	if m._TeamToProvisionedNetwork != nil {
		edges = append(edges, team.EdgeTeamToProvisionedNetwork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeTeamToUser:
		ids := make([]ent.Value, 0, len(m._TeamToUser))
		for id := range m._TeamToUser {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToBuild:
		ids := make([]ent.Value, 0, len(m._TeamToBuild))
		for id := range m._TeamToBuild {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToEnvironment:
		ids := make([]ent.Value, 0, len(m._TeamToEnvironment))
		for id := range m._TeamToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToTag:
		ids := make([]ent.Value, 0, len(m._TeamToTag))
		for id := range m._TeamToTag {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m._TeamToProvisionedNetwork))
		for id := range m._TeamToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_TeamToUser != nil {
		edges = append(edges, team.EdgeTeamToUser)
	}
	if m.removed_TeamToBuild != nil {
		edges = append(edges, team.EdgeTeamToBuild)
	}
	if m.removed_TeamToEnvironment != nil {
		edges = append(edges, team.EdgeTeamToEnvironment)
	}
	if m.removed_TeamToTag != nil {
		edges = append(edges, team.EdgeTeamToTag)
	}
	if m.removed_TeamToProvisionedNetwork != nil {
		edges = append(edges, team.EdgeTeamToProvisionedNetwork)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeTeamToUser:
		ids := make([]ent.Value, 0, len(m.removed_TeamToUser))
		for id := range m.removed_TeamToUser {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToBuild:
		ids := make([]ent.Value, 0, len(m.removed_TeamToBuild))
		for id := range m.removed_TeamToBuild {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_TeamToEnvironment))
		for id := range m.removed_TeamToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToTag:
		ids := make([]ent.Value, 0, len(m.removed_TeamToTag))
		for id := range m.removed_TeamToTag {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_TeamToProvisionedNetwork))
		for id := range m.removed_TeamToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_TeamToUser {
		edges = append(edges, team.EdgeTeamToUser)
	}
	if m.cleared_TeamToBuild {
		edges = append(edges, team.EdgeTeamToBuild)
	}
	if m.cleared_TeamToEnvironment {
		edges = append(edges, team.EdgeTeamToEnvironment)
	}
	if m.cleared_TeamToTag {
		edges = append(edges, team.EdgeTeamToTag)
	}
	if m.cleared_TeamToProvisionedNetwork {
		edges = append(edges, team.EdgeTeamToProvisionedNetwork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeTeamToUser:
		return m.cleared_TeamToUser
	case team.EdgeTeamToBuild:
		return m.cleared_TeamToBuild
	case team.EdgeTeamToEnvironment:
		return m.cleared_TeamToEnvironment
	case team.EdgeTeamToTag:
		return m.cleared_TeamToTag
	case team.EdgeTeamToProvisionedNetwork:
		return m.cleared_TeamToProvisionedNetwork
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeTeamToUser:
		m.ResetTeamToUser()
		return nil
	case team.EdgeTeamToBuild:
		m.ResetTeamToBuild()
		return nil
	case team.EdgeTeamToEnvironment:
		m.ResetTeamToEnvironment()
		return nil
	case team.EdgeTeamToTag:
		m.ResetTeamToTag()
		return nil
	case team.EdgeTeamToProvisionedNetwork:
		m.ResetTeamToProvisionedNetwork()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	uuid                      *string
	email                     *string
	hcl_id                    *string
	clearedFields             map[string]struct{}
	_UserToTag                map[int]struct{}
	removed_UserToTag         map[int]struct{}
	cleared_UserToTag         bool
	_UserToEnvironment        map[int]struct{}
	removed_UserToEnvironment map[int]struct{}
	cleared_UserToEnvironment bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetHclID sets the "hcl_id" field.
func (m *UserMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *UserMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *UserMutation) ResetHclID() {
	m.hcl_id = nil
}

// AddUserToTagIDs adds the "UserToTag" edge to the Tag entity by ids.
func (m *UserMutation) AddUserToTagIDs(ids ...int) {
	if m._UserToTag == nil {
		m._UserToTag = make(map[int]struct{})
	}
	for i := range ids {
		m._UserToTag[ids[i]] = struct{}{}
	}
}

// ClearUserToTag clears the "UserToTag" edge to the Tag entity.
func (m *UserMutation) ClearUserToTag() {
	m.cleared_UserToTag = true
}

// UserToTagCleared returns if the "UserToTag" edge to the Tag entity was cleared.
func (m *UserMutation) UserToTagCleared() bool {
	return m.cleared_UserToTag
}

// RemoveUserToTagIDs removes the "UserToTag" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveUserToTagIDs(ids ...int) {
	if m.removed_UserToTag == nil {
		m.removed_UserToTag = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_UserToTag[ids[i]] = struct{}{}
	}
}

// RemovedUserToTag returns the removed IDs of the "UserToTag" edge to the Tag entity.
func (m *UserMutation) RemovedUserToTagIDs() (ids []int) {
	for id := range m.removed_UserToTag {
		ids = append(ids, id)
	}
	return
}

// UserToTagIDs returns the "UserToTag" edge IDs in the mutation.
func (m *UserMutation) UserToTagIDs() (ids []int) {
	for id := range m._UserToTag {
		ids = append(ids, id)
	}
	return
}

// ResetUserToTag resets all changes to the "UserToTag" edge.
func (m *UserMutation) ResetUserToTag() {
	m._UserToTag = nil
	m.cleared_UserToTag = false
	m.removed_UserToTag = nil
}

// AddUserToEnvironmentIDs adds the "UserToEnvironment" edge to the Environment entity by ids.
func (m *UserMutation) AddUserToEnvironmentIDs(ids ...int) {
	if m._UserToEnvironment == nil {
		m._UserToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m._UserToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearUserToEnvironment clears the "UserToEnvironment" edge to the Environment entity.
func (m *UserMutation) ClearUserToEnvironment() {
	m.cleared_UserToEnvironment = true
}

// UserToEnvironmentCleared returns if the "UserToEnvironment" edge to the Environment entity was cleared.
func (m *UserMutation) UserToEnvironmentCleared() bool {
	return m.cleared_UserToEnvironment
}

// RemoveUserToEnvironmentIDs removes the "UserToEnvironment" edge to the Environment entity by IDs.
func (m *UserMutation) RemoveUserToEnvironmentIDs(ids ...int) {
	if m.removed_UserToEnvironment == nil {
		m.removed_UserToEnvironment = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_UserToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedUserToEnvironment returns the removed IDs of the "UserToEnvironment" edge to the Environment entity.
func (m *UserMutation) RemovedUserToEnvironmentIDs() (ids []int) {
	for id := range m.removed_UserToEnvironment {
		ids = append(ids, id)
	}
	return
}

// UserToEnvironmentIDs returns the "UserToEnvironment" edge IDs in the mutation.
func (m *UserMutation) UserToEnvironmentIDs() (ids []int) {
	for id := range m._UserToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetUserToEnvironment resets all changes to the "UserToEnvironment" edge.
func (m *UserMutation) ResetUserToEnvironment() {
	m._UserToEnvironment = nil
	m.cleared_UserToEnvironment = false
	m.removed_UserToEnvironment = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.hcl_id != nil {
		fields = append(fields, user.FieldHclID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldHclID:
		return m.HclID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldHclID:
		return m.OldHclID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldHclID:
		m.ResetHclID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._UserToTag != nil {
		edges = append(edges, user.EdgeUserToTag)
	}
	if m._UserToEnvironment != nil {
		edges = append(edges, user.EdgeUserToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserToTag:
		ids := make([]ent.Value, 0, len(m._UserToTag))
		for id := range m._UserToTag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserToEnvironment:
		ids := make([]ent.Value, 0, len(m._UserToEnvironment))
		for id := range m._UserToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_UserToTag != nil {
		edges = append(edges, user.EdgeUserToTag)
	}
	if m.removed_UserToEnvironment != nil {
		edges = append(edges, user.EdgeUserToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserToTag:
		ids := make([]ent.Value, 0, len(m.removed_UserToTag))
		for id := range m.removed_UserToTag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_UserToEnvironment))
		for id := range m.removed_UserToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_UserToTag {
		edges = append(edges, user.EdgeUserToTag)
	}
	if m.cleared_UserToEnvironment {
		edges = append(edges, user.EdgeUserToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserToTag:
		return m.cleared_UserToTag
	case user.EdgeUserToEnvironment:
		return m.cleared_UserToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserToTag:
		m.ResetUserToTag()
		return nil
	case user.EdgeUserToEnvironment:
		m.ResetUserToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
